This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
    testflight.yml
maestro/
  config.yaml
  create_account_test.yaml
  login_with_hex_test.yaml
  login_with_nsec_test.yaml
  README.md
Olas/
  App/
    AppState.swift
    OlasApp.swift
  Assets.xcassets/
    AppIcon.appiconset/
      Contents.json
    Contents.json
  Components/
    BlurhashView.swift
    TimeBasedGradient.swift
  DataSources/
    NostrDataSources.swift
  Models/
    BlossomServerManager.swift
    Color+Extensions.swift
    DesignSystem.swift
    ImetaUtils.swift
    NostrManager.swift
    StoriesManager.swift
    WalletManager.swift
  Utils/
    OlasUtilities.swift
  Views/
    Analytics/
      AnalyticsDashboardView.swift
    Components/
      AdvancedCameraView.swift
      HeartAnimation.swift
      LiveUpdatesIndicator.swift
      OlasAvatar.swift
      OlasButton.swift
      OlasCameraView.swift
      OlasCaptionComposer.swift
      OlasImageEditor.swift
      OlasMultiImageView.swift
      OlasRichText.swift
      ReplyView.swift
      ZapView.swift
    Explore/
      CategoryPill.swift
      ExploreGridItem.swift
      ExploreView.swift
      HashtagView.swift
      TrendingHashtagPill.swift
    Onboarding/
      OnboardingView.swift
    Profile/
      FollowersListView.swift
    Search/
      SearchView.swift
    Settings/
      AccountSettingsView.swift
      NotificationSettingsView.swift
      RelayManagementView.swift
      ThemeSettingsView.swift
    Stories/
      CreateStoryView.swift
      OlasStoriesView.swift
      StoriesContainerView.swift
      StoriesView.swift
    Wallet/
      Components/
        GlassmorphicComponents.swift
        ModernStatCard.swift
        OlasBalanceCard.swift
        OlasEnhancedBalanceCard.swift
        WalletComponents.swift
        WalletContactsScrollView.swift
        WalletUIHelpers.swift
      AddMintView.swift
      MintManagementView.swift
      NutZapView.swift
      OlasWalletView.swift
      QRScannerView.swift
      ReceiveView.swift
      SendView.swift
      TransactionDetailView.swift
      WalletView.swift
    AuthenticationView.swift
    ContentView.swift
    CreateAccountView.swift
    CreatePostView.swift
    FeedView.swift
    MainTabView.swift
    PostDetailView.swift
    ProfileView.swift
  Info.plist
  LaunchScreen.storyboard
Olas.xcodeproj/
  project.xcworkspace/
    xcshareddata/
      swiftpm/
        configuration/
        Package.resolved
    contents.xcworkspacedata
  xcshareddata/
Sources/
  Olas/
    App/
      OlasApp.swift
    Models/
      DesignSystem.swift
      ImageMetadata.swift
    Views/
      Authentication/
        AuthenticationView.swift
        CreateAccountView.swift
      Components/
        OlasMultiImageView.swift
        OlasRichText.swift
      Create/
        CreatePostView.swift
      Main/
        MainTabView.swift
      Profile/
        ProfileView.swift
      Settings/
        AccountSettingsView.swift
        NotificationSettingsView.swift
        RelayManagementView.swift
        SettingsView.swift
        ThemeSettingsView.swift
      ContentView.swift
Tests/
  OlasTests/
    OlasTests.swift
.gitignore
build.sh
deploy.sh
ExportOptions-TestFlight.plist
LICENSE
MODERNIZATION_SUMMARY.md
Olas-progress.md
Package.swift
project.yml
README.md
refresh-project.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="maestro/config.yaml">
# Maestro Configuration for Olas
# Test Tags - useful for organizing and filtering tests
tags:
  - auth
  - onboarding
  - account
# Environment variables (if needed)
env:
  APP_ID: com.olas.app
# Global test configuration
testExecutionOrder: sequential
# Test flows
flows:
  - create_account_test.yaml
  - login_with_nsec_test.yaml
  - login_with_hex_test.yaml
</file>

<file path="maestro/create_account_test.yaml">
appId: com.olas.app
---
- launchApp
# Wait for the app to load
- waitForAnimationToEnd
# Verify we're on the authentication screen
- assertVisible: "Olas"
- assertVisible: "Welcome back"
# Tap "I'm New Here" button
- tapOn: "I'm New Here"
# Wait for onboarding screen
- waitForAnimationToEnd
# Page 1: Welcome Page
- assertVisible: "Picture-First Social"
- swipe:
    direction: LEFT
# Page 2: Nostr Explainer
- assertVisible: "Your Content, Everywhere"
- swipe:
    direction: LEFT
# Page 3: Key Generation
- assertVisible: "Creating Your Identity"
# Wait for automatic key generation (happens after 2 seconds)
- waitForAnimationToEnd:
    timeout: 5000
- assertVisible: "Your Identity is Ready"
- swipe:
    direction: LEFT
# Page 4: Security Education
- assertVisible: "Your Keys, Your Control"
- assertVisible: "Get Started"
- tapOn: "Get Started"
# Wait for account creation and main feed
- waitForAnimationToEnd:
    timeout: 10000
# Verify we're now on the main feed
- assertVisible:
    text: "Olas"
    index: 0
# Verify bottom tab bar is visible (indicates successful login)
- assertVisible:
    id: "mainTabBar"
# Verify feed tab is selected
- assertVisible:
    id: "feedTab"
# Optional: Verify profile was created by navigating to profile
- tapOn:
    id: "profileTab"
- waitForAnimationToEnd
# Should see the default display name from onboarding
- assertVisible: "Olas User"
</file>

<file path="maestro/login_with_hex_test.yaml">
appId: com.olas.app
---
- launchApp
# Wait for the app to load
- waitForAnimationToEnd
# Verify we're on the authentication screen
- assertVisible: "Olas"
- assertVisible: "Welcome back"
# Tap "I Have an Account" button
- tapOn: "I Have an Account"
# Wait for login sheet
- waitForAnimationToEnd
# Verify login sheet elements
- assertVisible: "Welcome Back"
- assertVisible: "Enter your private key (nsec or hex format)"
# Enter a hex private key (this is a test key - DO NOT use real keys in tests)
- tapOn:
    id: "privateKeyField"
- inputText: "7f3b464b9ff3623630485983fdf8c44b4b8abfe3dcd3dc2fe8c9ed82e5d584f6"
# Tap login button
- tapOn: "Login"
# Wait for login to complete
- waitForAnimationToEnd:
    timeout: 10000
# Verify we're now on the main feed
- assertVisible:
    text: "Olas"
    index: 0
# Verify bottom tab bar is visible (indicates successful login)
- assertVisible:
    id: "mainTabBar"
# Verify feed tab is selected
- assertVisible:
    id: "feedTab"
</file>

<file path="maestro/login_with_nsec_test.yaml">
appId: com.olas.app
---
- launchApp
# Wait for the app to load
- waitForAnimationToEnd
# Verify we're on the authentication screen
- assertVisible: "Olas"
- assertVisible: "Welcome back"
# Tap "I Have an Account" button
- tapOn: "I Have an Account"
# Wait for login sheet
- waitForAnimationToEnd
# Verify login sheet elements
- assertVisible: "Welcome Back"
- assertVisible: "Enter your private key (nsec or hex format)"
# Enter an nsec key (this is a test key - DO NOT use real keys in tests)
- tapOn:
    id: "privateKeyField"
- inputText: "nsec1vl029mgpspedva04g90vltkh6fvh240zqtv9k0t9af8935ke9laqsnlfe5"
# Tap login button
- tapOn: "Login"
# Wait for login to complete
- waitForAnimationToEnd:
    timeout: 10000
# Verify we're now on the main feed
- assertVisible:
    text: "Olas"
    index: 0
# Verify bottom tab bar is visible (indicates successful login)
- assertVisible:
    id: "mainTabBar"
# Verify feed tab is selected
- assertVisible:
    id: "feedTab"
</file>

<file path="maestro/README.md">
# Olas Maestro Tests

This directory contains Maestro UI tests for the Olas iOS app.

## Prerequisites

1. Install Maestro CLI:
```bash
curl -Ls "https://get.maestro.mobile.dev" | bash
```

2. Make sure you have the iOS Simulator installed via Xcode.

## Running Tests

### Run all tests:
```bash
maestro test maestro/
```

### Run a specific test:
```bash
maestro test maestro/create_account_test.yaml
```

### Run tests with specific device:
```bash
maestro test --device "iPhone 15 Pro" maestro/
```

## Test Files

- `create_account_test.yaml` - Tests the new account creation flow through onboarding
- `login_with_nsec_test.yaml` - Tests login with nsec private key format
- `login_with_hex_test.yaml` - Tests login with hex private key format
- `config.yaml` - Maestro configuration file

## Important Notes

1. **Private Keys**: The private keys used in the login tests are TEST KEYS ONLY. Never use real private keys in test files.

2. **Test Data**: Account creation uses dynamic timestamps to ensure unique usernames.

3. **Timeouts**: Some operations (like account creation) may take time due to network requests. Timeouts are configured accordingly.

## Writing New Tests

When adding new tests:

1. Use accessibility identifiers in the SwiftUI code for reliable element selection
2. Add appropriate waits for animations and network operations
3. Keep tests focused on a single user flow
4. Document any test data requirements

## Troubleshooting

- If tests fail on element not found, check that accessibility identifiers are properly set in the code
- For timing issues, increase timeout values or add `waitForAnimationToEnd` commands
- Use `maestro studio` to interactively explore the app and find elements
</file>

<file path="Olas.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved">
{
  "originHash" : "4bbea0d3b72726fa4bd0f2e2af7ec8b45cdc1d533cb0a1a8a6dfdc1e577aac17",
  "pins" : [
    {
      "identity" : "base58",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/anquii/Base58.git",
      "state" : {
        "revision" : "7e4a1e4e6813c750ed2f9e80a0494c608eebb2ca",
        "version" : "1.0.1"
      }
    },
    {
      "identity" : "base58check",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/anquii/Base58Check.git",
      "state" : {
        "revision" : "f35a770ff7f3fd553cc44057f492c0107cc7b481",
        "version" : "1.0.1"
      }
    },
    {
      "identity" : "bigint",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/attaswift/BigInt.git",
      "state" : {
        "revision" : "0ed110f7555c34ff468e72e1686e59721f2b0da6",
        "version" : "5.3.0"
      }
    },
    {
      "identity" : "bip32",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/zeugmaster/BIP32.git",
      "state" : {
        "branch" : "main",
        "revision" : "1be94093fb7fe87dc0ccc8e2c041cc05218efff6"
      }
    },
    {
      "identity" : "bip39",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pengpengliu/BIP39.git",
      "state" : {
        "revision" : "e79bd90275e50643cf8f97208ffa536d0def3ec7",
        "version" : "1.0.1"
      }
    },
    {
      "identity" : "cashuswift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/zeugmaster/CashuSwift.git",
      "state" : {
        "branch" : "main",
        "revision" : "d703a9b2035d1240e4476d3c37d2cd967f0c3d75"
      }
    },
    {
      "identity" : "cryptoswiftwrapper",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/anquii/CryptoSwiftWrapper.git",
      "state" : {
        "revision" : "0d57e806de368b5d2364fabb7c789b48661ec90c",
        "version" : "1.4.3"
      }
    },
    {
      "identity" : "grdb.swift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/groue/GRDB.swift.git",
      "state" : {
        "revision" : "2cf6c756e1e5ef6901ebae16576a7e4e4b834622",
        "version" : "6.29.3"
      }
    },
    {
      "identity" : "ndkswift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pablof7z/NDKSwift",
      "state" : {
        "branch" : "master",
        "revision" : "c88959125ef52409f3976d4c8fcfc0e4874b7872"
      }
    },
    {
      "identity" : "ripemd160",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/anquii/RIPEMD160.git",
      "state" : {
        "revision" : "15679c6fe1f3ae32ec1bad63bcc45aa422954f01",
        "version" : "1.0.0"
      }
    },
    {
      "identity" : "swift-bigint",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mkrd/Swift-BigInt.git",
      "state" : {
        "revision" : "b07e961f4c999671cf8c2dc80e740899e8946013",
        "version" : "2.3.0"
      }
    },
    {
      "identity" : "swift-secp256k1",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/zeugmaster/swift-secp256k1.git",
      "state" : {
        "branch" : "main",
        "revision" : "73cf2403b7a69de8efc612d251a6e0d01211e1c4"
      }
    },
    {
      "identity" : "swiftcbor",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/myfreeweb/SwiftCBOR.git",
      "state" : {
        "revision" : "04ccff117f6549121d5721ec84fdf0162122b90e",
        "version" : "0.5.0"
      }
    }
  ],
  "version" : 3
}
</file>

<file path=".github/workflows/ci.yml">
name: CI
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  build:
    name: Build and Test
    runs-on: macos-14
    steps:
    - uses: actions/checkout@v4
    - name: Select Xcode
      run: sudo xcode-select -s /Applications/Xcode_15.4.app
    - name: Install XcodeGen
      run: brew install xcodegen
    - name: Install xcbeautify
      run: brew install xcbeautify
    - name: Generate Xcode project
      run: ./refresh-project.sh
    - name: Build
      run: |
        xcodebuild build \
          -project Olas.xcodeproj \
          -scheme Olas \
          -destination 'platform=iOS Simulator,name=iPhone 15 Pro' \
          | xcbeautify
    - name: Run tests
      run: |
        xcodebuild test \
          -project Olas.xcodeproj \
          -scheme Olas \
          -destination 'platform=iOS Simulator,name=iPhone 15 Pro' \
          | xcbeautify || true
</file>

<file path=".github/workflows/testflight.yml">
name: Deploy to TestFlight
on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
jobs:
  deploy:
    name: Deploy to TestFlight
    runs-on: macos-14
    steps:
    - uses: actions/checkout@v4
    - name: Select Xcode
      run: sudo xcode-select -s /Applications/Xcode_15.4.app
    - name: Install dependencies
      run: |
        brew install xcodegen
        brew install xcbeautify
    - name: Setup API Key
      env:
        APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
      run: |
        mkdir -p ~/.appstoreconnect/private_keys
        echo "$APP_STORE_CONNECT_API_KEY" > ~/.appstoreconnect/private_keys/AuthKey_6VZ4NHWMQN.p8
    - name: Generate Xcode project
      run: ./refresh-project.sh
    - name: Build and deploy
      env:
        API_KEY_ID: "6VZ4NHWMQN"
        API_ISSUER_ID: "0acdb473-8d3f-4eba-85bc-d2de82234bea"
      run: |
        xcodebuild archive \
          -project Olas.xcodeproj \
          -scheme Olas \
          -configuration Release \
          -archivePath build/Olas.xcarchive \
          -destination "generic/platform=iOS" \
          CODE_SIGN_STYLE=Automatic \
          DEVELOPMENT_TEAM="456SHKPP26" \
          | xcbeautify
        xcodebuild -exportArchive \
          -archivePath build/Olas.xcarchive \
          -exportPath build \
          -exportOptionsPlist ExportOptions-TestFlight.plist \
          | xcbeautify
        xcrun altool --upload-app \
          -f build/Olas.ipa \
          -t ios \
          --apiKey "$API_KEY_ID" \
          --apiIssuer "$API_ISSUER_ID"
</file>

<file path="Olas/App/AppState.swift">
import SwiftUI
import NDKSwift
import Observation
// MARK: - App State
@MainActor
class AppState: ObservableObject {
    @Published var isAuthenticated = false
    @Published var currentUser: NDKUser?
    // UI state
    @Published var selectedTab = 0
    @Published var isCreatingPost = false
    @Published var selectedImage: Data?
    @Published var replyingTo: NDKEvent?
    // Lazy reference to NostrManager
    private weak var nostrManager: NostrManager?
    func setNostrManager(_ manager: NostrManager) {
        self.nostrManager = manager
        // Observe authentication state
        Task {
            await observeAuthState()
        }
    }
    private func observeAuthState() async {
        guard let nostrManager = nostrManager else { return }
        // Initial update
        await updateAuthState()
        // Continuously observe auth state changes
        Task { @MainActor in
            while true {
                withObservationTracking {
                    _ = nostrManager.isAuthenticated
                } onChange: { [weak self] in
                    Task { @MainActor in
                        await self?.updateAuthState()
                    }
                }
                // Check every second for auth state changes
                try? await Task.sleep(nanoseconds: 1_000_000_000)
            }
        }
    }
    private func updateAuthState() async {
        guard let nostrManager = nostrManager else { return }
        isAuthenticated = nostrManager.isAuthenticated
        currentUser = await nostrManager.currentUser
    }
    func reset() {
        isAuthenticated = false
        currentUser = nil
        selectedImage = nil
        replyingTo = nil
        isCreatingPost = false
    }
}
</file>

<file path="Olas/App/OlasApp.swift">
import SwiftUI
import NDKSwift
@main
struct OlasApp: App {
    @State private var nostrManager: NostrManager
    @StateObject private var appState = AppState()
    @StateObject private var blossomServerManager: BlossomServerManager
    init() {
        let manager = NostrManager()
        self._nostrManager = State(initialValue: manager)
        self._appState = StateObject(wrappedValue: AppState())
        self._blossomServerManager = StateObject(wrappedValue: BlossomServerManager(ndk: manager.ndk))
    }
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(nostrManager)
                .environmentObject(appState)
                .environmentObject(blossomServerManager)
                .preferredColorScheme(.dark)
        }
    }
}
</file>

<file path="Olas/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Olas/Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Olas/Components/BlurhashView.swift">
import SwiftUI
#if os(iOS)
import UIKit
#endif
// MARK: - String Extension for SHA256
extension String {
    var sha256Hash: String {
        // Simple hash for demo - in production use CryptoKit
        let hash = self.hashValue
        return String(format: "%016llx", Int64(bitPattern: UInt64(bitPattern: Int64(hash))))
    }
}
// MARK: - Blurhash View
struct BlurhashView: View {
    let hash: String
    #if os(iOS)
    @State private var image: UIImage?
    #else
    @State private var image: NSImage?
    #endif
    @State private var opacity: Double = 1.0
    var body: some View {
        ZStack {
            if let image = image {
                #if os(iOS)
                SwiftUI.Image(uiImage: image)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .opacity(opacity)
                    .transition(.opacity)
                #else
                SwiftUI.Image(nsImage: image)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .opacity(opacity)
                    .transition(.opacity)
                #endif
            } else {
                Rectangle()
                    .fill(
                        LinearGradient(
                            colors: [
                                Color(.systemGray5),
                                Color(.systemGray6)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
            }
        }
        .onAppear {
            decodeHash()
        }
    }
    private func decodeHash() {
        DispatchQueue.global(qos: .userInitiated).async {
            // Decode blurhash (placeholder implementation)
            // In production, use a proper blurhash library
            let placeholderImage = createPlaceholderImage(from: hash)
            DispatchQueue.main.async {
                withAnimation(.easeOut(duration: 0.3)) {
                    self.image = placeholderImage
                }
            }
        }
    }
    #if os(iOS)
    private func createPlaceholderImage(from hash: String) -> UIImage? {
        // Create a gradient placeholder based on hash
        let size = CGSize(width: 32, height: 32)
        let renderer = UIGraphicsImageRenderer(size: size)
        return renderer.image { context in
            // Extract colors from hash (simplified)
            let hashValue = hash.hashValue
            let hue1 = CGFloat(abs(hashValue % 360)) / 360.0
            let hue2 = CGFloat(abs((hashValue >> 8) % 360)) / 360.0
            let color1 = UIColor(hue: hue1, saturation: 0.5, brightness: 0.8, alpha: 1.0)
            let color2 = UIColor(hue: hue2, saturation: 0.5, brightness: 0.6, alpha: 1.0)
            let gradient = CGGradient(
                colorsSpace: CGColorSpaceCreateDeviceRGB(),
                colors: [color1.cgColor, color2.cgColor] as CFArray,
                locations: [0, 1]
            )!
            context.cgContext.drawLinearGradient(
                gradient,
                start: CGPoint(x: 0, y: 0),
                end: CGPoint(x: size.width, y: size.height),
                options: []
            )
        }
    }
    #else
    private func createPlaceholderImage(from hash: String) -> NSImage? {
        // macOS implementation
        let size = CGSize(width: 32, height: 32)
        let image = NSImage(size: size)
        image.lockFocus()
        let hashValue = hash.hashValue
        let hue1 = CGFloat(abs(hashValue % 360)) / 360.0
        let hue2 = CGFloat(abs((hashValue >> 8) % 360)) / 360.0
        let color1 = NSColor(hue: hue1, saturation: 0.5, brightness: 0.8, alpha: 1.0)
        let color2 = NSColor(hue: hue2, saturation: 0.5, brightness: 0.6, alpha: 1.0)
        let gradient = NSGradient(colors: [color1, color2])
        gradient?.draw(in: NSRect(origin: .zero, size: size), angle: 45)
        image.unlockFocus()
        return image
    }
    #endif
}
// MARK: - Progressive Image View
struct OlasProgressiveImage: View {
    let imageURL: String
    let blurhash: String?
    @State private var phase: ImagePhase = .empty
    #if os(iOS)
    @State private var lowQualityImage: UIImage?
    @State private var highQualityImage: UIImage?
    #else
    @State private var lowQualityImage: NSImage?
    @State private var highQualityImage: NSImage?
    #endif
    @State private var progress: Double = 0
    @State private var showHighQuality = false
    enum ImagePhase {
        case empty
        case blurhash
        case lowQuality
        case highQuality
    }
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Layer 1: Blurhash or placeholder
                if let blurhash = blurhash {
                    BlurhashView(hash: blurhash)
                        .opacity(phase == .empty || phase == .blurhash ? 1 : 0)
                        .animation(.easeOut(duration: 0.3), value: phase)
                } else {
                    OlasShimmer()
                        .opacity(phase == .empty ? 1 : 0)
                        .animation(.easeOut(duration: 0.3), value: phase)
                }
                // Layer 2: Low quality image
                if let lowQualityImage = lowQualityImage {
                    #if os(iOS)
                    SwiftUI.Image(uiImage: lowQualityImage)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .opacity(phase == .lowQuality && !showHighQuality ? 1 : 0)
                        .animation(.easeOut(duration: 0.3), value: phase)
                        .animation(.easeOut(duration: 0.3), value: showHighQuality)
                    #else
                    SwiftUI.Image(nsImage: lowQualityImage)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .opacity(phase == .lowQuality && !showHighQuality ? 1 : 0)
                        .animation(.easeOut(duration: 0.3), value: phase)
                        .animation(.easeOut(duration: 0.3), value: showHighQuality)
                    #endif
                }
                // Layer 3: High quality image
                if let highQualityImage = highQualityImage {
                    #if os(iOS)
                    SwiftUI.Image(uiImage: highQualityImage)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .opacity(showHighQuality ? 1 : 0)
                        .animation(.easeOut(duration: 0.5), value: showHighQuality)
                    #else
                    SwiftUI.Image(nsImage: highQualityImage)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .opacity(showHighQuality ? 1 : 0)
                        .animation(.easeOut(duration: 0.5), value: showHighQuality)
                    #endif
                }
                // Loading progress indicator
                if phase == .lowQuality && progress < 1.0 {
                    VStack {
                        Spacer()
                        ProgressView(value: progress)
                            .progressViewStyle(LinearProgressViewStyle(tint: .white))
                            .scaleEffect(x: 1, y: 0.5)
                            .padding(.horizontal, OlasDesign.Spacing.md)
                            .padding(.bottom, OlasDesign.Spacing.sm)
                            .opacity(0.8)
                    }
                }
            }
            .frame(width: geometry.size.width, height: geometry.size.height)
            .clipped()
            .onAppear {
                loadImage(size: geometry.size)
            }
        }
    }
    private func loadImage(size: CGSize) {
        // Start with blurhash
        if blurhash != nil {
            phase = .blurhash
        }
        guard let url = URL(string: imageURL) else { return }
        // Load low quality version first
        Task {
            await loadLowQuality(from: url, targetSize: CGSize(width: size.width * 0.25, height: size.height * 0.25))
        }
        // Then load high quality
        Task {
            await loadHighQuality(from: url, targetSize: size)
        }
    }
    private func loadLowQuality(from url: URL, targetSize: CGSize) async {
        // Simulate progressive loading with URLSession
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            #if os(iOS)
            if let image = UIImage(data: data) {
                let resized = await resizeImage(image, to: targetSize)
                await MainActor.run {
                    self.lowQualityImage = resized
                    self.phase = .lowQuality
                }
            }
            #else
            if let image = NSImage(data: data) {
                let resized = await resizeImage(image, to: targetSize)
                await MainActor.run {
                    self.lowQualityImage = resized
                    self.phase = .lowQuality
                }
            }
            #endif
        } catch {
            print("Failed to load low quality image: \(error)")
        }
    }
    private func loadHighQuality(from url: URL, targetSize: CGSize) async {
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            #if os(iOS)
            if let image = UIImage(data: data) {
                let resized = await resizeImage(image, to: targetSize)
                await MainActor.run {
                    self.highQualityImage = resized
                    self.phase = .highQuality
                    // Smooth transition
                    withAnimation(.easeOut(duration: 0.5)) {
                        self.showHighQuality = true
                    }
                }
            }
            #else
            if let image = NSImage(data: data) {
                let resized = await resizeImage(image, to: targetSize)
                await MainActor.run {
                    self.highQualityImage = resized
                    self.phase = .highQuality
                    // Smooth transition
                    withAnimation(.easeOut(duration: 0.5)) {
                        self.showHighQuality = true
                    }
                }
            }
            #endif
        } catch {
            print("Failed to load high quality image: \(error)")
        }
    }
    #if os(iOS)
    private func resizeImage(_ image: UIImage, to size: CGSize) async -> UIImage? {
        return await withCheckedContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                let renderer = UIGraphicsImageRenderer(size: size)
                let resized = renderer.image { context in
                    image.draw(in: CGRect(origin: .zero, size: size))
                }
                continuation.resume(returning: resized)
            }
        }
    }
    #else
    private func resizeImage(_ image: NSImage, to size: CGSize) async -> NSImage? {
        return await withCheckedContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                let resized = NSImage(size: size)
                resized.lockFocus()
                image.draw(in: NSRect(origin: .zero, size: size))
                resized.unlockFocus()
                continuation.resume(returning: resized)
            }
        }
    }
    #endif
}
// MARK: - Image Cache Manager
class ImageCacheManager {
    static let shared = ImageCacheManager()
    #if os(iOS)
    private let memoryCache = NSCache<NSString, UIImage>()
    #else
    private let memoryCache = NSCache<NSString, NSImage>()
    #endif
    private let diskCacheURL: URL
    private let maxMemoryCacheSize = 50 * 1024 * 1024 // 50MB
    private let maxDiskCacheSize = 100 * 1024 * 1024 // 100MB
    private init() {
        // Setup disk cache directory
        let cacheDir = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first!
        diskCacheURL = cacheDir.appendingPathComponent("OlasImageCache")
        // Create directory if needed
        try? FileManager.default.createDirectory(at: diskCacheURL, withIntermediateDirectories: true)
        // Configure memory cache
        memoryCache.totalCostLimit = maxMemoryCacheSize
        // Clean old cache on init
        cleanOldCache()
    }
    #if os(iOS)
    func getCachedImage(for url: String) -> UIImage? {
        let key = NSString(string: url)
        // Check memory cache first
        if let image = memoryCache.object(forKey: key) {
            return image
        }
        // Check disk cache
        let fileURL = diskCacheURL.appendingPathComponent(url.sha256Hash)
        if let data = try? Data(contentsOf: fileURL),
           let image = UIImage(data: data) {
            // Add to memory cache
            memoryCache.setObject(image, forKey: key, cost: data.count)
            return image
        }
        return nil
    }
    #else
    func getCachedImage(for url: String) -> NSImage? {
        let key = NSString(string: url)
        // Check memory cache first
        if let image = memoryCache.object(forKey: key) {
            return image
        }
        // Check disk cache
        let fileURL = diskCacheURL.appendingPathComponent(url.sha256Hash)
        if let data = try? Data(contentsOf: fileURL),
           let image = NSImage(data: data) {
            // Add to memory cache
            memoryCache.setObject(image, forKey: key, cost: data.count)
            return image
        }
        return nil
    }
    #endif
    #if os(iOS)
    func cacheImage(_ image: UIImage, for url: String) {
        let key = NSString(string: url)
        // Add to memory cache
        if let data = image.jpegData(compressionQuality: 0.8) {
            memoryCache.setObject(image, forKey: key, cost: data.count)
            // Save to disk
            let fileURL = diskCacheURL.appendingPathComponent(url.sha256Hash)
            try? data.write(to: fileURL)
        }
    }
    #else
    func cacheImage(_ image: NSImage, for url: String) {
        let key = NSString(string: url)
        // Add to memory cache
        if let tiffData = image.tiffRepresentation,
           let bitmap = NSBitmapImageRep(data: tiffData),
           let data = bitmap.representation(using: .jpeg, properties: [.compressionFactor: 0.8]) {
            memoryCache.setObject(image, forKey: key, cost: data.count)
            // Save to disk
            let fileURL = diskCacheURL.appendingPathComponent(url.sha256Hash)
            try? data.write(to: fileURL)
        }
    }
    #endif
    private func cleanOldCache() {
        // Remove files older than 7 days
        let fileManager = FileManager.default
        let expirationDate = Date().addingTimeInterval(-7 * 24 * 60 * 60)
        if let files = try? fileManager.contentsOfDirectory(at: diskCacheURL, includingPropertiesForKeys: [.creationDateKey]) {
            for file in files {
                if let attributes = try? file.resourceValues(forKeys: [.creationDateKey]),
                   let creationDate = attributes.creationDate,
                   creationDate < expirationDate {
                    try? fileManager.removeItem(at: file)
                }
            }
        }
    }
}
// End of BlurhashView.swift
</file>

<file path="Olas/Components/TimeBasedGradient.swift">
import SwiftUI
struct TimeBasedGradient: View {
    @State private var animateGradient = false
    private var gradientColors: [Color] {
        let hour = Calendar.current.component(.hour, from: Date())
        switch hour {
        case 5..<8: // Early morning
            return [Color(hex: "FF6B6B"), Color(hex: "4ECDC4")]
        case 8..<12: // Morning
            return [Color(hex: "667EEA"), Color(hex: "764BA2")]
        case 12..<17: // Afternoon
            return [Color(hex: "F093FB"), Color(hex: "F5576C")]
        case 17..<20: // Evening
            return [Color(hex: "FA709A"), Color(hex: "FEE140")]
        case 20..<24, 0..<5: // Night
            return [Color(hex: "30CFD0"), Color(hex: "330867")]
        default:
            return [Color(hex: "667EEA"), Color(hex: "764BA2")]
        }
    }
    var body: some View {
        LinearGradient(
            colors: gradientColors,
            startPoint: animateGradient ? .topLeading : .bottomLeading,
            endPoint: animateGradient ? .bottomTrailing : .topTrailing
        )
        .animation(.easeInOut(duration: 5).repeatForever(autoreverses: true), value: animateGradient)
        .onAppear {
            animateGradient = true
        }
    }
}
</file>

<file path="Olas/DataSources/NostrDataSources.swift">
import Foundation
import NDKSwift
import SwiftUI
import Combine
// MARK: - User Profile Data Source
/// Data source for user profile metadata
@MainActor
public class UserProfileDataSource: ObservableObject {
    @Published public private(set) var profile: NDKUserProfile?
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    private let dataSource: NDKDataSource<NDKEvent>
    public init(ndk: NDK, pubkey: String) {
        self.dataSource = ndk.observe(
            filter: NDKFilter(
                authors: [pubkey],
                kinds: [EventKind.metadata]
            ),
            maxAge: 0,  // Real-time updates
            cachePolicy: .cacheWithNetwork
        )
        Task {
            await observeProfile()
        }
    }
    private func observeProfile() async {
        dataSource.$data
            .compactMap { events in
                events.sorted { $0.createdAt > $1.createdAt }.first
            }
            .map { event in
                JSONCoding.safeDecode(NDKUserProfile.self, from: event.content.data(using: .utf8) ?? Data())
            }
            .assign(to: &$profile)
        dataSource.$isLoading.assign(to: &$isLoading)
        dataSource.$error.assign(to: &$error)
    }
}
// MARK: - Image Feed Data Source
/// Data source for image posts (kind 1 with image tags)
@MainActor
public class ImageFeedDataSource: ObservableObject {
    @Published public private(set) var posts: [NDKEvent] = []
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    private let dataSource: NDKDataSource<NDKEvent>
    public init(ndk: NDK, authors: [String]? = nil, limit: Int = 50) {
        var filter = NDKFilter(kinds: [EventKind.textNote])
        filter.authors = authors
        filter.limit = limit
        self.dataSource = ndk.observe(
            filter: filter,
            maxAge: 0,  // Real-time updates
            cachePolicy: .cacheWithNetwork
        )
        Task {
            await observePosts()
        }
    }
    private func observePosts() async {
        dataSource.$data
            .map { events in
                // Filter for events with image tags
                events.filter { event in
                    event.tags.contains { tag in
                        tag.count >= 2 && (tag[0] == "imeta" || 
                                         (tag[0] == "r" && tag[1].hasSuffix(".jpg")) ||
                                         (tag[0] == "r" && tag[1].hasSuffix(".jpeg")) ||
                                         (tag[0] == "r" && tag[1].hasSuffix(".png")) ||
                                         (tag[0] == "r" && tag[1].hasSuffix(".gif")) ||
                                         (tag[0] == "r" && tag[1].hasSuffix(".webp")))
                    }
                }.sorted { $0.createdAt > $1.createdAt }
            }
            .assign(to: &$posts)
        dataSource.$isLoading.assign(to: &$isLoading)
        dataSource.$error.assign(to: &$error)
    }
}
// MARK: - Hashtag Feed Data Source
/// Data source for posts with specific hashtags
@MainActor
public class HashtagFeedDataSource: ObservableObject {
    @Published public private(set) var posts: [NDKEvent] = []
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    private let dataSource: NDKDataSource<NDKEvent>
    private let hashtag: String
    public init(ndk: NDK, hashtag: String, limit: Int = 50) {
        self.hashtag = hashtag.lowercased().replacingOccurrences(of: "#", with: "")
        let filter = NDKFilter(
            kinds: [EventKind.textNote],
            limit: limit,
            tags: ["t": Set([self.hashtag])]
        )
        self.dataSource = ndk.observe(
            filter: filter,
            maxAge: 0,  // Real-time updates
            cachePolicy: .cacheWithNetwork
        )
        Task {
            await observePosts()
        }
    }
    private func observePosts() async {
        dataSource.$data
            .map { events in
                events.sorted { $0.createdAt > $1.createdAt }
            }
            .assign(to: &$posts)
        dataSource.$isLoading.assign(to: &$isLoading)
        dataSource.$error.assign(to: &$error)
    }
}
// MARK: - User Posts Data Source
/// Data source for a specific user's posts
@MainActor
public class UserPostsDataSource: ObservableObject {
    @Published public private(set) var posts: [NDKEvent] = []
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    private let dataSource: NDKDataSource<NDKEvent>
    public init(ndk: NDK, pubkey: String, includeReplies: Bool = false) {
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [EventKind.textNote]
        )
        if !includeReplies {
            // This would filter out replies if NDK supported it
            // For now, we'll filter client-side
        }
        self.dataSource = ndk.observe(
            filter: filter,
            maxAge: 0,  // Real-time updates
            cachePolicy: .cacheWithNetwork
        )
        Task {
            await observePosts(includeReplies: includeReplies)
        }
    }
    private func observePosts(includeReplies: Bool) async {
        dataSource.$data
            .map { events in
                var filtered = events
                if !includeReplies {
                    // Filter out replies (events with "e" or "p" tags that indicate replies)
                    filtered = events.filter { event in
                        !event.isReply
                    }
                }
                // Filter for events with images
                return filtered.filter { event in
                    event.tags.contains { tag in
                        tag.count >= 2 && (tag[0] == "imeta" || 
                                         (tag[0] == "r" && self.isImageURL(tag[1])))
                    }
                }.sorted { $0.createdAt > $1.createdAt }
            }
            .assign(to: &$posts)
        dataSource.$isLoading.assign(to: &$isLoading)
        dataSource.$error.assign(to: &$error)
    }
    private func isImageURL(_ url: String) -> Bool {
        let imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp"]
        return imageExtensions.contains { url.lowercased().hasSuffix($0) }
    }
}
// MARK: - Extensions
extension NDKEvent {
    var isReply: Bool {
        // Check for reply markers
        tags.contains { tag in
            (tag.count >= 2 && tag[0] == "e" && tag.count >= 4 && tag[3] == "reply") ||
            (tag.count >= 2 && tag[0] == "e" && !tags.contains { $0[0] == "e" && $0.count >= 4 && $0[3] == "root" })
        }
    }
}
</file>

<file path="Olas/Models/BlossomServerManager.swift">
import Foundation
import NDKSwift
import SwiftUI
@MainActor
class BlossomServerManager: ObservableObject {
    @Published var servers: [BlossomServerInfo] = []
    @Published var selectedServers: Set<String> = []
    @Published var isLoading = false
    private var ndk: NDK?
    // Default Blossom servers for Olas
    private let defaultServers = [
        "https://files.hzrd149.com",
        "https://cdn.satellite.earth",
        "https://nostr.build"
    ]
    // Key for storing user preferences
    private static let selectedServersKey = "OlasSelectedBlossomServers"
    init(ndk: NDK?) {
        self.ndk = ndk
        loadSelectedServers()
        Task {
            await loadServerInfo()
        }
    }
    private func loadSelectedServers() {
        if let saved = UserDefaults.standard.stringArray(forKey: Self.selectedServersKey) {
            selectedServers = Set(saved)
        } else {
            // Default to first server if none selected
            selectedServers = [defaultServers.first!]
        }
    }
    private func saveSelectedServers() {
        UserDefaults.standard.set(Array(selectedServers), forKey: Self.selectedServersKey)
    }
    func toggleServer(_ serverURL: String) {
        if selectedServers.contains(serverURL) {
            selectedServers.remove(serverURL)
        } else {
            selectedServers.insert(serverURL)
        }
        saveSelectedServers()
    }
    private func loadServerInfo() async {
        isLoading = true
        defer { isLoading = false }
        var serverInfos: [BlossomServerInfo] = []
        for serverURL in defaultServers {
            let info = BlossomServerInfo(
                url: serverURL,
                name: serverName(for: serverURL),
                isAvailable: true, // We'll implement health checks later
                maxUploadSize: nil
            )
            serverInfos.append(info)
        }
        servers = serverInfos
    }
    private func serverName(for url: String) -> String {
        if url.contains("hzrd149") {
            return "hzrd149's Files"
        } else if url.contains("satellite") {
            return "Satellite CDN"
        } else if url.contains("nostr.build") {
            return "nostr.build"
        } else {
            return URL(string: url)?.host ?? url
        }
    }
    func uploadToSelectedServers(data: Data, mimeType: String) async throws -> [BlossomUploadResult] {
        guard let ndk = ndk, ndk.signer != nil else {
            throw BlossomError.notAuthenticated
        }
        let selectedServerURLs = Array(selectedServers)
        guard !selectedServerURLs.isEmpty else {
            throw BlossomError.noServersSelected
        }
        var results: [BlossomUploadResult] = []
        for serverURL in selectedServerURLs {
            do {
                let blobs = try await ndk.uploadToBlossom(
                    data: data,
                    mimeType: mimeType,
                    servers: [serverURL]
                )
                if let firstBlob = blobs.first {
                    results.append(BlossomUploadResult(
                        serverURL: serverURL,
                        fileURL: firstBlob.url,
                        success: true,
                        error: nil
                    ))
                } else {
                    throw BlossomError.uploadFailed("No blob returned from server")
                }
            } catch {
                results.append(BlossomUploadResult(
                    serverURL: serverURL,
                    fileURL: nil,
                    success: false,
                    error: error
                ))
            }
        }
        // If at least one upload succeeded, return results
        if results.contains(where: { $0.success }) {
            return results
        } else {
            // All uploads failed
            throw BlossomError.allUploadsFailed(results)
        }
    }
}
// MARK: - Supporting Types
struct BlossomServerInfo: Identifiable {
    let id = UUID()
    let url: String
    let name: String
    let isAvailable: Bool
    let maxUploadSize: Int64?
}
struct BlossomUploadResult {
    let serverURL: String
    let fileURL: String?
    let success: Bool
    let error: Error?
}
enum BlossomError: LocalizedError {
    case notAuthenticated
    case noServersSelected
    case allUploadsFailed([BlossomUploadResult])
    case uploadFailed(String)
    var errorDescription: String? {
        switch self {
        case .notAuthenticated:
            return "You must be logged in to upload files"
        case .noServersSelected:
            return "Please select at least one server"
        case .allUploadsFailed(let results):
            let errors = results.compactMap { $0.error?.localizedDescription }.joined(separator: ", ")
            return "All uploads failed: \(errors)"
        case .uploadFailed(let message):
            return message
        }
    }
}
</file>

<file path="Olas/Models/Color+Extensions.swift">
import SwiftUI
extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3:
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6:
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8:
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue:  Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}
</file>

<file path="Olas/Models/DesignSystem.swift">
import SwiftUI
import Foundation
// MARK: - Design System
enum OlasDesign {
    // MARK: - Time-Based Gradient System
    static var currentGradient: LinearGradient {
        let hour = Calendar.current.component(.hour, from: Date())
        switch hour {
        case 5...7: // Dawn
            return LinearGradient(
                colors: [Color(hex: "FF6B6B"), Color(hex: "4ECDC4")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        case 8...16: // Day
            return LinearGradient(
                colors: [Color(hex: "667eea"), Color(hex: "764ba2")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        case 17...19: // Dusk
            return LinearGradient(
                colors: [Color(hex: "f093fb"), Color(hex: "f5576c")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        default: // Night
            return LinearGradient(
                colors: [Color(hex: "4facfe"), Color(hex: "00f2fe")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        }
    }
    static var accentGradient: LinearGradient {
        currentGradient
    }
    // MARK: - Colors
    enum Colors {
        static let background = Color.black
        static let surface = Color.white.opacity(0.08) // Glass morphism
        static let text = Color.white
        static let textSecondary = Color.white.opacity(0.7)
        static let textTertiary = Color.white.opacity(0.5)
        static let divider = Color.white.opacity(0.1)
        static let border = Color.white.opacity(0.15)
        static let error = Color(hex: "FF6B6B")
        static let success = Color(hex: "4ECDC4")
        static let warning = Color(hex: "FFA726")
        static let primary = Color(hex: "667eea") // Default to day color
        static let secondary = Color(hex: "764ba2")
        static let like = Color(hex: "FF4458") // Heart red
        static let gradient = [Color(hex: "667eea"), Color(hex: "764ba2")] // Default gradient
        static let primaryGradient = [Color(hex: "667eea"), Color(hex: "764ba2")] // For compatibility
    }
    // MARK: - Typography
    enum Typography {
        static let largeTitle = Font.system(.largeTitle, design: .rounded, weight: .bold)
        static let title = Font.system(.title, design: .rounded, weight: .semibold)
        static let title2 = Font.system(.title2, design: .rounded, weight: .semibold)
        static let title3 = Font.system(.title3, design: .rounded, weight: .medium)
        static let headline = Font.system(.headline, design: .default, weight: .semibold)
        static let body = Font.custom("Inter", size: 16).weight(.regular)
        static let bodyMedium = Font.custom("Inter", size: 16).weight(.medium)
        static let bodyBold = Font.custom("Inter", size: 16).weight(.bold)
        static let caption = Font.custom("Inter", size: 14).weight(.regular)
        static let footnote = Font.custom("Inter", size: 13).weight(.regular)
        static let mono = Font.custom("JetBrains Mono", size: 14).weight(.regular)
    }
    // MARK: - Spacing (8pt Grid System)
    enum Spacing {
        static let xxs: CGFloat = 2   // 0.25x
        static let xs: CGFloat = 4    // 0.5x
        static let sm: CGFloat = 8    // 1x (base)
        static let md: CGFloat = 16   // 2x
        static let lg: CGFloat = 24   // 3x
        static let xl: CGFloat = 32   // 4x
        static let xxl: CGFloat = 48  // 6x
        static let xxxl: CGFloat = 64 // 8x
    }
    // MARK: - Animations
    enum Animation {
        static let springResponse: Double = 0.55
        static let springDamping: Double = 0.825
        static let spring = SwiftUI.Animation.spring(response: springResponse, dampingFraction: springDamping)
        static let microDuration: Double = 0.2
        static let macroDuration: Double = 0.35
        static let easeOutBack = SwiftUI.Animation.timingCurve(0.34, 1.56, 0.64, 1, duration: macroDuration)
    }
    // MARK: - Corner Radius
    enum CornerRadius {
        static let xs: CGFloat = 4
        static let sm: CGFloat = 8
        static let md: CGFloat = 12
        static let lg: CGFloat = 16
        static let xl: CGFloat = 20
        static let xxl: CGFloat = 24
        static let full: CGFloat = 9999
    }
    // MARK: - Shadows
    enum Shadow {
        static func small(color: Color = .black) -> SwiftShadow {
            SwiftShadow(color: color.opacity(0.15), radius: 4, x: 0, y: 2)
        }
        static func medium(color: Color = .black) -> SwiftShadow {
            SwiftShadow(color: color.opacity(0.2), radius: 8, x: 0, y: 4)
        }
        static func large(color: Color = .black) -> SwiftShadow {
            SwiftShadow(color: color.opacity(0.25), radius: 16, x: 0, y: 8)
        }
        static func glow(color: Color) -> SwiftShadow {
            SwiftShadow(color: color.opacity(0.6), radius: 20, x: 0, y: 0)
        }
    }
    // MARK: - Haptic Feedback
    enum Haptic {
        #if os(iOS)
        static func impact(_ style: UIImpactFeedbackGenerator.FeedbackStyle) {
            let impactFeedback = UIImpactFeedbackGenerator(style: style)
            impactFeedback.prepare()
            impactFeedback.impactOccurred()
        }
        #else
        static func impact(_ style: Int) {
            // No haptic feedback on macOS
        }
        #endif
        static func selection() {
            #if os(iOS)
            let selectionFeedback = UISelectionFeedbackGenerator()
            selectionFeedback.prepare()
            selectionFeedback.selectionChanged()
            #endif
        }
        #if os(iOS)
        static func notification(_ type: UINotificationFeedbackGenerator.FeedbackType) {
            let notificationFeedback = UINotificationFeedbackGenerator()
            notificationFeedback.prepare()
            notificationFeedback.notificationOccurred(type)
        }
        #else
        static func notification(_ type: Int) {
            // No haptic feedback on macOS
        }
        #endif
        static func success() {
            #if os(iOS)
            notification(.success)
            #endif
        }
        static func error() {
            #if os(iOS)
            notification(.error)
            #endif
        }
    }
}
// MARK: - Shadow Helper
struct SwiftShadow {
    let color: Color
    let radius: CGFloat
    let x: CGFloat
    let y: CGFloat
}
// MARK: - View Extensions
extension View {
    func olasGradient() -> some View {
        self.foregroundStyle(OlasDesign.currentGradient)
    }
    func olasSurface() -> some View {
        self
            .background(OlasDesign.Colors.surface)
            .background(.ultraThinMaterial)
            .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg))
    }
    func olasGlassMorphism() -> some View {
        self
            .background(
                ZStack {
                    OlasDesign.Colors.surface
                    Color.white.opacity(0.05)
                }
            )
            .background(.ultraThinMaterial)
            .overlay(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                    .stroke(OlasDesign.Colors.divider, lineWidth: 1)
            )
            .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg))
    }
    func olasShadow(_ shadow: SwiftShadow) -> some View {
        self.shadow(color: shadow.color, radius: shadow.radius, x: shadow.x, y: shadow.y)
    }
    func olasTextShadow() -> some View {
        self.shadow(color: .black.opacity(0.3), radius: 1, x: 0, y: 1)
    }
    func olasSpringAnimation() -> some View {
        self.animation(OlasDesign.Animation.spring, value: UUID())
    }
}
// MARK: - Custom Components
// Note: OlasButton is defined in Views/Components/OlasButton.swift
struct OlasTextField: View {
    @Binding var text: String
    let placeholder: String
    var isSecure: Bool = false
    var icon: String? = nil
    @FocusState private var isFocused: Bool
    var body: some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            if let icon = icon {
                Image(systemName: icon)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
                    .font(.system(size: 18))
            }
            Group {
                if isSecure {
                    SecureField(placeholder, text: $text)
                } else {
                    TextField(placeholder, text: $text)
                }
            }
            .font(OlasDesign.Typography.body)
            .foregroundColor(OlasDesign.Colors.text)
            .focused($isFocused)
        }
        .padding(OlasDesign.Spacing.md)
        .background(OlasDesign.Colors.surface)
        .background(.ultraThinMaterial)
        .overlay(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .stroke(
                    isFocused ? OlasDesign.Colors.text.opacity(0.5) : OlasDesign.Colors.divider,
                    lineWidth: isFocused ? 2 : 1
                )
        )
        .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md))
        .animation(OlasDesign.Animation.spring, value: isFocused)
        .onChange(of: isFocused) { _, focused in
            if focused {
                OlasDesign.Haptic.selection()
            }
        }
    }
}
// MARK: - Loading States
struct OlasShimmer: View {
    @State private var isAnimating = false
    var body: some View {
        LinearGradient(
            colors: [
                OlasDesign.Colors.surface,
                OlasDesign.Colors.surface.opacity(0.6),
                OlasDesign.Colors.surface
            ],
            startPoint: .leading,
            endPoint: .trailing
        )
        .offset(x: isAnimating ? 200 : -200)
        .animation(
            .linear(duration: 1.5)
            .repeatForever(autoreverses: false),
            value: isAnimating
        )
        .onAppear {
            isAnimating = true
        }
    }
}
struct OlasSkeletonView: View {
    let height: CGFloat
    var body: some View {
        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
            .fill(OlasDesign.Colors.surface)
            .overlay(OlasShimmer())
            .frame(height: height)
            .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm))
    }
}
struct OlasLoadingView: View {
    var body: some View {
        Rectangle()
            .fill(OlasDesign.Colors.surface)
            .overlay(OlasShimmer())
    }
}
// MARK: - Relative Time Formatter
// RelativeTimeFormatter is defined in StoriesManager.swift
</file>

<file path="Olas/Models/ImetaUtils.swift">
import Foundation
import NDKSwift
// MARK: - Image Metadata Utilities
struct SimpleImageMetadata {
    var url: String
    var mimeType: String?
    var blurhash: String?
    var width: Int?
    var height: Int?
    var sha256: String?
    var size: Int?
}
enum ImetaUtils {
    // Extract image metadata from NIP-92 imeta tags
    static func extractImageMetadata(from tags: [[String]]) -> [SimpleImageMetadata] {
        var imageMetadataList: [SimpleImageMetadata] = []
        for tag in tags {
            guard tag.count >= 2, tag[0] == "imeta" else { continue }
            var metadata = SimpleImageMetadata(url: "")
            // Parse imeta tag format: ["imeta", "url <url>", "m <mime>", "blurhash <hash>", ...]
            for i in 1..<tag.count {
                let parts = tag[i].split(separator: " ", maxSplits: 1)
                guard parts.count == 2 else { continue }
                let key = String(parts[0])
                let value = String(parts[1])
                switch key {
                case "url":
                    metadata.url = value
                case "m":
                    metadata.mimeType = value
                case "blurhash":
                    metadata.blurhash = value
                case "dim":
                    let dimensions = value.split(separator: "x")
                    if dimensions.count == 2,
                       let width = Int(dimensions[0]),
                       let height = Int(dimensions[1]) {
                        metadata.width = width
                        metadata.height = height
                    }
                case "x":
                    metadata.sha256 = value
                case "size":
                    if let size = Int(value) {
                        metadata.size = size
                    }
                default:
                    break
                }
            }
            // Only add if we have a valid URL
            if !metadata.url.isEmpty {
                imageMetadataList.append(metadata)
            }
        }
        return imageMetadataList
    }
    // Extract first image URL from tags (for quick access)
    static func extractFirstImageURL(from tags: [[String]]) -> String? {
        let metadata = extractImageMetadata(from: tags)
        return metadata.first?.url
    }
    // Extract all image URLs from tags
    static func extractImageURLs(from tags: [[String]]) -> [String] {
        let metadata = extractImageMetadata(from: tags)
        return metadata.map { $0.url }
    }
    // Build imeta tag for NIP-92
    static func buildImetaTag(for metadata: SimpleImageMetadata) -> [String] {
        var tag = ["imeta"]
        tag.append("url \(metadata.url)")
        if let mimeType = metadata.mimeType {
            tag.append("m \(mimeType)")
        }
        if let blurhash = metadata.blurhash {
            tag.append("blurhash \(blurhash)")
        }
        if let width = metadata.width, let height = metadata.height {
            tag.append("dim \(width)x\(height)")
        }
        if let sha256 = metadata.sha256 {
            tag.append("x \(sha256)")
        }
        if let size = metadata.size {
            tag.append("size \(size)")
        }
        return tag
    }
}
</file>

<file path="Olas/Models/NostrManager.swift">
import Foundation
import NDKSwift
import SwiftUI
import Observation
@MainActor
@Observable
class NostrManager {
    var ndk: NDK?
    var isConnected = false
    var relayStatus: [String: Bool] = [:]
    private var ndkAuthManager: NDKAuthManager
    var cache: NDKSQLiteCache?
    // Declarative data sources
    private(set) var userProfileDataSource: UserProfileDataSource?
    // Current user's profile
    private(set) var currentUserProfile: NDKUserProfile?
    private var profileObservationTask: Task<Void, Never>?
    // Default relays for Olas (visual content focused)
    let defaultRelays = [
        RelayConstants.primal,
        RelayConstants.damus,
        RelayConstants.nosLol,
        RelayConstants.nostrWine,
        "wss://relay.nostr.band"
    ]
    // Key for storing user-added relays
    private static let userRelaysKey = "OlasUserAddedRelays"
    init() {
        print(" [OlasManager] Initializing...")
        self.ndkAuthManager = NDKAuthManager.shared
        Task {
            await setupNDK()
        }
    }
    private func setupNDK() async {
        print(" [OlasManager] Setting up NDK...")
        // Initialize SQLite cache for better performance and offline access
        do {
            cache = try await NDKSQLiteCache()
            let allRelays = getAllRelays()
            ndk = NDK(relayUrls: allRelays, cache: cache)
            print("NDK initialized with SQLite cache and \(allRelays.count) relays")
        } catch {
            print("Failed to initialize SQLite cache: \(error). Continuing without cache.")
            let allRelays = getAllRelays()
            ndk = NDK(relayUrls: allRelays)
        }
        // Set NDK on auth manager
        if let ndk = ndk {
            print(" [OlasManager] Setting NDK on auth manager")
            ndkAuthManager.setNDK(ndk)
            // Restore session from keychain (handles automatic session switching)
            ndkAuthManager.restoreSession()
            // Configure NIP-89 client tags for Olas
            ndk.clientTagConfig = NDKClientTagConfig(
                name: "Olas",
                relay: RelayConstants.primal,
                autoTag: true,
                excludedKinds: [
                    EventKind.encryptedDirectMessage
                ]
            )
            print(" [OlasManager] Configured NIP-89 client tags")
            // If authenticated after restore, initialize data sources
            if ndkAuthManager.isAuthenticated {
                if let signer = ndkAuthManager.activeSigner {
                    Task {
                        let pubkey = try await signer.pubkey
                        await initializeDataSources(for: pubkey)
                    }
                }
            }
        }
        Task {
            await connectToRelays()
        }
    }
    func connectToRelays() async {
        guard let ndk = ndk else { return }
        print("OlasManager - Connecting to relays")
        await ndk.connect()
        isConnected = true
        print("OlasManager - Connected to relays")
        // Monitor relay status
        await monitorRelayStatus()
    }
    private func monitorRelayStatus() async {
        guard let ndk = ndk else { return }
        // Monitor relay changes
        let relayChanges = await ndk.relayChanges
        for await change in relayChanges {
            switch change {
            case .relayConnected(let relay):
                relayStatus[relay.url] = true
            case .relayDisconnected(let relay):
                relayStatus[relay.url] = false
            case .relayAdded(let relay):
                relayStatus[relay.url] = false
            case .relayRemoved(let relay):
                relayStatus.removeValue(forKey: relay)
            }
        }
    }
    func login(with privateKey: String) async throws {
        guard let ndk = ndk else { throw OlasError.ndkNotInitialized }
        // Create signer - NDKPrivateKeySigner handles both nsec and hex formats
        let signer: NDKPrivateKeySigner
        if privateKey.hasPrefix("nsec1") {
            signer = try NDKPrivateKeySigner(nsec: privateKey)
        } else {
            signer = try NDKPrivateKeySigner(privateKey: privateKey)
        }
        // Start session with follow list and mute list support
        try await ndk.startSession(
            signer: signer,
            config: NDKSessionConfiguration(
                dataRequirements: [.followList, .muteList],
                preloadStrategy: .progressive
            )
        )
        // Create auth session for persistence
        let session = try await ndkAuthManager.createSession(
            with: signer,
            requiresBiometric: false,
            isHardwareBacked: false
        )
        // Switch to the new session
        try await ndkAuthManager.switchToSession(session)
        let publicKey = try await signer.pubkey
        print("Logged in with public key: \(publicKey)")
        // Initialize declarative data sources
        await initializeDataSources(for: publicKey)
    }
    func createNewAccount(displayName: String, about: String? = nil, picture: String? = nil) async throws -> NDKSession {
        print(" [OlasManager] createNewAccount() called with displayName: \(displayName)")
        guard let ndk = ndk else { 
            print(" [OlasManager] ERROR: NDK is not initialized!")
            throw OlasError.ndkNotInitialized 
        }
        // Generate new private key
        let signer = try NDKPrivateKeySigner.generate()
        // Start session
        print(" [OlasManager] Starting session...")
        try await ndk.startSession(
            signer: signer,
            config: NDKSessionConfiguration(
                dataRequirements: [.followList, .muteList],
                preloadStrategy: .progressive
            )
        )
        // Create auth session for persistence
        let session = try await ndkAuthManager.createSession(
            with: signer,
            requiresBiometric: false,
            isHardwareBacked: false
        )
        // Create and publish profile
        let metadata = NDKUserProfile(
            name: displayName.lowercased().replacingOccurrences(of: " ", with: "_"),
            displayName: displayName,
            about: about ?? "Visual storyteller on Nostr ",
            picture: picture
        )
        if ndkAuthManager.isAuthenticated {
            print(" [OlasManager] User is authenticated, publishing metadata...")
            // Create metadata event
            let metadataContent = try JSONCoding.encodeToString(metadata)
            let metadataEvent = try await NDKEventBuilder(ndk: ndk)
                .content(metadataContent)
                .kind(EventKind.metadata)
                .build(signer: signer)
            _ = try await ndk.publish(metadataEvent)
            // Update session with profile
            try await ndkAuthManager.updateActiveSessionProfile(metadata)
        }
        // Initialize declarative data sources
        await initializeDataSources(for: session.pubkey)
        print(" [OlasManager] createNewAccount() completed successfully")
        return session
    }
    func createAccountFromNsec(_ nsec: String, displayName: String) async throws -> NDKSession {
        print(" [OlasManager] createAccountFromNsec() called")
        guard let ndk = ndk else { throw OlasError.ndkNotInitialized }
        let signer = try NDKPrivateKeySigner(nsec: nsec)
        // Start session
        try await ndk.startSession(
            signer: signer,
            config: NDKSessionConfiguration(
                dataRequirements: [.followList, .muteList],
                preloadStrategy: .progressive
            )
        )
        // Create auth session for persistence
        let session = try await ndkAuthManager.createSession(
            with: signer,
            requiresBiometric: false,
            isHardwareBacked: false
        )
        // Initialize declarative data sources
        await initializeDataSources(for: session.pubkey)
        print(" [OlasManager] createAccountFromNsec() completed successfully")
        return session
    }
    func logout() {
        // Cancel profile observation
        profileObservationTask?.cancel()
        profileObservationTask = nil
        currentUserProfile = nil
        // Clean up data sources
        userProfileDataSource = nil
        // Clear all cached data and sessions
        Task {
            if let cache = cache {
                try? await cache.clear()
                print("Cleared all cached data")
            }
            // Clear all sessions from keychain
            for session in ndkAuthManager.availableSessions {
                try? await ndkAuthManager.deleteSession(session)
            }
        }
        // Clear active authentication state
        ndkAuthManager.logout()
        // Clear NDK signer
        ndk?.signer = nil
        print("Logged out and cleared all authentication data")
    }
    // MARK: - Auth State Management
    /// Check if user is authenticated via NDKAuth
    var isAuthenticated: Bool {
        ndkAuthManager.isAuthenticated
    }
    /// Get auth manager for use in UI
    var authManager: NDKAuthManager {
        return ndkAuthManager
    }
    /// Get current user from auth manager
    var currentUser: NDKUser? {
        get async {
            guard ndkAuthManager.isAuthenticated else { return nil }
            return try? await ndkAuthManager.activeSigner?.user()
        }
    }
    // MARK: - Declarative Data Sources
    private func initializeDataSources(for pubkey: String) async {
        guard let ndk = ndk else { return }
        print("OlasManager - Initializing declarative data sources for user: \(pubkey.prefix(8))...")
        // Cancel any existing profile observation
        profileObservationTask?.cancel()
        // Start observing user profile using NDKProfileManager
        profileObservationTask = Task { @MainActor in
            // Use maxAge of 3600 (1 hour) for the profile
            for await profile in await ndk.profileManager.observe(for: pubkey, maxAge: 3600) {
                self.currentUserProfile = profile
            }
        }
        // Initialize user profile data source (kept for compatibility)
        userProfileDataSource = UserProfileDataSource(ndk: ndk, pubkey: pubkey)
    }
    // MARK: - Relay Management
    /// Get all relays (default + user-added)
    private func getAllRelays() -> [String] {
        let userRelays = getUserAddedRelays()
        let allRelays = defaultRelays + userRelays
        return Array(Set(allRelays)) // Remove duplicates
    }
    /// Get user-added relays from UserDefaults
    private func getUserAddedRelays() -> [String] {
        return UserDefaults.standard.stringArray(forKey: Self.userRelaysKey) ?? []
    }
    /// Add a user relay and persist it
    func addUserRelay(_ relayURL: String) async {
        var userRelays = getUserAddedRelays()
        guard !userRelays.contains(relayURL) && !defaultRelays.contains(relayURL) else {
            print("OlasManager - Relay \(relayURL) already exists")
            return
        }
        userRelays.append(relayURL)
        UserDefaults.standard.set(userRelays, forKey: Self.userRelaysKey)
        // Add relay to NDK
        if let ndk = ndk {
            await ndk.addRelay(relayURL)
        }
        print("OlasManager - Added user relay: \(relayURL)")
    }
    /// Remove a user relay and persist the change
    func removeUserRelay(_ relayURL: String) async {
        var userRelays = getUserAddedRelays()
        userRelays.removeAll { $0 == relayURL }
        UserDefaults.standard.set(userRelays, forKey: Self.userRelaysKey)
        // Remove relay from NDK (only if not a default relay)
        if !defaultRelays.contains(relayURL), let ndk = ndk {
            await ndk.removeRelay(relayURL)
        }
        print("OlasManager - Removed user relay: \(relayURL)")
    }
    /// Get list of user-added relays (for UI display)
    var userAddedRelays: [String] {
        return getUserAddedRelays()
    }
}
// MARK: - Error Types
enum OlasError: LocalizedError {
    case ndkNotInitialized
    case invalidKey
    case invalidPrivateKey
    case profileCreationFailed
    var errorDescription: String? {
        switch self {
        case .ndkNotInitialized:
            return "Network connection not ready. Please try again."
        case .invalidKey, .invalidPrivateKey:
            return "Invalid private key format."
        case .profileCreationFailed:
            return "Failed to create profile. Please try again."
        }
    }
}
</file>

<file path="Olas/Models/StoriesManager.swift">
import Foundation
import NDKSwift
import SwiftUI
@MainActor
class StoriesManager: ObservableObject {
    @Published var userStories: [UserStoryCollection] = []
    @Published var currentUserStories: [Story] = []
    @Published var isLoading = false
    @Published var hasActiveStory = false
    private let nostrManager: NostrManager
    private var storiesTask: Task<Void, Never>?
    private var profileTasks: [String: Task<Void, Never>] = [:]
    // Use a custom kind for stories (30078 - ephemeral content)
    private let storyKind: Int = 30078
    private let storyDuration: TimeInterval = 24 * 60 * 60 // 24 hours
    init(nostrManager: NostrManager) {
        self.nostrManager = nostrManager
    }
    deinit {
        storiesTask?.cancel()
        profileTasks.values.forEach { $0.cancel() }
    }
    func startObservingStories() {
        storiesTask?.cancel()
        guard let ndk = nostrManager.ndk else { return }
        storiesTask = Task {
            isLoading = true
            // Get stories from the last 24 hours
            let since = Timestamp(Int64(Date().addingTimeInterval(-storyDuration).timeIntervalSince1970))
            let filter = NDKFilter(
                kinds: [storyKind],
                since: since
            )
            let dataSource = ndk.observe(
                filter: filter,
                maxAge: 0,
                cachePolicy: .cacheWithNetwork
            )
            // Group stories by author
            var storiesByAuthor: [String: [Story]] = [:]
            for await event in dataSource.events {
                // Check if story is not expired
                if let expirationTag = event.tags.first(where: { $0.count >= 2 && $0[0] == "expiration" }),
                   let expirationTimestamp = Int64(expirationTag[1]),
                   expirationTimestamp < Int64(Date().timeIntervalSince1970) {
                    continue // Skip expired stories
                }
                let story = Story(from: event)
                if storiesByAuthor[event.pubkey] != nil {
                    storiesByAuthor[event.pubkey]?.append(story)
                } else {
                    storiesByAuthor[event.pubkey] = [story]
                }
                // Update UI
                await updateUserStories(from: storiesByAuthor)
                // Load profile for this author
                loadProfileForAuthor(event.pubkey)
                // Check if current user has active story
                if let signer = ndk.signer,
                   let signerPubkey = try? await signer.pubkey,
                   event.pubkey == signerPubkey {
                    hasActiveStory = true
                }
            }
            isLoading = false
        }
    }
    private func updateUserStories(from storiesByAuthor: [String: [Story]]) async {
        var collections: [UserStoryCollection] = []
        // Current user's stories first
        if let ndk = nostrManager.ndk,
           let signer = ndk.signer,
           let currentUserPubkey = try? await signer.pubkey,
           let currentStories = storiesByAuthor[currentUserPubkey] {
            let sortedStories = currentStories.sorted { $0.timestamp > $1.timestamp }
            collections.append(UserStoryCollection(
                authorPubkey: currentUserPubkey,
                stories: sortedStories,
                isCurrentUser: true
            ))
        }
        // Other users' stories
        for (pubkey, stories) in storiesByAuthor {
            if let ndk = nostrManager.ndk,
               let signer = ndk.signer,
               let signerPubkey = try? await signer.pubkey,
               pubkey != signerPubkey {
                let sortedStories = stories.sorted { $0.timestamp > $1.timestamp }
                collections.append(UserStoryCollection(
                    authorPubkey: pubkey,
                    stories: sortedStories,
                    isCurrentUser: false
                ))
            }
        }
        // Sort by most recent story
        collections.sort { collection1, collection2 in
            let time1 = collection1.stories.first?.timestamp ?? Date.distantPast
            let time2 = collection2.stories.first?.timestamp ?? Date.distantPast
            return time1 > time2
        }
        self.userStories = collections
    }
    private func loadProfileForAuthor(_ pubkey: String) {
        guard let profileManager = nostrManager.ndk?.profileManager else { return }
        profileTasks[pubkey]?.cancel()
        profileTasks[pubkey] = Task {
            for await profile in await profileManager.observe(for: pubkey, maxAge: 3600) {
                if let profile = profile {
                    // Update all stories for this author
                    for index in userStories.indices {
                        if userStories[index].authorPubkey == pubkey {
                            userStories[index].authorProfile = profile
                        }
                    }
                }
                break
            }
        }
    }
    func createStory(with imageData: Data, caption: String, filters: [String] = []) async throws {
        guard let ndk = nostrManager.ndk,
              let signer = ndk.signer else {
            throw StoryError.notAuthenticated
        }
        // Upload image to Blossom
        // For now, create a placeholder URL - in production this would upload to Blossom servers
        // TODO: Integrate with Blossom using BlossomClient like in CreatePostView
        let imageURL = "https://example.com/temp-story-\(UUID().uuidString).jpg"
        // Create story event
        let storyId = "story-\(UUID().uuidString)"
        let expiration = Int64(Date().addingTimeInterval(storyDuration).timeIntervalSince1970)
        var tags: [[String]] = [
            ["d", storyId],
            ["title", "Story"],
            ["image", imageURL],
            ["published_at", "\(Int64(Date().timeIntervalSince1970))"],
            ["expiration", "\(expiration)"]
        ]
        // Add filter tags if any
        for filter in filters {
            tags.append(["filter", filter])
        }
        // Add imeta tag for the image
        if let dimensions = getImageDimensions(from: imageData) {
            tags.append([
                "imeta",
                "url \(imageURL)",
                "dim \(dimensions.width)x\(dimensions.height)",
                "m image/jpeg"
            ])
        }
        let storyEvent = try await NDKEventBuilder(ndk: ndk)
            .kind(storyKind)
            .content(caption)
            .tags(tags)
            .build(signer: signer)
        _ = try await ndk.publish(storyEvent)
        // Update local state
        hasActiveStory = true
        // Trigger haptic feedback
        OlasDesign.Haptic.success()
    }
    func deleteStory(_ storyId: String) async throws {
        guard let ndk = nostrManager.ndk,
              let signer = ndk.signer else {
            throw StoryError.notAuthenticated
        }
        // Create deletion event
        let deletionEvent = try await NDKEventBuilder(ndk: ndk)
            .kind(EventKind.deletion)
            .content("Story deleted")
            .tags([
                ["e", storyId],
                ["k", "\(storyKind)"]
            ])
            .build(signer: signer)
        _ = try await ndk.publish(deletionEvent)
        // Update local state
        if let currentUserPubkey = try? await signer.pubkey {
            userStories.removeAll { collection in
                collection.authorPubkey == currentUserPubkey &&
                collection.stories.contains { $0.id == storyId }
            }
            // Check if user still has active stories
            hasActiveStory = userStories.contains { $0.authorPubkey == currentUserPubkey }
        }
    }
    func markStoryAsViewed(_ storyId: String) {
        // Store viewed state locally
        UserDefaults.standard.set(true, forKey: "story_viewed_\(storyId)")
    }
    func isStoryViewed(_ storyId: String) -> Bool {
        UserDefaults.standard.bool(forKey: "story_viewed_\(storyId)")
    }
    private func getImageDimensions(from imageData: Data) -> (width: Int, height: Int)? {
        #if os(iOS)
        if let image = UIImage(data: imageData) {
            return (width: Int(image.size.width), height: Int(image.size.height))
        }
        #elseif os(macOS)
        if let image = NSImage(data: imageData) {
            return (width: Int(image.size.width), height: Int(image.size.height))
        }
        #endif
        return nil
    }
}
// MARK: - Models
struct UserStoryCollection: Identifiable {
    let id = UUID()
    let authorPubkey: String
    var authorProfile: NDKUserProfile?
    var stories: [Story]
    let isCurrentUser: Bool
    var hasUnviewedStories: Bool {
        stories.contains { story in
            !UserDefaults.standard.bool(forKey: "story_viewed_\(story.id)")
        }
    }
}
struct EnhancedStory: Identifiable {
    let id: String
    let authorPubkey: String
    var authorProfile: NDKUserProfile?
    let content: String
    let mediaURLs: [String]
    let filters: [String]
    let timestamp: Date
    let expirationDate: Date
    let event: NDKEvent
    var isExpired: Bool {
        Date() > expirationDate
    }
    var timeRemaining: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute]
        formatter.unitsStyle = .abbreviated
        return formatter.string(from: Date(), to: expirationDate) ?? "Expired"
    }
}
// MARK: - Errors
enum StoryError: LocalizedError {
    case notAuthenticated
    case uploadFailed
    case eventCreationFailed
    case deletionFailed
    var errorDescription: String? {
        switch self {
        case .notAuthenticated:
            return "You must be logged in to create stories"
        case .uploadFailed:
            return "Failed to upload image"
        case .eventCreationFailed:
            return "Failed to create story"
        case .deletionFailed:
            return "Failed to delete story"
        }
    }
}
// MARK: - Utilities
struct RelativeTimeFormatter {
    static func format(_ date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}
</file>

<file path="Olas/Models/WalletManager.swift">
import Foundation
import NDKSwift
import SwiftUI
@MainActor
class OlasWalletManager: ObservableObject {
    @Published var activeWallet: NIP60Wallet?
    @Published var isLoading = false
    @Published var error: Error?
    @Published var currentBalance: Int64 = 0
    @Published var mintURLs: [String] = []
    @Published var mintBalances: [String: Int64] = [:]
    @Published var pendingAmount: Int64 = 0
    @Published var activeTokens: [WalletToken] = []
    @Published var pendingInvoices: [String: (amount: Int64, description: String, expiry: Date)] = [:]
    var isWalletConfigured: Bool {
        return activeWallet != nil && !mintURLs.isEmpty
    }
    // Enhanced transaction with more details
    @Published var recentTransactions: [WalletTransaction] = []
    enum TransactionType {
        case sent
        case received
        case zapped
        case nutzapped
        case minted
        case melted
        case swapped
    }
    struct WalletTransaction: Identifiable {
        let id = UUID()
        let type: TransactionType
        let amount: Int64
        let description: String
        let timestamp: Date
        let mint: String?
        let invoice: String?
        let fee: Int64?
        let status: TransactionStatus
        let direction: Direction?
        enum TransactionStatus {
            case pending
            case completed
            case failed
        }
        enum Direction {
            case incoming
            case outgoing
        }
    }
    private let nostrManager: NostrManager
    private var walletEventTask: Task<Void, Never>?
    // Simplified wallet state - in production would use CashuSwift
    private var walletState: WalletState = WalletState()
    init(nostrManager: NostrManager) {
        self.nostrManager = nostrManager
    }
    deinit {
        walletEventTask?.cancel()
    }
    // MARK: - Wallet Operations
    /// Load or create wallet for current user
    func loadWallet() async throws {
        print(" OlasWalletManager.loadWallet() called")
        guard nostrManager.isAuthenticated else {
            throw WalletError.notAuthenticated
        }
        guard let ndk = nostrManager.ndk else {
            throw WalletError.ndkNotInitialized
        }
        isLoading = true
        defer { isLoading = false }
        do {
            // Create or load NIP60 wallet
            let wallet = try NIP60Wallet(ndk: ndk)
            activeWallet = wallet
            // Initialize with default mints if needed
            if mintURLs.isEmpty {
                mintURLs = [
                    "https://mint.minibits.cash/Bitcoin",
                    "https://testnut.cashu.space",
                    "https://8333.space:3338"
                ]
            }
            // Initialize wallet state
            await initializeWallet()
            // Start monitoring wallet events
            await startWalletEventMonitoring()
            // Load balances from all mints
            await updateAllBalances()
            // Load existing tokens from storage
            await loadStoredTokens()
            print(" Wallet loaded successfully with \(activeTokens.count) tokens")
        } catch {
            self.error = error
            print(" Error loading wallet: \(error)")
            throw error
        }
    }
    /// Initialize wallet state
    private func initializeWallet() async {
        // In production, would connect to actual mints
        for mintURL in mintURLs {
            walletState.mintInfo[mintURL] = WalletState.MintInfo(
                name: mintURL.replacingOccurrences(of: "https://", with: ""),
                publicKey: "mock-public-key",
                version: "0.1.0"
            )
            print(" Connected to mint: \(mintURL)")
        }
    }
    /// Add a new mint
    func addMint(_ mintURL: String) async throws {
        guard let url = URL(string: mintURL) else {
            throw WalletError.invalidMintURL
        }
        // In production, test actual connection to mint
        // For now, just validate URL format
        guard url.scheme == "https" else {
            throw WalletError.invalidMintURL
        }
        // Add to list if successful
        if !mintURLs.contains(mintURL) {
            mintURLs.append(mintURL)
            await updateMintBalance(mintURL)
        }
    }
    /// Remove a mint
    func removeMint(_ mintURL: String) async throws {
        // Check if we have tokens from this mint
        let tokensFromMint = activeTokens.filter { $0.mint == mintURL }
        if !tokensFromMint.isEmpty {
            throw WalletError.cannotRemoveMintWithTokens
        }
        mintURLs.removeAll { $0 == mintURL }
        mintBalances.removeValue(forKey: mintURL)
    }
    /// Send sats via Lightning invoice
    func payInvoice(_ invoice: String, comment: String?) async throws {
        guard !mintURLs.isEmpty else {
            throw WalletError.walletNotConfigured
        }
        let primaryMint = mintURLs.first!
        isLoading = true
        defer { isLoading = false }
        do {
            // Parse invoice to get amount
            let invoiceAmount = try await getInvoiceAmount(invoice)
            guard currentBalance >= invoiceAmount else {
                throw WalletError.insufficientBalance
            }
            // In production, get quote from mint
            let feeReserve: Int64 = 10 // Mock fee
            let totalAmount = invoiceAmount + feeReserve
            // Select tokens to spend
            let tokensToSpend = selectTokensForAmount(totalAmount)
            guard !tokensToSpend.isEmpty else {
                throw WalletError.insufficientTokens
            }
            // In production, melt tokens via mint API
            // For now, just remove spent tokens
            activeTokens.removeAll { token in
                tokensToSpend.contains { $0.id == token.id }
            }
            // Record transaction
            let transaction = WalletTransaction(
                type: .sent,
                amount: invoiceAmount,
                description: comment ?? "Lightning payment",
                timestamp: Date(),
                mint: primaryMint,
                invoice: invoice,
                fee: feeReserve,
                status: .completed,
                direction: .outgoing
            )
            recentTransactions.insert(transaction, at: 0)
            // Update balance
            await updateAllBalances()
            print(" Successfully paid \(invoiceAmount) sats")
        } catch {
            print(" Payment failed: \(error)")
            throw error
        }
    }
    /// Send ecash tokens directly
    func sendEcash(amount: Int64, comment: String?) async throws -> String {
        guard !mintURLs.isEmpty else {
            throw WalletError.walletNotConfigured
        }
        isLoading = true
        defer { isLoading = false }
        do {
            // Select tokens for the amount
            let tokensToSend = selectTokensForAmount(amount)
            guard !tokensToSend.isEmpty else {
                throw WalletError.insufficientTokens
            }
            // Create cashu token string
            let tokenString = try encodeCashuToken(tokensToSend)
            // Remove sent tokens from wallet
            activeTokens.removeAll { token in
                tokensToSend.contains { $0.id == token.id }
            }
            // Record transaction
            let transaction = WalletTransaction(
                type: .sent,
                amount: amount,
                description: comment ?? "Sent ecash",
                timestamp: Date(),
                mint: tokensToSend.first?.mint,
                invoice: nil,
                fee: 0,
                status: .completed,
                direction: .outgoing
            )
            recentTransactions.insert(transaction, at: 0)
            // Update balance
            await updateAllBalances()
            return tokenString
        } catch {
            print(" Failed to create ecash token: \(error)")
            throw error
        }
    }
    /// Zap an event
    func zapEvent(_ event: NDKEvent, amount: Int64, comment: String?) async throws {
        guard activeWallet != nil else {
            throw WalletError.walletNotConfigured
        }
        isLoading = true
        defer { isLoading = false }
        print(" Zapping event \(event.id) with \(amount) sats")
        // Add to transactions
        let transaction = WalletTransaction(
            type: .zapped,
            amount: amount,
            description: comment ?? "Zapped a post",
            timestamp: Date(),
            mint: nil,
            invoice: nil,
            fee: 0,
            status: .completed,
            direction: .outgoing
        )
        recentTransactions.insert(transaction, at: 0)
        // Update balance
        currentBalance -= amount
    }
    /// Generate a lightning invoice to receive payment
    func generateInvoice(amount: Int64, description: String?) async throws -> String {
        guard mintURLs.first != nil else {
            throw WalletError.walletNotConfigured
        }
        isLoading = true
        defer { isLoading = false }
        // In production, get mint quote
        // For now, generate mock invoice
        let quote = UUID().uuidString
        let invoice = "lnbc\(amount)1pjrmq3pp5" + UUID().uuidString.replacingOccurrences(of: "-", with: "")
        // Store pending invoice
        pendingInvoices[quote] = (
            amount: amount,
            description: description ?? "Olas payment",
            expiry: Date().addingTimeInterval(3600)
        )
        // Start monitoring for payment
        Task {
            await monitorInvoicePayment(quote: quote, amount: amount)
        }
        return invoice
    }
    /// Receive ecash tokens
    func receiveEcash(_ tokenString: String) async throws {
        // In production, would use actual wallet
        guard !mintURLs.isEmpty else {
            throw WalletError.walletNotConfigured
        }
        isLoading = true
        defer { isLoading = false }
        do {
            // Decode token string
            let receivedTokens = try decodeCashuToken(tokenString)
            // In production, verify tokens with mint
            // For now, just accept them
            let validTokens = receivedTokens
            // Add to active tokens
            activeTokens.append(contentsOf: validTokens)
            // Calculate total amount
            let totalAmount = validTokens.reduce(0) { $0 + $1.amount }
            // Record transaction
            let transaction = WalletTransaction(
                type: .received,
                amount: Int64(totalAmount),
                description: "Received ecash",
                timestamp: Date(),
                mint: validTokens.first?.mint,
                invoice: nil,
                fee: 0,
                status: .completed,
                direction: .incoming
            )
            recentTransactions.insert(transaction, at: 0)
            // Update balance
            await updateAllBalances()
            // Store tokens
            await storeTokens()
            print(" Successfully received \(totalAmount) sats")
        } catch {
            print(" Failed to receive ecash: \(error)")
            throw error
        }
    }
    /// Monitor invoice payment
    private func monitorInvoicePayment(quote: String, amount: Int64) async {
        guard let primaryMint = mintURLs.first else { return }
        // Poll for payment (in production, use websocket)
        for _ in 0..<60 { // Check for 5 minutes
            // In production, mint tokens from paid invoice
            // For now, create mock tokens
            let tokens = [
                WalletToken(amount: UInt64(amount), mint: primaryMint)
            ]
            // Payment successful
            activeTokens.append(contentsOf: tokens)
            // Remove from pending
            pendingInvoices.removeValue(forKey: quote)
            // Record transaction
            let transaction = WalletTransaction(
                type: .received,
                amount: amount,
                description: "Lightning payment received",
                timestamp: Date(),
                mint: primaryMint,
                invoice: nil,
                fee: 0,
                status: .completed,
                direction: .incoming
            )
            await MainActor.run {
                recentTransactions.insert(transaction, at: 0)
            }
            // Update balance
            await updateAllBalances()
            // Store tokens
            await storeTokens()
            print(" Invoice paid: \(amount) sats received")
            return
        }
        // Invoice expired
        _ = await MainActor.run { @MainActor in
            pendingInvoices.removeValue(forKey: quote)
        }
    }
    // MARK: - Private Methods
    private func startWalletEventMonitoring() async {
        walletEventTask?.cancel()
        guard let ndk = nostrManager.ndk else { return }
        walletEventTask = Task {
            // Monitor for wallet events
            // In a real implementation, this would monitor proper wallet event kinds
            // For now, we'll just monitor for zap receipts
            guard let userPubkey = try? await ndk.signer?.pubkey else { return }
            let filter = NDKFilter(
                authors: [userPubkey],
                kinds: [EventKind.zap]
            )
            let dataSource = ndk.observe(
                filter: filter,
                maxAge: 0,
                cachePolicy: .cacheWithNetwork
            )
            for await event in dataSource.events {
                await handleWalletEvent(event)
            }
        }
    }
    private func handleWalletEvent(_ event: NDKEvent) async {
        print(" Received wallet event: kind \(event.kind)")
        // Handle different wallet event types
        switch event.kind {
        case EventKind.zap:
            // Handle zap receipt
            // In a real implementation, parse the zap receipt to update balance
            await updateAllBalances()
        default:
            break
        }
    }
    private func updateAllBalances() async {
        var totalBalance: Int64 = 0
        // Calculate balance from active tokens
        for token in activeTokens {
            totalBalance += Int64(token.amount)
        }
        currentBalance = totalBalance
        // Update balance per mint
        for mintURL in mintURLs {
            await updateMintBalance(mintURL)
        }
    }
    private func updateMintBalance(_ mintURL: String) async {
        let mintTokens = activeTokens.filter { $0.mint == mintURL }
        let mintBalance = mintTokens.reduce(0) { $0 + Int64($1.amount) }
        await MainActor.run {
            mintBalances[mintURL] = mintBalance
        }
    }
    /// Select tokens for a specific amount
    private func selectTokensForAmount(_ amount: Int64) -> [WalletToken] {
        var selectedTokens: [WalletToken] = []
        var currentAmount: Int64 = 0
        // Sort tokens by amount (descending) for optimal selection
        let sortedTokens = activeTokens.sorted { $0.amount > $1.amount }
        for token in sortedTokens {
            if currentAmount >= amount {
                break
            }
            selectedTokens.append(token)
            currentAmount += Int64(token.amount)
        }
        return currentAmount >= amount ? selectedTokens : []
    }
    /// Get invoice amount from bolt11
    private func getInvoiceAmount(_ invoice: String) async throws -> Int64 {
        // In production, use proper bolt11 parsing
        // For now, extract amount from invoice string
        if let match = invoice.range(of: #"lnbc(\d+)"#, options: .regularExpression) {
            let amountString = String(invoice[match]).replacingOccurrences(of: "lnbc", with: "")
            if let amount = Int64(amountString) {
                return amount * 1000 // Convert to millisats
            }
        }
        throw WalletError.invalidInvoice
    }
    /// Encode tokens to cashu token string
    private func encodeCashuToken(_ tokens: [WalletToken]) throws -> String {
        // In production, use proper cashu token encoding
        // For now, create a simple representation
        let tokenData = tokens.map { token in
            ["amount": token.amount, "C": token.C, "id": token.id, "secret": token.secret, "mint": token.mint] as [String : Any]
        }
        let jsonData = try JSONSerialization.data(withJSONObject: tokenData)
        return "cashuA" + jsonData.base64EncodedString()
    }
    /// Decode cashu token string
    private func decodeCashuToken(_ tokenString: String) throws -> [WalletToken] {
        // In production, use proper cashu token decoding
        guard tokenString.hasPrefix("cashu") else {
            throw WalletError.invalidToken
        }
        // For now, return empty array
        return []
    }
    /// Store tokens securely
    private func storeTokens() async {
        // In production, store encrypted in keychain
        // For now, just log
        print(" Storing \(activeTokens.count) tokens")
    }
    /// Load stored tokens
    private func loadStoredTokens() async {
        // In production, load from keychain
        // For now, start with empty tokens
        activeTokens = []
    }
}
// MARK: - Wallet Models
struct WalletToken: Identifiable, Codable {
    let id: String
    let amount: UInt64
    let secret: String
    let C: String
    let mint: String
    init(amount: UInt64, mint: String) {
        self.id = UUID().uuidString
        self.amount = amount
        self.mint = mint
        self.secret = UUID().uuidString // Simplified - in production use proper cryptography
        self.C = UUID().uuidString // Simplified - in production use proper cryptography
    }
}
struct WalletState {
    var mintInfo: [String: MintInfo] = [:]
    struct MintInfo {
        let name: String
        let publicKey: String
        let version: String
    }
}
// MARK: - Error Types
enum WalletError: LocalizedError {
    case notAuthenticated
    case ndkNotInitialized
    case walletNotConfigured
    case insufficientBalance
    case insufficientTokens
    case invoiceGenerationFailed
    case paymentFailed(String)
    case invalidMintURL
    case cannotRemoveMintWithTokens
    case invalidInvoice
    case invalidToken
    case mintConnectionFailed
    var errorDescription: String? {
        switch self {
        case .notAuthenticated:
            return "User not authenticated"
        case .ndkNotInitialized:
            return "NDK not initialized"
        case .walletNotConfigured:
            return "Wallet not configured"
        case .insufficientBalance:
            return "Insufficient balance"
        case .insufficientTokens:
            return "Not enough tokens for this amount"
        case .invoiceGenerationFailed:
            return "Failed to generate invoice"
        case .paymentFailed(let reason):
            return "Payment failed: \(reason)"
        case .invalidMintURL:
            return "Invalid mint URL"
        case .cannotRemoveMintWithTokens:
            return "Cannot remove mint with active tokens"
        case .invalidInvoice:
            return "Invalid lightning invoice"
        case .invalidToken:
            return "Invalid ecash token"
        case .mintConnectionFailed:
            return "Failed to connect to mint"
        }
    }
}
// MARK: - NWC Response (simplified)
private struct NWCResponse: Codable {
    let result_type: String
    let error: NWCError?
    let result: NWCResult?
}
private struct NWCError: Codable {
    let code: String
    let message: String
}
private struct NWCResult: Codable {
    let preimage: String?
}
</file>

<file path="Olas/Utils/OlasUtilities.swift">
import SwiftUI
// MARK: - Olas Utilities
// This file contains utility functions and extensions specific to Olas
extension String {
    func nsecToHex() -> String? {
        guard self.hasPrefix("nsec1") else { return nil }
        let bech32String = String(self.dropFirst(5))
        // Bech32 character set
        let charset = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"
        // Convert from bech32
        var data: [UInt8] = []
        for char in bech32String {
            guard let index = charset.firstIndex(of: char) else { return nil }
            let value = charset.distance(from: charset.startIndex, to: index)
            data.append(UInt8(value))
        }
        // Convert 5-bit groups to 8-bit groups
        var result: [UInt8] = []
        var buffer = 0
        var bits = 0
        for value in data {
            buffer = (buffer << 5) | Int(value)
            bits += 5
            while bits >= 8 {
                bits -= 8
                result.append(UInt8((buffer >> bits) & 0xFF))
            }
        }
        // Convert to hex string
        return result.map { String(format: "%02x", $0) }.joined()
    }
}
</file>

<file path="Olas/Views/Analytics/AnalyticsDashboardView.swift">
import SwiftUI
import Charts
import NDKSwift
struct AnalyticsDashboardView: View {
    @Environment(NostrManager.self) private var nostrManager
    @StateObject private var analyticsManager = AnalyticsManager()
    @State private var selectedTimeRange = TimeRange.week
    @State private var showingDetailedStats = false
    enum TimeRange: String, CaseIterable {
        case day = "24h"
        case week = "7d"
        case month = "30d"
        case all = "All"
    }
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: OlasDesign.Spacing.lg) {
                    // Time range selector
                    timeRangeSelector
                        .padding(.horizontal)
                    // Overview cards
                    overviewSection
                    // Engagement chart
                    engagementChart
                    // Top posts
                    topPostsSection
                    // Follower growth
                    followerGrowthChart
                    // Audience insights
                    audienceInsights
                    // Content performance
                    contentPerformance
                }
                .padding(.vertical)
            }
            .background(
                LinearGradient(
                    colors: [
                        OlasDesign.Colors.background,
                        OlasDesign.Colors.background.opacity(0.95)
                    ],
                    startPoint: .top,
                    endPoint: .bottom
                )
            )
            .navigationTitle("Analytics")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        Task {
                            await analyticsManager.refreshData()
                        }
                    }) {
                        Image(systemName: "arrow.clockwise")
                            .foregroundColor(OlasDesign.Colors.primary)
                    }
                }
            }
            .task {
                if let ndk = nostrManager.ndk {
                    await analyticsManager.loadAnalytics(ndk: ndk, timeRange: selectedTimeRange)
                }
            }
            .onChange(of: selectedTimeRange) { _, newValue in
                Task {
                    if let ndk = nostrManager.ndk {
                        await analyticsManager.loadAnalytics(ndk: ndk, timeRange: newValue)
                    }
                }
            }
        }
    }
    private var timeRangeSelector: some View {
        HStack(spacing: 0) {
            ForEach(TimeRange.allCases, id: \.self) { range in
                Button(action: {
                    withAnimation(.spring()) {
                        selectedTimeRange = range
                    }
                    OlasDesign.Haptic.selection()
                }) {
                    Text(range.rawValue)
                        .font(OlasDesign.Typography.bodyMedium)
                        .foregroundColor(selectedTimeRange == range ? .white : OlasDesign.Colors.text)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, OlasDesign.Spacing.sm)
                        .background(
                            selectedTimeRange == range ?
                            LinearGradient(
                                colors: OlasDesign.Colors.primaryGradient,
                                startPoint: .leading,
                                endPoint: .trailing
                            ) : nil
                        )
                }
            }
        }
        .background(OlasDesign.Colors.surface)
        .cornerRadius(OlasDesign.CornerRadius.md)
    }
    private var overviewSection: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            HStack(spacing: OlasDesign.Spacing.md) {
                AnalyticsCard(
                    title: "Total Views",
                    value: formatNumber(analyticsManager.totalViews),
                    change: analyticsManager.viewsChange,
                    icon: "eye.fill",
                    gradient: [Color(hex: "FF6B6B"), Color(hex: "4ECDC4")]
                )
                AnalyticsCard(
                    title: "Engagement",
                    value: formatNumber(analyticsManager.totalEngagement),
                    change: analyticsManager.engagementChange,
                    icon: "heart.fill",
                    gradient: [Color(hex: "667EEA"), Color(hex: "764BA2")]
                )
            }
            HStack(spacing: OlasDesign.Spacing.md) {
                AnalyticsCard(
                    title: "Followers",
                    value: formatNumber(analyticsManager.followerCount),
                    change: analyticsManager.followerChange,
                    icon: "person.2.fill",
                    gradient: [Color(hex: "F093FB"), Color(hex: "F5576C")]
                )
                AnalyticsCard(
                    title: "Reach",
                    value: formatNumber(analyticsManager.totalReach),
                    change: analyticsManager.reachChange,
                    icon: "network",
                    gradient: [Color(hex: "4FACFE"), Color(hex: "00F2FE")]
                )
            }
        }
        .padding(.horizontal)
    }
    private var engagementChart: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Engagement Overview")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
                .padding(.horizontal)
            Chart(analyticsManager.engagementData) { data in
                AreaMark(
                    x: .value("Date", data.date),
                    y: .value("Engagement", data.value)
                )
                .foregroundStyle(
                    LinearGradient(
                        colors: [
                            OlasDesign.Colors.primary.opacity(0.6),
                            OlasDesign.Colors.primary.opacity(0.1)
                        ],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )
                .interpolationMethod(.catmullRom)
                LineMark(
                    x: .value("Date", data.date),
                    y: .value("Engagement", data.value)
                )
                .foregroundStyle(OlasDesign.Colors.primary)
                .lineStyle(StrokeStyle(lineWidth: 3))
                .interpolationMethod(.catmullRom)
            }
            .frame(height: 200)
            .padding(.horizontal)
        }
        .padding(.vertical)
        .background(OlasDesign.Colors.surface.opacity(0.5))
        .cornerRadius(OlasDesign.CornerRadius.lg)
        .padding(.horizontal)
    }
    private var topPostsSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            HStack {
                Text("Top Posts")
                    .font(OlasDesign.Typography.title3)
                    .foregroundColor(OlasDesign.Colors.text)
                Spacer()
                Button("See All") {
                    showingDetailedStats = true
                }
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.primary)
            }
            .padding(.horizontal)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: OlasDesign.Spacing.md) {
                    ForEach(analyticsManager.topPosts) { post in
                        TopPostCard(post: post)
                    }
                }
                .padding(.horizontal)
            }
        }
    }
    private var followerGrowthChart: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Follower Growth")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
                .padding(.horizontal)
            Chart(analyticsManager.followerGrowthData) { data in
                BarMark(
                    x: .value("Day", data.date, unit: .day),
                    y: .value("New Followers", data.value)
                )
                .foregroundStyle(
                    LinearGradient(
                        colors: OlasDesign.Colors.primaryGradient,
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )
                .cornerRadius(4)
            }
            .frame(height: 150)
            .padding(.horizontal)
        }
        .padding(.vertical)
        .background(OlasDesign.Colors.surface.opacity(0.5))
        .cornerRadius(OlasDesign.CornerRadius.lg)
        .padding(.horizontal)
    }
    private var audienceInsights: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Audience Insights")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
                .padding(.horizontal)
            // Active times heatmap
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                Text("Most Active Times")
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
                ActiveTimesHeatmap(data: analyticsManager.activeTimesData)
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .fill(OlasDesign.Colors.surface.opacity(0.7))
            )
            // Demographics
            HStack(spacing: OlasDesign.Spacing.md) {
                DemographicChart(
                    title: "Top Locations",
                    data: analyticsManager.topLocations
                )
                DemographicChart(
                    title: "Top Interests",
                    data: analyticsManager.topInterests
                )
            }
        }
        .padding(.horizontal)
    }
    private var contentPerformance: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Content Performance")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
                .padding(.horizontal)
            // Content type breakdown
            Chart(analyticsManager.contentTypeData) { data in
                SectorMark(
                    angle: .value("Count", data.value),
                    innerRadius: .ratio(0.618),
                    angularInset: 2
                )
                .foregroundStyle(by: .value("Type", data.type))
                .cornerRadius(4)
            }
            .frame(height: 200)
            .padding()
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                    .fill(OlasDesign.Colors.surface.opacity(0.7))
            )
            .padding(.horizontal)
        }
    }
    private func formatNumber(_ number: Int) -> String {
        if number >= 1_000_000 {
            return String(format: "%.1fM", Double(number) / 1_000_000)
        } else if number >= 1_000 {
            return String(format: "%.1fK", Double(number) / 1_000)
        } else {
            return "\(number)"
        }
    }
}
// MARK: - Analytics Manager
@MainActor
class AnalyticsManager: ObservableObject {
    @Published var totalViews = 0
    @Published var viewsChange: Double = 0
    @Published var totalEngagement = 0
    @Published var engagementChange: Double = 0
    @Published var followerCount = 0
    @Published var followerChange: Double = 0
    @Published var totalReach = 0
    @Published var reachChange: Double = 0
    @Published var engagementData: [ChartData] = []
    @Published var followerGrowthData: [ChartData] = []
    @Published var topPosts: [TopPost] = []
    @Published var activeTimesData: [[Double]] = []
    @Published var topLocations: [DemographicData] = []
    @Published var topInterests: [DemographicData] = []
    @Published var contentTypeData: [ContentTypeData] = []
    func loadAnalytics(ndk: NDK, timeRange: AnalyticsDashboardView.TimeRange) async {
        // Simulate loading analytics data
        // In a real app, this would query Nostr events and calculate metrics
        // Generate mock data
        totalViews = Int.random(in: 10000...50000)
        viewsChange = Double.random(in: -20...50)
        totalEngagement = Int.random(in: 1000...10000)
        engagementChange = Double.random(in: -10...30)
        followerCount = Int.random(in: 500...5000)
        followerChange = Double.random(in: -5...20)
        totalReach = Int.random(in: 20000...100000)
        reachChange = Double.random(in: -15...40)
        // Generate chart data
        engagementData = generateChartData(days: 7)
        followerGrowthData = generateChartData(days: 7)
        topPosts = generateTopPosts()
        activeTimesData = generateHeatmapData()
        topLocations = generateDemographicData(type: .location)
        topInterests = generateDemographicData(type: .interest)
        contentTypeData = generateContentTypeData()
    }
    func refreshData() async {
        // Refresh analytics data
    }
    private func generateChartData(days: Int) -> [ChartData] {
        (0..<days).map { day in
            ChartData(
                date: Date().addingTimeInterval(-Double(day) * 86400),
                value: Int.random(in: 100...1000)
            )
        }.reversed()
    }
    private func generateTopPosts() -> [TopPost] {
        (1...5).map { index in
            TopPost(
                id: "\(index)",
                imageURL: "https://picsum.photos/200/300?random=\(index)",
                engagement: Int.random(in: 100...1000),
                views: Int.random(in: 1000...10000),
                timestamp: Date().addingTimeInterval(-Double.random(in: 0...604800))
            )
        }
    }
    private func generateHeatmapData() -> [[Double]] {
        (0..<7).map { _ in
            (0..<24).map { _ in Double.random(in: 0...1) }
        }
    }
    private func generateDemographicData(type: DemographicType) -> [DemographicData] {
        let items = type == .location ?
            ["USA", "Japan", "Brazil", "Germany", "UK"] :
            ["Bitcoin", "Photography", "Art", "Tech", "Music"]
        return items.enumerated().map { index, name in
            DemographicData(
                name: name,
                value: Double(100 - index * 15),
                percentage: Double(30 - index * 5)
            )
        }
    }
    private func generateContentTypeData() -> [ContentTypeData] {
        [
            ContentTypeData(type: "Photos", value: 60),
            ContentTypeData(type: "Videos", value: 25),
            ContentTypeData(type: "Stories", value: 10),
            ContentTypeData(type: "Text", value: 5)
        ]
    }
}
// MARK: - Supporting Views
struct AnalyticsCard: View {
    let title: String
    let value: String
    let change: Double
    let icon: String
    let gradient: [Color]
    var body: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            HStack {
                Image(systemName: icon)
                    .font(.title3)
                    .foregroundStyle(
                        LinearGradient(
                            colors: gradient,
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                Spacer()
                if change != 0 {
                    HStack(spacing: 2) {
                        Image(systemName: change > 0 ? "arrow.up.right" : "arrow.down.right")
                            .font(.caption)
                        Text("\(abs(Int(change)))%")
                            .font(.caption)
                    }
                    .foregroundColor(change > 0 ? .green : .red)
                }
            }
            Text(value)
                .font(.system(size: 28, weight: .bold, design: .rounded))
                .foregroundColor(OlasDesign.Colors.text)
            Text(title)
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                .fill(OlasDesign.Colors.surface.opacity(0.7))
                .overlay(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                        .stroke(
                            LinearGradient(
                                colors: gradient.map { $0.opacity(0.3) },
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 1
                        )
                )
        )
    }
}
struct TopPostCard: View {
    let post: TopPost
    var body: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            AsyncImage(url: URL(string: post.imageURL)) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .fill(Color.gray.opacity(0.3))
            }
            .frame(width: 120, height: 150)
            .clipped()
            .cornerRadius(OlasDesign.CornerRadius.md)
            VStack(alignment: .leading, spacing: 2) {
                HStack(spacing: 4) {
                    Image(systemName: "heart.fill")
                        .font(.caption2)
                    Text("\(post.engagement)")
                        .font(.caption)
                }
                HStack(spacing: 4) {
                    Image(systemName: "eye.fill")
                        .font(.caption2)
                    Text("\(post.views)")
                        .font(.caption)
                }
            }
            .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .padding(8)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .fill(OlasDesign.Colors.surface.opacity(0.7))
        )
    }
}
struct ActiveTimesHeatmap: View {
    let data: [[Double]]
    let days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
    var body: some View {
        VStack(spacing: 2) {
            ForEach(0..<7) { day in
                HStack(spacing: 2) {
                    Text(days[day])
                        .font(.caption2)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        .frame(width: 30)
                    ForEach(0..<24) { hour in
                        RoundedRectangle(cornerRadius: 2)
                            .fill(
                                Color.green.opacity(
                                    data.indices.contains(day) && data[day].indices.contains(hour) ?
                                    data[day][hour] : 0
                                )
                            )
                            .frame(width: 10, height: 10)
                    }
                }
            }
        }
    }
}
struct DemographicChart: View {
    let title: String
    let data: [DemographicData]
    var body: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            Text(title)
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textSecondary)
            VStack(spacing: OlasDesign.Spacing.xs) {
                ForEach(data) { item in
                    HStack {
                        Text(item.name)
                            .font(.caption)
                            .foregroundColor(OlasDesign.Colors.text)
                            .lineLimit(1)
                        Spacer()
                        Text("\(Int(item.percentage))%")
                            .font(.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    GeometryReader { geometry in
                        RoundedRectangle(cornerRadius: 2)
                            .fill(OlasDesign.Colors.surface)
                            .overlay(
                                RoundedRectangle(cornerRadius: 2)
                                    .fill(
                                        LinearGradient(
                                            colors: OlasDesign.Colors.primaryGradient,
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        )
                                    )
                                    .frame(width: geometry.size.width * item.value / 100),
                                alignment: .leading
                            )
                    }
                    .frame(height: 4)
                }
            }
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .fill(OlasDesign.Colors.surface.opacity(0.7))
        )
    }
}
// MARK: - Data Models
struct ChartData: Identifiable {
    let id = UUID()
    let date: Date
    let value: Int
}
struct TopPost: Identifiable {
    let id: String
    let imageURL: String
    let engagement: Int
    let views: Int
    let timestamp: Date
}
struct DemographicData: Identifiable {
    let id = UUID()
    let name: String
    let value: Double
    let percentage: Double
}
struct ContentTypeData: Identifiable {
    let id = UUID()
    let type: String
    let value: Int
}
enum DemographicType {
    case location
    case interest
}
</file>

<file path="Olas/Views/Components/AdvancedCameraView.swift">
import SwiftUI
import AVFoundation
import CoreImage
import CoreImage.CIFilterBuiltins
import Vision
struct AdvancedCameraView: View {
    @Binding var capturedImage: UIImage?
    @Binding var capturedVideo: URL?
    @State private var cameraMode: CameraMode = .photo
    @State private var currentFilter: FilterType = .none
    @State private var isFlashOn = false
    @State private var isGridVisible = false
    @State private var zoomLevel: CGFloat = 1.0
    @State private var exposureLevel: Float = 0.0
    @State private var beautifyLevel: Float = 0.0
    @State private var showFilters = false
    @State private var detectedFaces: [VNFaceObservation] = []
    @Environment(\.dismiss) private var dismiss
    enum CameraMode {
        case photo, video, portrait, night, pro
    }
    enum FilterType: String, CaseIterable {
        case none = "Normal"
        case vivid = "Vivid"
        case noir = "Noir"
        case chrome = "Chrome"
        case fade = "Fade"
        case instant = "Instant"
        case tonal = "Tonal"
        case process = "Process"
        case transfer = "Transfer"
        case sepia = "Sepia"
        case comic = "Comic"
        case crystallize = "Crystal"
        case thermal = "Thermal"
        case vortex = "Vortex"
        var ciFilterName: String? {
            switch self {
            case .none: return nil
            case .vivid: return "CIPhotoEffectChrome"
            case .noir: return "CIPhotoEffectNoir"
            case .chrome: return "CIPhotoEffectChrome"
            case .fade: return "CIPhotoEffectFade"
            case .instant: return "CIPhotoEffectInstant"
            case .tonal: return "CIPhotoEffectTonal"
            case .process: return "CIPhotoEffectProcess"
            case .transfer: return "CIPhotoEffectTransfer"
            case .sepia: return "CISepiaTone"
            case .comic: return "CIComicEffect"
            case .crystallize: return "CICrystallize"
            case .thermal: return "CIThermal"
            case .vortex: return "CIVortexDistortion"
            }
        }
        var icon: String {
            switch self {
            case .none: return "camera.filters"
            case .vivid: return "sun.max.fill"
            case .noir: return "moon.fill"
            case .chrome: return "sparkles"
            case .fade: return "cloud.fill"
            case .instant: return "camera.fill"
            case .tonal: return "circle.lefthalf.filled"
            case .process: return "square.stack.3d.up.fill"
            case .transfer: return "arrow.triangle.2.circlepath"
            case .sepia: return "drop.fill"
            case .comic: return "book.fill"
            case .crystallize: return "square.grid.3x3.fill"
            case .thermal: return "thermometer.sun.fill"
            case .vortex: return "tornado"
            }
        }
    }
    var body: some View {
        ZStack {
            // Camera preview
            CameraPreviewView(
                currentFilter: currentFilter,
                zoomLevel: $zoomLevel,
                exposureLevel: $exposureLevel,
                beautifyLevel: $beautifyLevel,
                detectedFaces: $detectedFaces,
                onCapture: { image in
                    capturedImage = image
                    dismiss()
                }
            )
            .ignoresSafeArea()
            // Grid overlay
            if isGridVisible {
                GridOverlay()
                    .ignoresSafeArea()
            }
            // Face detection overlay
            FaceDetectionOverlay(faces: detectedFaces)
                .ignoresSafeArea()
            // Controls overlay
            VStack {
                // Top controls
                topControls
                Spacer()
                // Filter carousel
                if showFilters {
                    filterCarousel
                        .transition(.move(edge: .bottom).combined(with: .opacity))
                }
                // Camera modes
                cameraModeSelector
                // Bottom controls
                bottomControls
            }
        }
        .preferredColorScheme(.dark)
        .statusBarHidden()
    }
    private var topControls: some View {
        HStack {
            // Close button
            Button(action: { dismiss() }) {
                Image(systemName: "xmark")
                    .font(.title2)
                    .foregroundStyle(.white)
                    .padding()
                    .background(Circle().fill(Color.black.opacity(0.5)))
            }
            Spacer()
            // Pro controls
            VStack(spacing: 20) {
                // Flash
                Button(action: { isFlashOn.toggle() }) {
                    Image(systemName: isFlashOn ? "bolt.fill" : "bolt.slash.fill")
                        .font(.title2)
                        .foregroundStyle(isFlashOn ? .yellow : .white)
                        .padding()
                        .background(Circle().fill(Color.black.opacity(0.5)))
                }
                // Grid
                Button(action: { isGridVisible.toggle() }) {
                    Image(systemName: "grid")
                        .font(.title2)
                        .foregroundStyle(isGridVisible ? OlasDesign.Colors.primary : .white)
                        .padding()
                        .background(Circle().fill(Color.black.opacity(0.5)))
                }
                // Settings
                Menu {
                    // Exposure slider
                    VStack {
                        Text("Exposure")
                        Slider(value: $exposureLevel, in: -2...2)
                    }
                    // Beauty slider
                    VStack {
                        Text("Beauty")
                        Slider(value: $beautifyLevel, in: 0...1)
                    }
                } label: {
                    Image(systemName: "slider.horizontal.3")
                        .font(.title2)
                        .foregroundStyle(.white)
                        .padding()
                        .background(Circle().fill(Color.black.opacity(0.5)))
                }
            }
        }
        .padding()
    }
    private var filterCarousel: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 15) {
                ForEach(FilterType.allCases, id: \.self) { filter in
                    FilterThumbnail(
                        filter: filter,
                        isSelected: currentFilter == filter,
                        action: {
                            withAnimation(.spring()) {
                                currentFilter = filter
                            }
                            OlasDesign.Haptic.selection()
                        }
                    )
                }
            }
            .padding(.horizontal)
        }
        .padding(.vertical)
        .background(
            LinearGradient(
                colors: [Color.black.opacity(0.8), Color.black.opacity(0.5)],
                startPoint: .bottom,
                endPoint: .top
            )
        )
    }
    private var cameraModeSelector: some View {
        HStack(spacing: 30) {
            CameraModeButton(title: "PHOTO", isSelected: cameraMode == .photo) {
                cameraMode = .photo
            }
            CameraModeButton(title: "VIDEO", isSelected: cameraMode == .video) {
                cameraMode = .video
            }
            CameraModeButton(title: "PORTRAIT", isSelected: cameraMode == .portrait) {
                cameraMode = .portrait
            }
            CameraModeButton(title: "NIGHT", isSelected: cameraMode == .night) {
                cameraMode = .night
            }
            CameraModeButton(title: "PRO", isSelected: cameraMode == .pro) {
                cameraMode = .pro
            }
        }
        .padding(.horizontal)
        .padding(.bottom, 10)
    }
    private var bottomControls: some View {
        HStack {
            // Gallery
            Button(action: {}) {
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 50, height: 50)
                    .overlay(
                        Image(systemName: "photo.on.rectangle")
                            .foregroundStyle(.white)
                    )
            }
            Spacer()
            // Capture button
            CaptureButton(mode: cameraMode) {
                // Capture action handled by CameraPreviewView
            }
            Spacer()
            // Filter toggle
            Button(action: {
                withAnimation(.spring()) {
                    showFilters.toggle()
                }
            }) {
                Image(systemName: currentFilter == .none ? "camera.filters" : "camera.filters.fill")
                    .font(.title2)
                    .foregroundStyle(currentFilter == .none ? .white : OlasDesign.Colors.primary)
                    .frame(width: 50, height: 50)
                    .background(Circle().fill(Color.black.opacity(0.5)))
            }
        }
        .padding(.horizontal, 30)
        .padding(.bottom, 30)
    }
}
// MARK: - Camera Preview
struct CameraPreviewView: UIViewRepresentable {
    let currentFilter: AdvancedCameraView.FilterType
    @Binding var zoomLevel: CGFloat
    @Binding var exposureLevel: Float
    @Binding var beautifyLevel: Float
    @Binding var detectedFaces: [VNFaceObservation]
    let onCapture: (UIImage) -> Void
    func makeUIView(context: Context) -> CameraPreviewUIView {
        let view = CameraPreviewUIView()
        view.delegate = context.coordinator
        return view
    }
    func updateUIView(_ uiView: CameraPreviewUIView, context: Context) {
        uiView.currentFilter = currentFilter
        uiView.zoomLevel = zoomLevel
        uiView.exposureLevel = exposureLevel
        uiView.beautifyLevel = beautifyLevel
    }
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    class Coordinator: NSObject, CameraPreviewDelegate {
        let parent: CameraPreviewView
        init(_ parent: CameraPreviewView) {
            self.parent = parent
        }
        func didCapturePhoto(_ image: UIImage) {
            parent.onCapture(image)
        }
        func didDetectFaces(_ faces: [VNFaceObservation]) {
            parent.detectedFaces = faces
        }
    }
}
protocol CameraPreviewDelegate: AnyObject {
    func didCapturePhoto(_ image: UIImage)
    func didDetectFaces(_ faces: [VNFaceObservation])
}
class CameraPreviewUIView: UIView {
    weak var delegate: CameraPreviewDelegate?
    var currentFilter: AdvancedCameraView.FilterType = .none
    var zoomLevel: CGFloat = 1.0
    var exposureLevel: Float = 0.0
    var beautifyLevel: Float = 0.0
    private var captureSession: AVCaptureSession?
    private var previewLayer: AVCaptureVideoPreviewLayer?
    private let context = CIContext()
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupCamera()
    }
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    private func setupCamera() {
        // Camera setup implementation
        // This is a simplified version - full implementation would include:
        // - AVCaptureSession setup
        // - Camera device configuration
        // - Preview layer setup
        // - Face detection setup
        // - Filter application
    }
}
// MARK: - Supporting Views
struct FilterThumbnail: View {
    let filter: AdvancedCameraView.FilterType
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                ZStack {
                    Circle()
                        .fill(
                            isSelected ?
                            LinearGradient(
                                colors: OlasDesign.Colors.primaryGradient,
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ) :
                            LinearGradient(
                                colors: [Color.gray.opacity(0.3)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 60, height: 60)
                    Image(systemName: filter.icon)
                        .font(.title2)
                        .foregroundStyle(.white)
                }
                Text(filter.rawValue)
                    .font(.caption)
                    .foregroundStyle(.white)
            }
        }
    }
}
struct CameraModeButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: {
            withAnimation(.spring()) {
                action()
            }
            OlasDesign.Haptic.selection()
        }) {
            Text(title)
                .font(.system(size: 13, weight: .semibold))
                .foregroundStyle(isSelected ? .yellow : .white.opacity(0.7))
                .scaleEffect(isSelected ? 1.1 : 1.0)
        }
    }
}
struct CaptureButton: View {
    let mode: AdvancedCameraView.CameraMode
    let action: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: {
            isPressed = true
            OlasDesign.Haptic.selection()
            action()
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                isPressed = false
            }
        }) {
            ZStack {
                Circle()
                    .stroke(Color.white, lineWidth: 3)
                    .frame(width: 70, height: 70)
                Circle()
                    .fill(mode == .video ? .red : .white)
                    .frame(width: isPressed ? 55 : 60, height: isPressed ? 55 : 60)
                    .animation(.spring(response: 0.3), value: isPressed)
            }
        }
    }
}
struct GridOverlay: View {
    var body: some View {
        GeometryReader { geometry in
            Path { path in
                let width = geometry.size.width
                let height = geometry.size.height
                // Vertical lines
                path.move(to: CGPoint(x: width / 3, y: 0))
                path.addLine(to: CGPoint(x: width / 3, y: height))
                path.move(to: CGPoint(x: 2 * width / 3, y: 0))
                path.addLine(to: CGPoint(x: 2 * width / 3, y: height))
                // Horizontal lines
                path.move(to: CGPoint(x: 0, y: height / 3))
                path.addLine(to: CGPoint(x: width, y: height / 3))
                path.move(to: CGPoint(x: 0, y: 2 * height / 3))
                path.addLine(to: CGPoint(x: width, y: 2 * height / 3))
            }
            .stroke(Color.white.opacity(0.3), lineWidth: 0.5)
        }
    }
}
struct FaceDetectionOverlay: View {
    let faces: [VNFaceObservation]
    var body: some View {
        GeometryReader { geometry in
            ForEach(faces.indices, id: \.self) { index in
                let face = faces[index]
                Rectangle()
                    .stroke(
                        LinearGradient(
                            colors: OlasDesign.Colors.primaryGradient,
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 2
                    )
                    .frame(
                        width: face.boundingBox.width * geometry.size.width,
                        height: face.boundingBox.height * geometry.size.height
                    )
                    .position(
                        x: face.boundingBox.midX * geometry.size.width,
                        y: (1 - face.boundingBox.midY) * geometry.size.height
                    )
            }
        }
    }
}
// MARK: - AR Effects
struct AREffectsView: View {
    @State private var selectedEffect: AREffect = .none
    enum AREffect: String, CaseIterable {
        case none = "None"
        case glasses = "Glasses"
        case hat = "Hat"
        case mustache = "Mustache"
        case animalEars = "Animal Ears"
        case sparkles = "Sparkles"
        case hearts = "Hearts"
        case rainbow = "Rainbow"
        case fire = "Fire"
        var icon: String {
            switch self {
            case .none: return "xmark.circle"
            case .glasses: return "eyeglasses"
            case .hat: return "graduationcap.fill"
            case .mustache: return "mustache.fill"
            case .animalEars: return "hare.fill"
            case .sparkles: return "sparkles"
            case .hearts: return "heart.fill"
            case .rainbow: return "rainbow"
            case .fire: return "flame.fill"
            }
        }
    }
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 20) {
                ForEach(AREffect.allCases, id: \.self) { effect in
                    AREffectButton(
                        effect: effect,
                        isSelected: selectedEffect == effect,
                        action: {
                            selectedEffect = effect
                            OlasDesign.Haptic.selection()
                        }
                    )
                }
            }
            .padding()
        }
        .background(Color.black.opacity(0.7))
    }
}
struct AREffectButton: View {
    let effect: AREffectsView.AREffect
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                ZStack {
                    Circle()
                        .fill(
                            isSelected ?
                            LinearGradient(
                                colors: OlasDesign.Colors.primaryGradient,
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ) :
                            LinearGradient(
                                colors: [Color.white.opacity(0.2)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 50, height: 50)
                    Image(systemName: effect.icon)
                        .font(.title3)
                        .foregroundStyle(.white)
                }
                Text(effect.rawValue)
                    .font(.caption2)
                    .foregroundStyle(.white)
            }
        }
    }
}
</file>

<file path="Olas/Views/Components/HeartAnimation.swift">
import SwiftUI
struct HeartAnimation: View {
    let location: CGPoint
    @State private var scale: CGFloat = 0
    @State private var opacity: Double = 1
    @State private var particles: [HeartParticle] = []
    var body: some View {
        ZStack {
            // Main heart
            Image(systemName: "heart.fill")
                .font(.system(size: 80))
                .foregroundStyle(
                    LinearGradient(
                        colors: [OlasDesign.Colors.error, .pink],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .scaleEffect(scale)
                .opacity(opacity)
                .position(location)
                .shadow(color: OlasDesign.Colors.error.opacity(0.3), radius: 10)
            // Particle hearts
            ForEach(particles) { particle in
                Image(systemName: "heart.fill")
                    .font(.system(size: particle.size))
                    .foregroundColor(particle.color)
                    .position(
                        x: location.x + particle.offset.width,
                        y: location.y + particle.offset.height
                    )
                    .opacity(particle.opacity)
            }
        }
        .onAppear {
            // Create particles
            for i in 0..<12 {
                let angle = Double(i) * (360.0 / 12.0) * .pi / 180
                let radius = Double.random(in: 60...120)
                let particle = HeartParticle(
                    angle: angle,
                    radius: radius,
                    size: CGFloat.random(in: 12...20),
                    color: [OlasDesign.Colors.error, .pink, .red].randomElement()!
                )
                particles.append(particle)
            }
            // Animate main heart
            withAnimation(.easeOut(duration: 0.15)) {
                scale = 1.2
            }
            withAnimation(.easeInOut(duration: 0.3).delay(0.15)) {
                scale = 1.0
                opacity = 0
            }
            // Animate particles
            for (index, particle) in particles.enumerated() {
                withAnimation(.easeOut(duration: 0.6).delay(Double(index) * 0.02)) {
                    particles[index].offset = CGSize(
                        width: cos(particle.angle) * particle.radius,
                        height: sin(particle.angle) * particle.radius
                    )
                    particles[index].opacity = 0
                }
            }
        }
    }
}
struct HeartParticle: Identifiable {
    let id = UUID()
    let angle: Double
    let radius: Double
    let size: CGFloat
    let color: Color
    var offset: CGSize = .zero
    var opacity: Double = 1
}
</file>

<file path="Olas/Views/Components/LiveUpdatesIndicator.swift">
import SwiftUI
struct LiveUpdatesIndicator: View {
    @Binding var newPostsCount: Int
    @State private var isAnimating = false
    @State private var showPulse = false
    var body: some View {
        Button {
            OlasDesign.Haptic.selection()
            // Action will be handled by parent view
        } label: {
            HStack(spacing: 12) {
                // Animated live dot
                ZStack {
                    Circle()
                        .fill(Color.green)
                        .frame(width: 8, height: 8)
                    // Pulsing rings
                    ForEach(0..<3) { index in
                        Circle()
                            .stroke(Color.green.opacity(0.4), lineWidth: 1)
                            .frame(width: 8, height: 8)
                            .scaleEffect(showPulse ? CGFloat(2 + index) : 1)
                            .opacity(showPulse ? 0 : 0.6)
                            .animation(
                                .easeOut(duration: 2)
                                .repeatForever(autoreverses: false)
                                .delay(Double(index) * 0.4),
                                value: showPulse
                            )
                    }
                }
                // Text with count
                HStack(spacing: 6) {
                    Text("\(newPostsCount)")
                        .font(.system(size: 16, weight: .bold, design: .rounded))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [
                                    OlasDesign.Colors.primary,
                                    OlasDesign.Colors.primary.opacity(0.8)
                                ],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .contentTransition(.numericText())
                    Text("new \(newPostsCount == 1 ? "post" : "posts")")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundStyle(OlasDesign.Colors.text)
                }
                // Arrow icon
                Image(systemName: "arrow.down.circle.fill")
                    .font(.system(size: 18))
                    .foregroundStyle(
                        LinearGradient(
                            colors: OlasDesign.Colors.primaryGradient,
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .rotationEffect(.degrees(isAnimating ? 0 : -180))
                    .animation(
                        .spring(response: 0.5, dampingFraction: 0.7)
                        .repeatForever(autoreverses: true),
                        value: isAnimating
                    )
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 10)
            .background(
                Capsule()
                    .fill(.ultraThinMaterial)
                    .overlay(
                        Capsule()
                            .fill(
                                LinearGradient(
                                    colors: [
                                        OlasDesign.Colors.primary.opacity(0.1),
                                        OlasDesign.Colors.primary.opacity(0.05)
                                    ],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                    )
                    .overlay(
                        Capsule()
                            .stroke(
                                LinearGradient(
                                    colors: [
                                        Color.white.opacity(0.2),
                                        Color.white.opacity(0.1)
                                    ],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ),
                                lineWidth: 1
                            )
                    )
            )
            .shadow(
                color: OlasDesign.Colors.primary.opacity(0.2),
                radius: 10,
                x: 0,
                y: 5
            )
        }
        .buttonStyle(ScaleButtonStyle())
        .padding(.vertical, 8)
        .onAppear {
            isAnimating = true
            showPulse = true
        }
    }
}
// Custom button style for scale effect
struct ScaleButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: configuration.isPressed)
    }
}
// Preview
struct LiveUpdatesIndicator_Previews: PreviewProvider {
    static var previews: some View {
        VStack {
            LiveUpdatesIndicator(newPostsCount: .constant(5))
            LiveUpdatesIndicator(newPostsCount: .constant(1))
            LiveUpdatesIndicator(newPostsCount: .constant(23))
        }
        .padding()
        .background(Color.black)
    }
}
</file>

<file path="Olas/Views/Components/OlasAvatar.swift">
import SwiftUI
import CryptoKit
struct OlasAvatar: View {
    let url: String?
    let size: CGFloat
    let pubkey: String
    @State private var isLoading = true
    @State private var hasError = false
    private var placeholderGradient: LinearGradient {
        let hash = pubkey.data(using: .utf8) ?? Data()
        let digest = SHA256.hash(data: hash)
        let hashString = digest.compactMap { String(format: "%02x", $0) }.joined()
        // Generate colors based on pubkey hash
        let hue1 = Double(hashString.prefix(2).compactMap { $0.hexDigitValue }.reduce(0) { $0 * 16 + $1 }) / 255.0
        let hue2 = Double(hashString.dropFirst(2).prefix(2).compactMap { $0.hexDigitValue }.reduce(0) { $0 * 16 + $1 }) / 255.0
        return LinearGradient(
            colors: [
                Color(hue: hue1, saturation: 0.7, brightness: 0.8),
                Color(hue: hue2, saturation: 0.6, brightness: 0.7)
            ],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }
    var body: some View {
        ZStack {
            if let url = url, !url.isEmpty, let imageURL = URL(string: url) {
                AsyncImage(url: imageURL) { phase in
                    switch phase {
                    case .empty:
                        // Loading state
                        Circle()
                            .fill(OlasDesign.Colors.surface)
                            .overlay(
                                ProgressView()
                                    .scaleEffect(0.5)
                            )
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: size, height: size)
                            .clipShape(Circle())
                            .overlay(
                                Circle()
                                    .stroke(
                                        LinearGradient(
                                            colors: [
                                                Color.white.opacity(0.2),
                                                Color.white.opacity(0.1)
                                            ],
                                            startPoint: .topLeading,
                                            endPoint: .bottomTrailing
                                        ),
                                        lineWidth: 1
                                    )
                            )
                    case .failure(_):
                        // Error state - show placeholder
                        placeholderAvatar
                    @unknown default:
                        placeholderAvatar
                    }
                }
            } else {
                // No URL - show placeholder
                placeholderAvatar
            }
        }
        .frame(width: size, height: size)
    }
    private var placeholderAvatar: some View {
        Circle()
            .fill(placeholderGradient)
            .overlay(
                Text(String(pubkey.prefix(2).uppercased()))
                    .font(.system(size: size * 0.4, weight: .bold, design: .rounded))
                    .foregroundColor(.white)
            )
            .overlay(
                Circle()
                    .stroke(
                        LinearGradient(
                            colors: [
                                Color.white.opacity(0.3),
                                Color.white.opacity(0.1)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 1
                    )
            )
    }
}
// Preview
struct OlasAvatar_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            OlasAvatar(
                url: "https://example.com/avatar.jpg",
                size: 60,
                pubkey: "npub1234567890abcdef"
            )
            OlasAvatar(
                url: nil,
                size: 40,
                pubkey: "npub0987654321fedcba"
            )
            OlasAvatar(
                url: "",
                size: 80,
                pubkey: "npubabcdef1234567890"
            )
        }
        .padding()
        .background(Color.black)
    }
}
</file>

<file path="Olas/Views/Components/OlasButton.swift">
import SwiftUI
struct OlasButton: View {
    let title: String
    let action: () -> Void
    var style: OlasButtonStyle = .primary
    var isLoading: Bool = false
    var isDisabled: Bool = false
    enum OlasButtonStyle {
        case primary
        case secondary
        case tertiary
        var background: some View {
            Group {
                switch self {
                case .primary:
                    LinearGradient(
                        colors: OlasDesign.Colors.primaryGradient,
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                case .secondary:
                    Color.clear
                        .overlay(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                .stroke(OlasDesign.Colors.divider, lineWidth: 1)
                        )
                case .tertiary:
                    Color.clear
                }
            }
        }
        var foregroundColor: Color {
            switch self {
            case .primary:
                return .white
            case .secondary, .tertiary:
                return OlasDesign.Colors.text
            }
        }
    }
    @State private var isPressed = false
    var body: some View {
        Button(action: {
            if !isLoading && !isDisabled {
                OlasDesign.Haptic.selection()
                action()
            }
        }) {
            ZStack {
                // Background
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .fill(Color.clear)
                    .background(style.background)
                    .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md))
                // Content
                HStack(spacing: OlasDesign.Spacing.sm) {
                    if isLoading {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle(tint: style.foregroundColor))
                            .scaleEffect(0.8)
                    } else {
                        Text(title)
                            .font(OlasDesign.Typography.bodyBold)
                            .foregroundColor(style.foregroundColor)
                    }
                }
                .padding(.horizontal, OlasDesign.Spacing.lg)
                .padding(.vertical, OlasDesign.Spacing.md)
            }
            .opacity(isDisabled ? 0.5 : 1)
            .scaleEffect(isPressed ? 0.95 : 1)
        }
        .disabled(isLoading || isDisabled)
        .onLongPressGesture(minimumDuration: 0, maximumDistance: .infinity) { pressing in
            withAnimation(.easeInOut(duration: 0.1)) {
                isPressed = pressing
            }
        } perform: {}
    }
}
// MARK: - Convenience Modifiers
extension OlasButton {
    func loading(_ isLoading: Bool) -> OlasButton {
        var button = self
        button.isLoading = isLoading
        return button
    }
    func disabled(_ isDisabled: Bool) -> OlasButton {
        var button = self
        button.isDisabled = isDisabled
        return button
    }
}
// MARK: - Preview
#Preview {
    VStack(spacing: 20) {
        OlasButton(title: "Follow", action: {})
        OlasButton(title: "Following", action: {}, style: .secondary)
        OlasButton(title: "Loading", action: {})
            .loading(true)
        OlasButton(title: "Disabled", action: {})
            .disabled(true)
        OlasButton(title: "Tertiary", action: {}, style: .tertiary)
    }
    .padding()
    .background(OlasDesign.Colors.background)
}
</file>

<file path="Olas/Views/Components/OlasCameraView.swift">
import SwiftUI
import AVFoundation
import CoreImage
#if canImport(UIKit)
import UIKit
#endif
#if canImport(UIKit)
struct OlasCameraView: View {
    @Environment(\.dismiss) var dismiss
    let onCapture: (UIImage) -> Void
    @StateObject private var camera = CameraModel()
    @State private var showFlash = false
    @State private var captureAnimation = false
    @State private var showGrid = false
    @State private var timerSeconds: Int? = nil
    @State private var timerCountdown: Int = 0
    @State private var isCountingDown = false
    var body: some View {
        ZStack {
            // Camera preview
            CameraPreview(camera: camera)
                .ignoresSafeArea()
                .onAppear {
                    camera.checkPermissions()
                }
            // Grid overlay
            if showGrid {
                gridOverlay
            }
            // UI Controls
            VStack {
                // Top bar
                topBar
                Spacer()
                // Bottom controls
                bottomControls
            }
            // Flash animation
            if showFlash {
                Color.white
                    .ignoresSafeArea()
                    .opacity(0.8)
                    .allowsHitTesting(false)
            }
            // Timer countdown
            if isCountingDown {
                timerCountdownView
            }
        }
        .background(Color.black)
    }
    @ViewBuilder
    private var topBar: some View {
        HStack {
            // Close button
            Button(action: {
                dismiss()
            }) {
                Image(systemName: "xmark")
                    .font(.title2)
                    .foregroundColor(.white)
                    .padding(12)
                    .background(Circle().fill(Color.black.opacity(0.5)))
            }
            Spacer()
            // Flash toggle
            Button(action: {
                camera.toggleFlash()
                OlasDesign.Haptic.selection()
            }) {
                Image(systemName: camera.flashMode.icon)
                    .font(.title2)
                    .foregroundColor(.white)
                    .padding(12)
                    .background(Circle().fill(Color.black.opacity(0.5)))
            }
            // Grid toggle
            Button(action: {
                showGrid.toggle()
                OlasDesign.Haptic.selection()
            }) {
                Image(systemName: showGrid ? "grid" : "grid.circle")
                    .font(.title2)
                    .foregroundColor(.white)
                    .padding(12)
                    .background(Circle().fill(Color.black.opacity(0.5)))
            }
            // Timer
            Menu {
                Button("Off") { timerSeconds = nil }
                Button("3s") { timerSeconds = 3 }
                Button("10s") { timerSeconds = 10 }
            } label: {
                Image(systemName: timerSeconds == nil ? "timer" : "timer.circle.fill")
                    .font(.title2)
                    .foregroundColor(.white)
                    .padding(12)
                    .background(Circle().fill(Color.black.opacity(0.5)))
            }
        }
        .padding(.horizontal)
        .padding(.top, 50)
    }
    @ViewBuilder
    private var bottomControls: some View {
        HStack(spacing: 60) {
            // Photo library
            Button(action: {
                // Placeholder for photo library
            }) {
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 50, height: 50)
                    .overlay(
                        Image(systemName: "photo")
                            .foregroundColor(.white)
                    )
            }
            // Capture button
            Button(action: capturePhoto) {
                ZStack {
                    Circle()
                        .strokeBorder(Color.white, lineWidth: 3)
                        .frame(width: 70, height: 70)
                    Circle()
                        .fill(Color.white)
                        .frame(width: 60, height: 60)
                        .scaleEffect(captureAnimation ? 0.8 : 1.0)
                }
            }
            .disabled(isCountingDown)
            // Camera flip
            Button(action: {
                camera.flipCamera()
                OlasDesign.Haptic.selection()
            }) {
                Image(systemName: "camera.rotate")
                    .font(.title2)
                    .foregroundColor(.white)
                    .frame(width: 50, height: 50)
                    .background(Circle().fill(Color.black.opacity(0.5)))
            }
        }
        .padding(.bottom, 30)
    }
    @ViewBuilder
    private var gridOverlay: some View {
        GeometryReader { geometry in
            Path { path in
                let width = geometry.size.width
                let height = geometry.size.height
                // Vertical lines
                path.move(to: CGPoint(x: width / 3, y: 0))
                path.addLine(to: CGPoint(x: width / 3, y: height))
                path.move(to: CGPoint(x: 2 * width / 3, y: 0))
                path.addLine(to: CGPoint(x: 2 * width / 3, y: height))
                // Horizontal lines
                path.move(to: CGPoint(x: 0, y: height / 3))
                path.addLine(to: CGPoint(x: width, y: height / 3))
                path.move(to: CGPoint(x: 0, y: 2 * height / 3))
                path.addLine(to: CGPoint(x: width, y: 2 * height / 3))
            }
            .stroke(Color.white.opacity(0.3), lineWidth: 1)
        }
        .ignoresSafeArea()
    }
    @ViewBuilder
    private var timerCountdownView: some View {
        Text("\(timerCountdown)")
            .font(.system(size: 120, weight: .bold, design: .rounded))
            .foregroundColor(.white)
            .shadow(radius: 10)
            .transition(.scale.combined(with: .opacity))
    }
    private func capturePhoto() {
        if let timer = timerSeconds {
            startTimer(seconds: timer)
        } else {
            performCapture()
        }
    }
    private func startTimer(seconds: Int) {
        isCountingDown = true
        timerCountdown = seconds
        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in
            if timerCountdown > 1 {
                timerCountdown -= 1
                OlasDesign.Haptic.impact(.light)
            } else {
                timer.invalidate()
                isCountingDown = false
                performCapture()
            }
        }
    }
    private func performCapture() {
        // Capture animation
        withAnimation(.easeInOut(duration: 0.1)) {
            captureAnimation = true
            showFlash = camera.flashMode != .off
        }
        OlasDesign.Haptic.impact(.medium)
        // Capture photo
        camera.capturePhoto { image in
            onCapture(image)
            dismiss()
        }
        // Reset animations
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            captureAnimation = false
            showFlash = false
        }
    }
}
// MARK: - Camera Model
class CameraModel: NSObject, ObservableObject {
    @Published var session = AVCaptureSession()
    @Published var flashMode: FlashMode = .auto
    @Published var isAuthorized = false
    @Published var isCameraReady = false
    private var photoOutput = AVCapturePhotoOutput()
    private var currentInput: AVCaptureDeviceInput?
    private var completionHandler: ((UIImage) -> Void)?
    enum FlashMode {
        case off, on, auto
        var icon: String {
            switch self {
            case .off: return "bolt.slash"
            case .on: return "bolt.fill"
            case .auto: return "bolt.badge.a"
            }
        }
        var avMode: AVCaptureDevice.FlashMode {
            switch self {
            case .off: return .off
            case .on: return .on
            case .auto: return .auto
            }
        }
    }
    override init() {
        super.init()
        setupSession()
    }
    func checkPermissions() {
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .authorized:
            isAuthorized = true
            startSession()
        case .notDetermined:
            AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in
                DispatchQueue.main.async {
                    self?.isAuthorized = granted
                    if granted {
                        self?.startSession()
                    }
                }
            }
        default:
            isAuthorized = false
        }
    }
    private func setupSession() {
        session.beginConfiguration()
        session.sessionPreset = .photo
        // Add video input
        guard let camera = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else { return }
        do {
            let input = try AVCaptureDeviceInput(device: camera)
            if session.canAddInput(input) {
                session.addInput(input)
                currentInput = input
            }
        } catch {
            print("Error setting up camera input: \(error)")
        }
        // Add photo output
        if session.canAddOutput(photoOutput) {
            session.addOutput(photoOutput)
            if #available(iOS 16.0, *) {
                // Use maxPhotoDimensions for iOS 16+
                if let format = camera.activeFormat.supportedMaxPhotoDimensions.first {
                    photoOutput.maxPhotoDimensions = format
                }
            } else {
                // Fallback for older iOS versions
                photoOutput.isHighResolutionCaptureEnabled = true
            }
        }
        session.commitConfiguration()
    }
    func startSession() {
        guard !session.isRunning else { return }
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            self?.session.startRunning()
            DispatchQueue.main.async {
                self?.isCameraReady = true
            }
        }
    }
    func stopSession() {
        guard session.isRunning else { return }
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            self?.session.stopRunning()
            DispatchQueue.main.async {
                self?.isCameraReady = false
            }
        }
    }
    func toggleFlash() {
        switch flashMode {
        case .off: flashMode = .on
        case .on: flashMode = .auto
        case .auto: flashMode = .off
        }
    }
    func flipCamera() {
        session.beginConfiguration()
        // Remove current input
        if let input = currentInput {
            session.removeInput(input)
        }
        // Get new camera
        let position: AVCaptureDevice.Position = currentInput?.device.position == .back ? .front : .back
        guard let camera = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: position) else {
            session.commitConfiguration()
            return
        }
        // Add new input
        do {
            let input = try AVCaptureDeviceInput(device: camera)
            if session.canAddInput(input) {
                session.addInput(input)
                currentInput = input
            }
        } catch {
            print("Error flipping camera: \(error)")
        }
        session.commitConfiguration()
    }
    func capturePhoto(completion: @escaping (UIImage) -> Void) {
        completionHandler = completion
        let settings = AVCapturePhotoSettings()
        settings.flashMode = flashMode.avMode
        photoOutput.capturePhoto(with: settings, delegate: self)
    }
}
// MARK: - AVCapturePhotoCaptureDelegate
extension CameraModel: AVCapturePhotoCaptureDelegate {
    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
        guard error == nil else {
            print("Error capturing photo: \(error!)")
            return
        }
        guard let imageData = photo.fileDataRepresentation(),
              let image = UIImage(data: imageData) else { return }
        // Apply orientation fix
        let fixedImage = image.fixedOrientation()
        DispatchQueue.main.async { [weak self] in
            self?.completionHandler?(fixedImage)
            self?.completionHandler = nil
        }
    }
}
// MARK: - Camera Preview
struct CameraPreview: UIViewRepresentable {
    @ObservedObject var camera: CameraModel
    func makeUIView(context: Context) -> UIView {
        let view = UIView(frame: UIScreen.main.bounds)
        let previewLayer = AVCaptureVideoPreviewLayer(session: camera.session)
        previewLayer.frame = view.frame
        previewLayer.videoGravity = .resizeAspectFill
        view.layer.addSublayer(previewLayer)
        return view
    }
    func updateUIView(_ uiView: UIView, context: Context) {
        if let previewLayer = uiView.layer.sublayers?.first as? AVCaptureVideoPreviewLayer {
            previewLayer.frame = uiView.bounds
        }
    }
}
// MARK: - UIImage Extension
extension UIImage {
    func fixedOrientation() -> UIImage {
        guard imageOrientation != .up else { return self }
        UIGraphicsBeginImageContextWithOptions(size, false, scale)
        draw(in: CGRect(origin: .zero, size: size))
        let normalizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return normalizedImage ?? self
    }
}
// MARK: - Preview
struct OlasCameraView_Previews: PreviewProvider {
    static var previews: some View {
        OlasCameraView { _ in }
    }
}
#else
// Placeholder for non-iOS platforms
struct OlasCameraView: View {
    let onCapture: (Any) -> Void
    var body: some View {
        Text("Camera not available on this platform")
    }
}
#endif
</file>

<file path="Olas/Views/Components/OlasCaptionComposer.swift">
import SwiftUI
import NDKSwift
#if canImport(UIKit)
import UIKit
#endif
struct OlasCaptionComposer: View {
    @Binding var caption: String
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var showMentions = false
    @State private var showHashtags = false
    @State private var currentWord = ""
    @State private var cursorPosition: Int = 0
    @State private var suggestedUsers: [NDKUser] = []
    @State private var suggestedProfiles: [String: NDKUserProfile] = [:]
    // Popular hashtags
    let popularHashtags = [
        "photography", "nostr", "art", "nature", "portrait",
        "streetphotography", "landscape", "blackandwhite", 
        "travel", "sunset", "architecture", "macro"
    ]
    var body: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            Text("Caption")
                .font(OlasDesign.Typography.bodyMedium)
                .foregroundColor(OlasDesign.Colors.text)
            // Caption input with custom editor
            ZStack(alignment: .topLeading) {
                // Background
                RoundedRectangle(cornerRadius: 12)
                    .fill(OlasDesign.Colors.surface)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(OlasDesign.Colors.border, lineWidth: 1)
                    )
                // Text editor
                CaptionTextEditor(
                    text: $caption,
                    onWordChange: handleWordChange
                )
                .scrollContentBackground(.hidden)
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.text)
                .padding(OlasDesign.Spacing.sm)
            }
            .frame(minHeight: 100)
            // Suggestions
            if showMentions && !suggestedUsers.isEmpty {
                mentionSuggestions
            } else if showHashtags {
                hashtagSuggestions
            }
        }
    }
    @ViewBuilder
    private var mentionSuggestions: some View {
        VStack(alignment: .leading, spacing: 0) {
            Text("Suggestions")
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textTertiary)
                .padding(.horizontal, OlasDesign.Spacing.sm)
                .padding(.vertical, OlasDesign.Spacing.xs)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: OlasDesign.Spacing.sm) {
                    ForEach(suggestedUsers.prefix(10), id: \.pubkey) { user in
                        Button(action: {
                            insertMention(user)
                            OlasDesign.Haptic.selection()
                        }) {
                            HStack(spacing: OlasDesign.Spacing.xs) {
                                // Avatar
                                if let profile = suggestedProfiles[user.pubkey] {
                                    OlasAvatar(
                                        url: profile.picture,
                                        size: 24,
                                        pubkey: user.pubkey
                                    )
                                } else {
                                    Circle()
                                        .fill(OlasDesign.Colors.surface)
                                        .frame(width: 24, height: 24)
                                }
                                // Name
                                VStack(alignment: .leading, spacing: 0) {
                                    if let profile = suggestedProfiles[user.pubkey] {
                                        Text(profile.displayName ?? profile.name ?? "Unknown")
                                            .font(OlasDesign.Typography.caption)
                                            .foregroundColor(OlasDesign.Colors.text)
                                        if let name = profile.name {
                                            Text("@\(name)")
                                                .font(.system(size: 10))
                                                .foregroundColor(OlasDesign.Colors.textTertiary)
                                        }
                                    } else {
                                        Text(user.npub.prefix(16) + "...")
                                            .font(OlasDesign.Typography.caption)
                                            .foregroundColor(OlasDesign.Colors.textSecondary)
                                    }
                                }
                            }
                            .padding(.horizontal, OlasDesign.Spacing.sm)
                            .padding(.vertical, OlasDesign.Spacing.xs)
                            .background(OlasDesign.Colors.surface)
                            .cornerRadius(16)
                            .overlay(
                                RoundedRectangle(cornerRadius: 16)
                                    .stroke(OlasDesign.Colors.border, lineWidth: 1)
                            )
                        }
                    }
                }
                .padding(.horizontal, OlasDesign.Spacing.sm)
            }
            .frame(height: 44)
            .task {
                await loadProfilesForSuggestions()
            }
        }
        .background(OlasDesign.Colors.surface.opacity(0.5))
        .cornerRadius(8)
    }
    @ViewBuilder
    private var hashtagSuggestions: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: OlasDesign.Spacing.sm) {
                ForEach(filteredHashtags, id: \.self) { tag in
                    Button(action: {
                        insertHashtag(tag)
                        OlasDesign.Haptic.selection()
                    }) {
                        Text("#\(tag)")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.primary)
                            .padding(.horizontal, OlasDesign.Spacing.sm)
                            .padding(.vertical, OlasDesign.Spacing.xs)
                            .background(OlasDesign.Colors.primary.opacity(0.1))
                            .cornerRadius(16)
                    }
                }
            }
        }
    }
    private var filteredHashtags: [String] {
        let searchTerm = currentWord.dropFirst() // Remove #
        if searchTerm.isEmpty {
            return popularHashtags
        }
        return popularHashtags.filter { $0.lowercased().contains(searchTerm.lowercased()) }
    }
    private func handleWordChange(_ word: String, position: Int) {
        currentWord = word
        cursorPosition = position
        if word.hasPrefix("@") && word.count > 1 {
            showMentions = true
            showHashtags = false
            searchUsers(String(word.dropFirst()))
        } else if word.hasPrefix("#") {
            showMentions = false
            showHashtags = true
        } else {
            showMentions = false
            showHashtags = false
        }
    }
    private func searchUsers(_ query: String) {
        guard let ndk = nostrManager.ndk else { return }
        Task {
            // Search for users by name/username
            let filter = NDKFilter(
                kinds: [EventKind.metadata],
                limit: 20
            )
            // For now, use empty array as we need to implement proper subscription
            // TODO: Implement proper subscription to fetch metadata events
            let events: [NDKEvent] = []
            var users: [NDKUser] = []
            // Implement proper metadata search when subscription API is available
            // For now, return empty list
            await MainActor.run {
                self.suggestedUsers = users
            }
        }
    }
    private func loadProfilesForSuggestions() async {
        guard let profileManager = nostrManager.ndk?.profileManager else { return }
        for user in suggestedUsers {
            if suggestedProfiles[user.pubkey] == nil {
                Task {
                    for await profile in await profileManager.observe(for: user.pubkey, maxAge: 3600) {
                        await MainActor.run {
                            suggestedProfiles[user.pubkey] = profile
                        }
                        break // Only need the first profile
                    }
                }
            }
        }
    }
    private func insertMention(_ user: NDKUser) {
        // Replace the current @mention with the full mention
        let beforeCursor = String(caption.prefix(cursorPosition - currentWord.count))
        let afterCursor = String(caption.suffix(caption.count - cursorPosition))
        let mention = "@\(user.npub) "
        caption = beforeCursor + mention + afterCursor
        showMentions = false
        currentWord = ""
    }
    private func insertHashtag(_ tag: String) {
        // Replace the current #word with the full hashtag
        let beforeCursor = String(caption.prefix(cursorPosition - currentWord.count))
        let afterCursor = String(caption.suffix(caption.count - cursorPosition))
        caption = beforeCursor + "#\(tag) " + afterCursor
        showHashtags = false
        currentWord = ""
    }
}
// MARK: - Custom Text Editor
#if canImport(UIKit)
struct CaptionTextEditor: UIViewRepresentable {
    @Binding var text: String
    let onWordChange: (String, Int) -> Void
    func makeUIView(context: Context) -> UITextView {
        let textView = UITextView()
        textView.delegate = context.coordinator
        textView.font = UIFont.preferredFont(forTextStyle: .body)
        textView.textColor = UIColor.label
        textView.backgroundColor = .clear
        textView.isScrollEnabled = true
        textView.keyboardType = .twitter
        textView.autocorrectionType = .no
        textView.text = text
        return textView
    }
    func updateUIView(_ uiView: UITextView, context: Context) {
        if uiView.text != text {
            uiView.text = text
        }
    }
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    class Coordinator: NSObject, UITextViewDelegate {
        let parent: CaptionTextEditor
        init(_ parent: CaptionTextEditor) {
            self.parent = parent
        }
        func textViewDidChange(_ textView: UITextView) {
            parent.text = textView.text
            // Get current word at cursor
            if let selectedRange = textView.selectedTextRange {
                let cursorPosition = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)
                // Find word boundaries
                let text = textView.text ?? ""
                let beforeCursor = String(text.prefix(cursorPosition))
                let words = beforeCursor.split(separator: " ", omittingEmptySubsequences: false)
                if let lastWord = words.last {
                    let word = String(lastWord)
                    if word.hasPrefix("@") || word.hasPrefix("#") {
                        parent.onWordChange(word, cursorPosition)
                    } else {
                        parent.onWordChange("", cursorPosition)
                    }
                }
            }
        }
    }
}
#else
// Placeholder for non-iOS platforms
struct CaptionTextEditor: View {
    @Binding var text: String
    let onWordChange: (String, Int) -> Void
    var body: some View {
        TextEditor(text: $text)
            .font(OlasDesign.Typography.body)
    }
}
#endif
// MARK: - Preview
struct OlasCaptionComposer_Previews: PreviewProvider {
    static var previews: some View {
        OlasCaptionComposer(caption: .constant(""))
            .environmentObject(AppState())
            .padding()
            .background(OlasDesign.Colors.background)
    }
}
</file>

<file path="Olas/Views/Components/OlasImageEditor.swift">
import SwiftUI
import CoreImage
import CoreImage.CIFilterBuiltins
#if canImport(UIKit)
import UIKit
#endif
#if canImport(UIKit)
struct OlasImageEditor: View {
    let originalImage: UIImage
    let currentFilter: String
    let onComplete: (UIImage, String) -> Void
    @Environment(\.dismiss) var dismiss
    @State private var selectedFilter = "No Filter"
    @State private var processedImage: UIImage?
    @State private var brightness: Double = 0
    @State private var contrast: Double = 1
    @State private var saturation: Double = 1
    @State private var rotation: Double = 0
    @State private var showAdjustments = false
    private let context = CIContext()
    // Filter definitions
    let filters = [
        "No Filter",
        "Olas Classic",
        "Neon Tokyo", 
        "Golden Hour",
        "Nordic Frost",
        "Vintage Film",
        "Black Pearl",
        "Coral Dream",
        "Electric Blue",
        "Autumn Maple",
        "Mint Fresh",
        "Purple Haze"
    ]
    var body: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: 0) {
                    // Image preview
                    GeometryReader { geometry in
                        Image(uiImage: processedImage ?? originalImage)
                            .resizable()
                            .scaledToFit()
                            .rotationEffect(.degrees(rotation))
                            .frame(width: geometry.size.width, height: geometry.size.height)
                            .clipped()
                    }
                    .background(OlasDesign.Colors.background)
                    // Controls
                    VStack(spacing: 0) {
                        // Tab selector
                        Picker("Edit Mode", selection: $showAdjustments) {
                            Text("Filters").tag(false)
                            Text("Adjust").tag(true)
                        }
                        .pickerStyle(.segmented)
                        .padding(OlasDesign.Spacing.md)
                        if showAdjustments {
                            adjustmentControls
                        } else {
                            filterSelector
                        }
                    }
                    .background(OlasDesign.Colors.surface)
                }
            }
            .navigationTitle("Edit Photo")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        onComplete(processedImage ?? originalImage, selectedFilter)
                        dismiss()
                    }
                    .fontWeight(.semibold)
                    .foregroundColor(OlasDesign.Colors.primary)
                }
            }
        }
        .onAppear {
            selectedFilter = currentFilter
            applyCurrentSettings()
        }
    }
    @ViewBuilder
    private var filterSelector: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: OlasDesign.Spacing.md) {
                ForEach(filters, id: \.self) { filter in
                    VStack(spacing: OlasDesign.Spacing.xs) {
                        // Filter preview thumbnail
                        if let thumbnail = generateThumbnail(for: filter) {
                            Image(uiImage: thumbnail)
                                .resizable()
                                .scaledToFill()
                                .frame(width: 80, height: 80)
                                .clipped()
                                .cornerRadius(8)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(
                                            selectedFilter == filter ? OlasDesign.Colors.primary : Color.clear,
                                            lineWidth: 3
                                        )
                                )
                        }
                        Text(filter)
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(
                                selectedFilter == filter ? OlasDesign.Colors.primary : OlasDesign.Colors.textSecondary
                            )
                    }
                    .onTapGesture {
                        selectedFilter = filter
                        applyCurrentSettings()
                        OlasDesign.Haptic.selection()
                    }
                }
            }
            .padding()
        }
    }
    @ViewBuilder
    private var adjustmentControls: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            // Brightness
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                HStack {
                    Image(systemName: "sun.max")
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Text("Brightness")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Spacer()
                    Text("\(Int(brightness * 100))")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Slider(value: $brightness, in: -1...1) { _ in
                    applyCurrentSettings()
                }
                .tint(OlasDesign.Colors.primary)
            }
            // Contrast
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                HStack {
                    Image(systemName: "circle.righthalf.filled")
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Text("Contrast")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Spacer()
                    Text("\(Int(contrast * 100))")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Slider(value: $contrast, in: 0.5...2) { _ in
                    applyCurrentSettings()
                }
                .tint(OlasDesign.Colors.primary)
            }
            // Saturation
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                HStack {
                    Image(systemName: "drop.fill")
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Text("Saturation")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Spacer()
                    Text("\(Int(saturation * 100))")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Slider(value: $saturation, in: 0...2) { _ in
                    applyCurrentSettings()
                }
                .tint(OlasDesign.Colors.primary)
            }
            // Rotation
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                HStack {
                    Image(systemName: "rotate.right")
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Text("Rotation")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Spacer()
                    Text("\(Int(rotation))")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                HStack(spacing: OlasDesign.Spacing.md) {
                    Button("-90") {
                        rotation -= 90
                        OlasDesign.Haptic.selection()
                    }
                    .buttonStyle(OlasSmallButtonStyle())
                    Slider(value: $rotation, in: -45...45) { _ in
                        // No need to apply settings on every change for rotation
                    }
                    .tint(OlasDesign.Colors.primary)
                    Button("+90") {
                        rotation += 90
                        OlasDesign.Haptic.selection()
                    }
                    .buttonStyle(OlasSmallButtonStyle())
                }
            }
            // Reset button
            Button("Reset All") {
                brightness = 0
                contrast = 1
                saturation = 1
                rotation = 0
                applyCurrentSettings()
                OlasDesign.Haptic.impact(.light)
            }
            .font(OlasDesign.Typography.caption)
            .foregroundColor(OlasDesign.Colors.warning)
        }
        .padding()
    }
    private func applyCurrentSettings() {
        Task {
            processedImage = await applyFilters()
        }
    }
    @MainActor
    private func applyFilters() async -> UIImage {
        guard let ciImage = CIImage(image: originalImage) else { return originalImage }
        var outputImage = ciImage
        // Apply selected filter
        if selectedFilter != "No Filter" {
            outputImage = applyFilter(selectedFilter, to: outputImage)
        }
        // Apply adjustments
        outputImage = applyAdjustments(to: outputImage)
        // Apply rotation
        if rotation != 0 {
            let radians = rotation * .pi / 180
            outputImage = outputImage.transformed(by: CGAffineTransform(rotationAngle: CGFloat(radians)))
        }
        // Render final image
        guard let cgImage = context.createCGImage(outputImage, from: outputImage.extent) else {
            return originalImage
        }
        return UIImage(cgImage: cgImage)
    }
    private func applyFilter(_ filterName: String, to image: CIImage) -> CIImage {
        switch filterName {
        case "Olas Classic":
            return applyOlasClassic(to: image)
        case "Neon Tokyo":
            return applyNeonTokyo(to: image)
        case "Golden Hour":
            return applyGoldenHour(to: image)
        case "Nordic Frost":
            return applyNordicFrost(to: image)
        case "Vintage Film":
            return applyVintageFilm(to: image)
        case "Black Pearl":
            return applyBlackPearl(to: image)
        case "Coral Dream":
            return applyCoralDream(to: image)
        case "Electric Blue":
            return applyElectricBlue(to: image)
        case "Autumn Maple":
            return applyAutumnMaple(to: image)
        case "Mint Fresh":
            return applyMintFresh(to: image)
        case "Purple Haze":
            return applyPurpleHaze(to: image)
        default:
            return image
        }
    }
    private func applyAdjustments(to image: CIImage) -> CIImage {
        var result = image
        // Brightness
        if brightness != 0 {
            let filter = CIFilter.colorControls()
            filter.inputImage = result
            filter.brightness = Float(brightness)
            result = filter.outputImage ?? result
        }
        // Contrast
        if contrast != 1 {
            let filter = CIFilter.colorControls()
            filter.inputImage = result
            filter.contrast = Float(contrast)
            result = filter.outputImage ?? result
        }
        // Saturation
        if saturation != 1 {
            let filter = CIFilter.colorControls()
            filter.inputImage = result
            filter.saturation = Float(saturation)
            result = filter.outputImage ?? result
        }
        return result
    }
    // MARK: - Filter Implementations
    private func applyOlasClassic(to image: CIImage) -> CIImage {
        // Subtle contrast boost with warmth
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = image
        colorControls.contrast = 1.1
        colorControls.saturation = 1.05
        colorControls.brightness = 0.02
        guard let adjusted = colorControls.outputImage else { return image }
        // Add slight warmth
        let tempAndTint = CIFilter.temperatureAndTint()
        tempAndTint.inputImage = adjusted
        tempAndTint.neutral = CIVector(x: 6500, y: 0)
        tempAndTint.targetNeutral = CIVector(x: 5500, y: 0)
        return tempAndTint.outputImage ?? adjusted
    }
    private func applyNeonTokyo(to image: CIImage) -> CIImage {
        // Cyberpunk-inspired with high contrast and cool tones
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = image
        colorControls.contrast = 1.3
        colorControls.saturation = 0.8
        colorControls.brightness = -0.05
        guard let adjusted = colorControls.outputImage else { return image }
        // Add blue/purple tone
        let colorMatrix = CIFilter.colorMatrix()
        colorMatrix.inputImage = adjusted
        colorMatrix.rVector = CIVector(x: 0.9, y: 0, z: 0, w: 0)
        colorMatrix.gVector = CIVector(x: 0, y: 0.9, z: 0, w: 0)
        colorMatrix.bVector = CIVector(x: 0.1, y: 0.1, z: 1.2, w: 0)
        return colorMatrix.outputImage ?? adjusted
    }
    private func applyGoldenHour(to image: CIImage) -> CIImage {
        // Warm highlights, cool shadows
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = image
        colorControls.contrast = 1.05
        colorControls.saturation = 1.1
        colorControls.brightness = 0.05
        guard let adjusted = colorControls.outputImage else { return image }
        // Add golden warmth
        let tempAndTint = CIFilter.temperatureAndTint()
        tempAndTint.inputImage = adjusted
        tempAndTint.neutral = CIVector(x: 6500, y: 0)
        tempAndTint.targetNeutral = CIVector(x: 4000, y: -10)
        return tempAndTint.outputImage ?? adjusted
    }
    private func applyNordicFrost(to image: CIImage) -> CIImage {
        // Desaturated with blue undertones
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = image
        colorControls.contrast = 0.95
        colorControls.saturation = 0.6
        colorControls.brightness = 0.1
        guard let adjusted = colorControls.outputImage else { return image }
        // Add cool tone
        let tempAndTint = CIFilter.temperatureAndTint()
        tempAndTint.inputImage = adjusted
        tempAndTint.neutral = CIVector(x: 6500, y: 0)
        tempAndTint.targetNeutral = CIVector(x: 8000, y: 10)
        return tempAndTint.outputImage ?? adjusted
    }
    private func applyVintageFilm(to image: CIImage) -> CIImage {
        // Film look with vignette
        let sepia = CIFilter.sepiaTone()
        sepia.inputImage = image
        sepia.intensity = 0.2
        guard let sepiaOutput = sepia.outputImage else { return image }
        // Add vignette
        let vignette = CIFilter.vignette()
        vignette.inputImage = sepiaOutput
        vignette.intensity = 0.8
        vignette.radius = 1.5
        guard let vignetted = vignette.outputImage else { return sepiaOutput }
        // Adjust colors
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = vignetted
        colorControls.contrast = 1.1
        colorControls.saturation = 0.9
        return colorControls.outputImage ?? vignetted
    }
    private func applyBlackPearl(to image: CIImage) -> CIImage {
        // Rich black and white
        let noir = CIFilter.photoEffectNoir()
        noir.inputImage = image
        guard let noirOutput = noir.outputImage else { return image }
        // Boost contrast
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = noirOutput
        colorControls.contrast = 1.2
        colorControls.brightness = -0.02
        return colorControls.outputImage ?? noirOutput
    }
    private func applyCoralDream(to image: CIImage) -> CIImage {
        // Peachy tones with soft highlights
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = image
        colorControls.contrast = 0.95
        colorControls.saturation = 1.15
        colorControls.brightness = 0.08
        guard let adjusted = colorControls.outputImage else { return image }
        // Add coral tint
        let colorMatrix = CIFilter.colorMatrix()
        colorMatrix.inputImage = adjusted
        colorMatrix.rVector = CIVector(x: 1.1, y: 0, z: 0, w: 0)
        colorMatrix.gVector = CIVector(x: 0, y: 0.95, z: 0, w: 0)
        colorMatrix.bVector = CIVector(x: 0, y: 0, z: 0.9, w: 0)
        return colorMatrix.outputImage ?? adjusted
    }
    private func applyElectricBlue(to image: CIImage) -> CIImage {
        // High contrast with blue accent
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = image
        colorControls.contrast = 1.25
        colorControls.saturation = 1.2
        colorControls.brightness = -0.03
        guard let adjusted = colorControls.outputImage else { return image }
        // Boost blues
        let colorMatrix = CIFilter.colorMatrix()
        colorMatrix.inputImage = adjusted
        colorMatrix.rVector = CIVector(x: 0.9, y: 0, z: 0, w: 0)
        colorMatrix.gVector = CIVector(x: 0, y: 0.95, z: 0, w: 0)
        colorMatrix.bVector = CIVector(x: 0, y: 0.1, z: 1.3, w: 0)
        return colorMatrix.outputImage ?? adjusted
    }
    private func applyAutumnMaple(to image: CIImage) -> CIImage {
        // Warm oranges and deep reds
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = image
        colorControls.contrast = 1.1
        colorControls.saturation = 1.2
        colorControls.brightness = 0.02
        guard let adjusted = colorControls.outputImage else { return image }
        // Add autumn colors
        let colorMatrix = CIFilter.colorMatrix()
        colorMatrix.inputImage = adjusted
        colorMatrix.rVector = CIVector(x: 1.2, y: 0, z: 0, w: 0)
        colorMatrix.gVector = CIVector(x: 0.1, y: 0.9, z: 0, w: 0)
        colorMatrix.bVector = CIVector(x: 0, y: 0, z: 0.8, w: 0)
        return colorMatrix.outputImage ?? adjusted
    }
    private func applyMintFresh(to image: CIImage) -> CIImage {
        // Cool greens with brightness
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = image
        colorControls.contrast = 1.05
        colorControls.saturation = 1.1
        colorControls.brightness = 0.1
        guard let adjusted = colorControls.outputImage else { return image }
        // Add mint tint
        let colorMatrix = CIFilter.colorMatrix()
        colorMatrix.inputImage = adjusted
        colorMatrix.rVector = CIVector(x: 0.9, y: 0, z: 0, w: 0)
        colorMatrix.gVector = CIVector(x: 0, y: 1.15, z: 0, w: 0)
        colorMatrix.bVector = CIVector(x: 0, y: 0.05, z: 1.05, w: 0)
        return colorMatrix.outputImage ?? adjusted
    }
    private func applyPurpleHaze(to image: CIImage) -> CIImage {
        // Moody purples with fade
        let colorControls = CIFilter.colorControls()
        colorControls.inputImage = image
        colorControls.contrast = 0.9
        colorControls.saturation = 0.95
        colorControls.brightness = 0.05
        guard let adjusted = colorControls.outputImage else { return image }
        // Add purple tint
        let colorMatrix = CIFilter.colorMatrix()
        colorMatrix.inputImage = adjusted
        colorMatrix.rVector = CIVector(x: 1.1, y: 0, z: 0.1, w: 0)
        colorMatrix.gVector = CIVector(x: 0, y: 0.9, z: 0, w: 0)
        colorMatrix.bVector = CIVector(x: 0.1, y: 0, z: 1.2, w: 0)
        guard let tinted = colorMatrix.outputImage else { return adjusted }
        // Add slight fade
        let exposure = CIFilter.exposureAdjust()
        exposure.inputImage = tinted
        exposure.ev = 0.15
        return exposure.outputImage ?? tinted
    }
    private func generateThumbnail(for filterName: String) -> UIImage? {
        // Create smaller version for performance
        let size = CGSize(width: 160, height: 160)
        UIGraphicsBeginImageContextWithOptions(size, false, 1.0)
        originalImage.draw(in: CGRect(origin: .zero, size: size))
        guard let thumbnailImage = UIGraphicsGetImageFromCurrentImageContext() else { return nil }
        UIGraphicsEndImageContext()
        // Apply filter to thumbnail
        guard let ciImage = CIImage(image: thumbnailImage) else { return nil }
        let filteredImage = applyFilter(filterName, to: ciImage)
        guard let cgImage = context.createCGImage(filteredImage, from: filteredImage.extent) else {
            return nil
        }
        return UIImage(cgImage: cgImage)
    }
}
// MARK: - Button Style
struct OlasSmallButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(OlasDesign.Typography.caption)
            .foregroundColor(OlasDesign.Colors.primary)
            .padding(.horizontal, OlasDesign.Spacing.sm)
            .padding(.vertical, OlasDesign.Spacing.xs)
            .background(OlasDesign.Colors.primary.opacity(0.1))
            .cornerRadius(6)
            .scaleEffect(configuration.isPressed ? 0.95 : 1)
    }
}
// MARK: - Preview
struct OlasImageEditor_Previews: PreviewProvider {
    static var previews: some View {
        if let image = UIImage(systemName: "photo") {
            OlasImageEditor(
                originalImage: image,
                currentFilter: "No Filter"
            ) { _, _ in }
        }
    }
}
#else
// Placeholder for non-iOS platforms
struct OlasImageEditor: View {
    let originalImage: Any
    let currentFilter: String
    let onComplete: (Any, String) -> Void
    var body: some View {
        Text("Image editor not available on this platform")
    }
}
#endif
</file>

<file path="Olas/Views/Components/OlasMultiImageView.swift">
import SwiftUI
// MARK: - Multi-Image Layout Component
struct OlasMultiImageView: View {
    let imageURLs: [String]
    let blurhashes: [String]
    @State private var loadedImages: [String: Image] = [:]
    @State private var failedImages: Set<String> = []
    init(imageURLs: [String], blurhashes: [String] = []) {
        self.imageURLs = imageURLs
        self.blurhashes = blurhashes.isEmpty ? Array(repeating: "", count: imageURLs.count) : blurhashes
    }
    var body: some View {
        GeometryReader { geometry in
            let width = geometry.size.width
            switch imageURLs.count {
            case 1:
                singleImageLayout(width: width)
            case 2:
                doubleImageLayout(width: width)
            case 3:
                tripleImageLayout(width: width)
            case 4...:
                quadImageLayout(width: width)
            default:
                EmptyView()
            }
        }
        .aspectRatio(4/5, contentMode: .fit)
        .background(OlasDesign.Colors.background)
    }
    // MARK: - Layout Components
    @ViewBuilder
    private func singleImageLayout(width: CGFloat) -> some View {
        imageView(for: imageURLs[0], aspectRatio: 4/5)
    }
    @ViewBuilder
    private func doubleImageLayout(width: CGFloat) -> some View {
        HStack(spacing: 1) {
            imageView(for: imageURLs[0], aspectRatio: 8/9)
            imageView(for: imageURLs[1], aspectRatio: 8/9)
        }
    }
    @ViewBuilder
    private func tripleImageLayout(width: CGFloat) -> some View {
        HStack(spacing: 1) {
            // Hero image on left (8:9)
            imageView(for: imageURLs[0], aspectRatio: 8/9)
                .frame(width: width * 0.6)
            // Two stacked images on right (1:1)
            VStack(spacing: 1) {
                imageView(for: imageURLs[1], aspectRatio: 1)
                imageView(for: imageURLs[2], aspectRatio: 1)
            }
            .frame(width: width * 0.4 - 1)
        }
    }
    @ViewBuilder
    private func quadImageLayout(width: CGFloat) -> some View {
        VStack(spacing: 1) {
            HStack(spacing: 1) {
                imageView(for: imageURLs[0], aspectRatio: 1)
                imageView(for: imageURLs[1], aspectRatio: 1)
            }
            HStack(spacing: 1) {
                imageView(for: imageURLs[2], aspectRatio: 1)
                if imageURLs.count > 3 {
                    ZStack {
                        imageView(for: imageURLs[3], aspectRatio: 1)
                        // Show +N overlay for additional images
                        if imageURLs.count > 4 {
                            Rectangle()
                                .fill(Color.black.opacity(0.6))
                                .overlay(
                                    Text("+\(imageURLs.count - 4)")
                                        .font(OlasDesign.Typography.title)
                                        .foregroundColor(.white)
                                        .olasTextShadow()
                                )
                        }
                    }
                } else {
                    imageView(for: imageURLs[2], aspectRatio: 1)
                }
            }
        }
    }
    // MARK: - Image View Builder
    @ViewBuilder
    private func imageView(for urlString: String, aspectRatio: CGFloat) -> some View {
        if let index = imageURLs.firstIndex(of: urlString) {
            let blurhash = index < blurhashes.count ? blurhashes[index] : nil
            OlasProgressiveImage(
                imageURL: urlString,
                blurhash: blurhash?.isEmpty == false ? blurhash : nil
            )
            .aspectRatio(aspectRatio, contentMode: .fill)
            .clipped()
        }
    }
}
// MARK: - Image Interaction Overlay
struct OlasImageInteractionOverlay: View {
    let imageURLs: [String]
    @State private var currentIndex: Int = 0
    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @State private var lastOffset: CGSize = .zero
    @Binding var isPresented: Bool
    @State private var dragOffset: CGSize = .zero
    @State private var opacity: Double = 1.0
    var body: some View {
        ZStack {
            backgroundView
            imageViewer
            closeButton
        }
    }
    @ViewBuilder
    private var backgroundView: some View {
        Color.black
            .opacity(opacity)
            .ignoresSafeArea()
            .onTapGesture {
                withAnimation(OlasDesign.Animation.spring) {
                    isPresented = false
                }
            }
    }
    @ViewBuilder
    private var imageViewer: some View {
        TabView(selection: $currentIndex) {
            ForEach(imageURLs.indices, id: \.self) { index in
                imageView(at: index)
                    .tag(index)
            }
        }
        #if os(iOS)
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: imageURLs.count > 1 ? .always : .never))
        #endif
        .offset(dragOffset)
    }
    @ViewBuilder
    private func imageView(at index: Int) -> some View {
        AsyncImage(url: URL(string: imageURLs[index])) { phase in
            switch phase {
            case .success(let image):
                zoomableImage(image)
            case .failure(_):
                failureView
            case .empty:
                loadingView
            @unknown default:
                EmptyView()
            }
        }
    }
    @ViewBuilder
    private func zoomableImage(_ image: Image) -> some View {
        image
            .resizable()
            .aspectRatio(contentMode: .fit)
            .scaleEffect(scale)
            .offset(offset)
            .gesture(zoomGesture)
            .onTapGesture(count: 2) {
                toggleZoom()
            }
    }
    private var zoomGesture: some Gesture {
        MagnificationGesture()
            .onChanged { value in
                scale = lastScale * value
            }
            .onEnded { value in
                handleZoomEnd()
            }
            .simultaneously(with: dragGesture)
    }
    private var dragGesture: some Gesture {
        DragGesture()
            .onChanged { value in
                handleDrag(value: value)
            }
            .onEnded { value in
                handleDragEnd(value: value)
            }
    }
    private func handleZoomEnd() {
        lastScale = scale
        withAnimation(OlasDesign.Animation.spring) {
            if scale < 1 {
                scale = 1
                lastScale = 1
                offset = .zero
                lastOffset = .zero
            } else if scale > 4 {
                scale = 4
                lastScale = 4
            }
        }
    }
    private func handleDrag(value: DragGesture.Value) {
        if scale > 1 {
            offset = CGSize(
                width: lastOffset.width + value.translation.width,
                height: lastOffset.height + value.translation.height
            )
        } else {
            dragOffset = value.translation
            let progress = abs(value.translation.height) / 200
            opacity = 1 - min(progress, 0.5)
        }
    }
    private func handleDragEnd(value: DragGesture.Value) {
        if scale > 1 {
            lastOffset = offset
        } else {
            if abs(value.translation.height) > 100 {
                withAnimation(OlasDesign.Animation.spring) {
                    isPresented = false
                }
            } else {
                withAnimation(OlasDesign.Animation.spring) {
                    dragOffset = .zero
                    opacity = 1
                }
            }
        }
    }
    private func toggleZoom() {
        withAnimation(OlasDesign.Animation.spring) {
            if scale > 1 {
                scale = 1
                lastScale = 1
                offset = .zero
                lastOffset = .zero
            } else {
                scale = 2
                lastScale = 2
            }
        }
        #if os(iOS)
        OlasDesign.Haptic.impact(.light)
        #else
        OlasDesign.Haptic.impact(0)
        #endif
    }
    @ViewBuilder
    private var failureView: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 50))
                .foregroundColor(OlasDesign.Colors.textTertiary)
            Text("Failed to load image")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
    }
    @ViewBuilder
    private var loadingView: some View {
        ProgressView()
            .progressViewStyle(CircularProgressViewStyle(tint: .white))
            .scaleEffect(1.5)
    }
    @ViewBuilder
    private var closeButton: some View {
        VStack {
            HStack {
                Spacer()
                Button(action: {
                    withAnimation(OlasDesign.Animation.spring) {
                        isPresented = false
                    }
                    OlasDesign.Haptic.selection()
                }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title)
                        .foregroundStyle(.white, Color.white.opacity(0.2))
                        .background(Circle().fill(.ultraThinMaterial))
                }
                .padding(OlasDesign.Spacing.lg)
            }
            Spacer()
        }
    }
}
// MARK: - Preview
struct OlasMultiImageView_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            OlasMultiImageView(imageURLs: ["https://example.com/1.jpg"])
                .frame(height: 400)
            OlasMultiImageView(imageURLs: ["https://example.com/1.jpg", "https://example.com/2.jpg"])
                .frame(height: 400)
            OlasMultiImageView(imageURLs: ["https://example.com/1.jpg", "https://example.com/2.jpg", "https://example.com/3.jpg"])
                .frame(height: 400)
            OlasMultiImageView(imageURLs: ["https://example.com/1.jpg", "https://example.com/2.jpg", "https://example.com/3.jpg", "https://example.com/4.jpg", "https://example.com/5.jpg"])
                .frame(height: 400)
        }
        .padding()
        .background(OlasDesign.Colors.background)
    }
}
</file>

<file path="Olas/Views/Components/OlasRichText.swift">
import SwiftUI
import NDKSwift
// MARK: - Rich Text Component
struct OlasRichText: View {
    let content: String
    let tags: [[String]]
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var parsedComponents: [RichTextComponent] = []
    @State private var profileCache: [String: NDKUserProfile] = [:]
    @State private var loadingProfiles: Set<String> = []
    var body: some View {
        Text(attributedString)
            .font(OlasDesign.Typography.body)
            .foregroundColor(OlasDesign.Colors.text)
            .tint(Color.white)
            .task {
                parseContent()
                await loadProfiles()
            }
            .onChange(of: content) { _, _ in
                parseContent()
                Task {
                    await loadProfiles()
                }
            }
    }
    private var attributedString: AttributedString {
        var result = AttributedString()
        for component in parsedComponents {
            switch component {
            case .text(let text):
                result.append(AttributedString(text))
            case .mention(let pubkey):
                let displayName = profileCache[pubkey]?.displayName ?? profileCache[pubkey]?.name ?? shortPubkey(pubkey)
                var mention = AttributedString("@\(displayName)")
                mention.foregroundColor = .white
                mention.font = OlasDesign.Typography.bodyMedium
                mention.link = URL(string: "olas://profile/\(pubkey)")
                mention.underlineStyle = .single
                #if os(iOS)
                mention.underlineColor = UIColor.white.withAlphaComponent(0.3)
                #else
                mention.underlineColor = NSColor.white.withAlphaComponent(0.3)
                #endif
                result.append(mention)
            case .hashtag(let tag):
                var hashtag = AttributedString("#\(tag)")
                hashtag.foregroundColor = .white
                hashtag.font = OlasDesign.Typography.bodyMedium
                hashtag.link = URL(string: "olas://hashtag/\(tag)")
                hashtag.underlineStyle = .single
                #if os(iOS)
                hashtag.underlineColor = UIColor.white.withAlphaComponent(0.3)
                #else
                hashtag.underlineColor = NSColor.white.withAlphaComponent(0.3)
                #endif
                result.append(hashtag)
            case .link(let url):
                var link = AttributedString(url)
                link.foregroundColor = .white.opacity(0.8)
                link.font = OlasDesign.Typography.body
                link.link = URL(string: url)
                link.underlineStyle = .single
                #if os(iOS)
                link.underlineColor = UIColor.white.withAlphaComponent(0.3)
                #else
                link.underlineColor = NSColor.white.withAlphaComponent(0.3)
                #endif
                result.append(link)
            case .noteReference(let noteId):
                var reference = AttributedString(" Note")
                reference.foregroundColor = .white.opacity(0.8)
                reference.font = OlasDesign.Typography.body
                reference.link = URL(string: "olas://note/\(noteId)")
                reference.underlineStyle = .single
                #if os(iOS)
                reference.underlineColor = UIColor.white.withAlphaComponent(0.3)
                #else
                reference.underlineColor = NSColor.white.withAlphaComponent(0.3)
                #endif
                result.append(reference)
            }
        }
        return result
    }
    private func parseContent() {
        let currentText = content
        // Create a map of replacements with their positions
        var replacements: [(range: Range<String.Index>, component: RichTextComponent)] = []
        // Find all mentions from tags
        for tag in tags {
            if tag.count >= 2 && tag[0] == "p" {
                let pubkey = tag[1]
                let mentionIndex = tag.count > 2 ? Int(tag[2]) : nil
                // Find nostr: mentions
                let nostrPattern = "nostr:npub1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}"
                if let regex = try? NSRegularExpression(pattern: nostrPattern) {
                    let matches = regex.matches(in: currentText, range: NSRange(currentText.startIndex..., in: currentText))
                    for match in matches {
                        if let range = Range(match.range, in: currentText) {
                            let npubFull = String(currentText[range])
                            let npub = npubFull.replacingOccurrences(of: "nostr:", with: "")
                            if let decoded = try? Bech32.decode(npub) {
                                let decodedPubkey = Data(decoded.data).hexString
                                if decodedPubkey == pubkey {
                                    replacements.append((range, .mention(pubkey)))
                                }
                            }
                        }
                    }
                }
                // Find #[index] mentions
                if let index = mentionIndex {
                    let indexPattern = "#\\[\(index)\\]"
                    if let regex = try? NSRegularExpression(pattern: indexPattern) {
                        let matches = regex.matches(in: currentText, range: NSRange(currentText.startIndex..., in: currentText))
                        for match in matches {
                            if let range = Range(match.range, in: currentText) {
                                replacements.append((range, .mention(pubkey)))
                            }
                        }
                    }
                }
            }
        }
        // Find hashtags
        let hashtagPattern = "#[a-zA-Z0-9_]+"
        if let regex = try? NSRegularExpression(pattern: hashtagPattern) {
            let matches = regex.matches(in: currentText, range: NSRange(currentText.startIndex..., in: currentText))
            for match in matches {
                if let range = Range(match.range, in: currentText) {
                    let hashtag = String(currentText[range]).dropFirst() // Remove #
                    replacements.append((range, .hashtag(String(hashtag))))
                }
            }
        }
        // Find URLs
        let urlPattern = "https?://[^\\s]+"
        if let regex = try? NSRegularExpression(pattern: urlPattern) {
            let matches = regex.matches(in: currentText, range: NSRange(currentText.startIndex..., in: currentText))
            for match in matches {
                if let range = Range(match.range, in: currentText) {
                    let url = String(currentText[range])
                    replacements.append((range, .link(url)))
                }
            }
        }
        // Find note references
        let notePattern = "nostr:note1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}"
        if let regex = try? NSRegularExpression(pattern: notePattern) {
            let matches = regex.matches(in: currentText, range: NSRange(currentText.startIndex..., in: currentText))
            for match in matches {
                if let range = Range(match.range, in: currentText) {
                    let noteFull = String(currentText[range])
                    let note = noteFull.replacingOccurrences(of: "nostr:", with: "")
                    if let decoded = try? Bech32.decode(note) {
                        let noteId = Data(decoded.data).hexString
                        replacements.append((range, .noteReference(noteId)))
                    }
                }
            }
        }
        // Sort replacements by position (reverse order for replacement)
        replacements.sort { $0.range.lowerBound > $1.range.lowerBound }
        // Build components
        var workingText = currentText
        var finalComponents: [RichTextComponent] = []
        for replacement in replacements {
            // Add text after this replacement
            let afterText = String(workingText[replacement.range.upperBound...])
            if !afterText.isEmpty {
                finalComponents.insert(.text(afterText), at: 0)
            }
            // Add the replacement component
            finalComponents.insert(replacement.component, at: 0)
            // Update working text
            workingText = String(workingText[..<replacement.range.lowerBound])
        }
        // Add any remaining text
        if !workingText.isEmpty {
            finalComponents.insert(.text(workingText), at: 0)
        }
        parsedComponents = finalComponents
    }
    private func loadProfiles() async {
        guard let profileManager = nostrManager.ndk?.profileManager else { return }
        // Find all unique pubkeys that need loading
        let pubkeysToLoad = parsedComponents.compactMap { component -> String? in
            if case .mention(let pubkey) = component,
               profileCache[pubkey] == nil,
               !loadingProfiles.contains(pubkey) {
                return pubkey
            }
            return nil
        }
        // Mark as loading
        await MainActor.run {
            pubkeysToLoad.forEach { loadingProfiles.insert($0) }
        }
        // Load profiles
        await withTaskGroup(of: (String, NDKUserProfile?).self) { group in
            for pubkey in pubkeysToLoad {
                group.addTask {
                    // Use observe to get reactive updates
                    var profile: NDKUserProfile?
                    for await p in await profileManager.observe(for: pubkey, maxAge: 3600) {
                        profile = p
                        break // Just get the first one for now
                    }
                    return (pubkey, profile)
                }
            }
            // Collect results
            for await (pubkey, profile) in group {
                await MainActor.run {
                    if let profile = profile {
                        profileCache[pubkey] = profile
                    }
                    loadingProfiles.remove(pubkey)
                }
            }
        }
    }
    private func shortPubkey(_ pubkey: String) -> String {
        if pubkey.count > 8 {
            return "\(pubkey.prefix(4))...\(pubkey.suffix(4))"
        }
        return pubkey
    }
}
// MARK: - Rich Text Component Types
private enum RichTextComponent: Hashable {
    case text(String)
    case mention(String) // pubkey
    case hashtag(String)
    case link(String)
    case noteReference(String) // note id
}
// MARK: - Preview Helper
struct OlasRichText_Previews: PreviewProvider {
    static var previews: some View {
        VStack(alignment: .leading, spacing: 20) {
            OlasRichText(
                content: "Hello nostr:npub1234567890abcdef! Check out #nostr and visit https://nostr.com",
                tags: [["p", "1234567890abcdef"]]
            )
            OlasRichText(
                content: "Reply to #[0] about #photography with note reference nostr:note1234567890abcdef",
                tags: [["p", "abcdef1234567890", "0"]]
            )
        }
        .padding()
        .background(OlasDesign.Colors.background)
        .environmentObject(AppState())
    }
}
</file>

<file path="Olas/Views/Components/ReplyView.swift">
import SwiftUI
import NDKSwift
struct ReplyView: View {
    let parentEvent: NDKEvent
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @StateObject private var viewModel = ReplyViewModel()
    @State private var replyText = ""
    @State private var isReplying = false
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Parent post context
                ScrollView {
                    VStack(alignment: .leading, spacing: 0) {
                        // Parent post header
                        ParentPostHeader(event: parentEvent, profile: viewModel.parentProfile)
                            .padding(OlasDesign.Spacing.md)
                            .background(OlasDesign.Colors.surface)
                        Divider()
                            .background(OlasDesign.Colors.border)
                        // Replies list
                        if viewModel.replies.isEmpty && !viewModel.isLoading {
                            EmptyRepliesView()
                                .padding(.vertical, OlasDesign.Spacing.xl)
                        } else {
                            LazyVStack(spacing: 0) {
                                ForEach(viewModel.replies) { reply in
                                    ReplyItemView(reply: reply)
                                    if reply.id != viewModel.replies.last?.id {
                                        Divider()
                                            .background(OlasDesign.Colors.border)
                                            .padding(.leading, 60)
                                    }
                                }
                            }
                        }
                        if viewModel.isLoading {
                            ProgressView()
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, OlasDesign.Spacing.xl)
                        }
                    }
                }
                // Reply input
                VStack(spacing: 0) {
                    Divider()
                        .background(OlasDesign.Colors.border)
                    HStack(alignment: .bottom, spacing: OlasDesign.Spacing.sm) {
                        // User avatar
                        if let currentUser = nostrManager.currentUserProfile {
                            OlasAvatar(
                                url: currentUser.picture,
                                size: 32,
                                pubkey: nostrManager.authManager.activeSession?.pubkey ?? ""
                            )
                        }
                        // Reply field
                        VStack(alignment: .leading, spacing: 4) {
                            if isReplying {
                                Text("Replying to @\(viewModel.parentProfile?.name ?? "...")")
                                    .font(OlasDesign.Typography.caption)
                                    .foregroundColor(OlasDesign.Colors.textSecondary)
                            }
                            HStack(alignment: .bottom) {
                                TextField("Add a reply...", text: $replyText, axis: .vertical)
                                    .textFieldStyle(PlainTextFieldStyle())
                                    .font(OlasDesign.Typography.body)
                                    .foregroundColor(OlasDesign.Colors.text)
                                    .lineLimit(1...5)
                                    .onSubmit {
                                        if !replyText.isEmpty {
                                            sendReply()
                                        }
                                    }
                                if !replyText.isEmpty {
                                    Button(action: sendReply) {
                                        Image(systemName: "arrow.up.circle.fill")
                                            .font(.title2)
                                            .foregroundStyle(
                                                LinearGradient(
                                                    colors: [OlasDesign.Colors.primary, OlasDesign.Colors.secondary],
                                                    startPoint: .topLeading,
                                                    endPoint: .bottomTrailing
                                                )
                                            )
                                    }
                                    .disabled(isReplying)
                                }
                            }
                        }
                        .padding(.horizontal, OlasDesign.Spacing.sm)
                        .padding(.vertical, OlasDesign.Spacing.xs)
                        .background(OlasDesign.Colors.surface)
                        .cornerRadius(20)
                    }
                    .padding(OlasDesign.Spacing.md)
                }
                .background(OlasDesign.Colors.background)
            }
            .background(OlasDesign.Colors.background)
            .navigationTitle("Replies")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            #if os(iOS)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            #else
            .toolbar {
                ToolbarItem(placement: .automatic) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            #endif
            .onAppear {
                if let ndk = nostrManager.ndk {
                    viewModel.loadReplies(for: parentEvent, ndk: ndk)
                }
            }
        }
    }
    private func sendReply() {
        guard let ndk = nostrManager.ndk,
              let signer = NDKAuthManager.shared.activeSigner,
              !replyText.isEmpty else { return }
        isReplying = true
        OlasDesign.Haptic.selection()
        Task { @MainActor in
            do {
                // Use NDK's built-in reply() method which handles NIP-22 automatically
                let reply = try await NDKEventBuilder.reply(to: parentEvent, ndk: ndk)
                    .content(replyText)
                    .build(signer: signer)
                _ = try await ndk.publish(reply)
                await MainActor.run {
                    replyText = ""
                    isReplying = false
                    OlasDesign.Haptic.success()
                }
            } catch {
                print("Error sending reply: \(error)")
                await MainActor.run {
                    isReplying = false
                    OlasDesign.Haptic.error()
                }
            }
        }
    }
}
struct ParentPostHeader: View {
    let event: NDKEvent
    let profile: NDKUserProfile?
    var body: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            HStack(spacing: OlasDesign.Spacing.sm) {
                OlasAvatar(
                    url: profile?.picture,
                    size: 40,
                    pubkey: event.pubkey
                )
                VStack(alignment: .leading, spacing: 2) {
                    Text(profile?.displayName ?? profile?.name ?? "Loading...")
                        .font(OlasDesign.Typography.bodyMedium)
                        .foregroundColor(OlasDesign.Colors.text)
                    Text("@\(profile?.name ?? String(event.pubkey.prefix(8)))")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Spacer()
                Text(formatTimestamp(event.createdAt))
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textTertiary)
            }
            OlasRichText(
                content: event.content,
                tags: event.tags
            )
        }
    }
    private func formatTimestamp(_ timestamp: Timestamp) -> String {
        let date = Date(timeIntervalSince1970: TimeInterval(timestamp))
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}
struct ReplyItemView: View {
    let reply: ReplyItem
    @EnvironmentObject var appState: AppState
    @State private var showingNestedReplies = false
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            HStack(alignment: .top, spacing: OlasDesign.Spacing.sm) {
                OlasAvatar(
                    url: reply.profile?.picture,
                    size: 32,
                    pubkey: reply.event.pubkey
                )
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                    HStack(spacing: OlasDesign.Spacing.xs) {
                        Text(reply.profile?.displayName ?? reply.profile?.name ?? "Loading...")
                            .font(OlasDesign.Typography.bodyMedium)
                            .foregroundColor(OlasDesign.Colors.text)
                        Text("@\(reply.profile?.name ?? String(reply.event.pubkey.prefix(8)))")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                        Text("")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textTertiary)
                        Text(formatTimestamp(reply.event.createdAt))
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textTertiary)
                        Spacer()
                    }
                    OlasRichText(
                        content: reply.event.content,
                        tags: reply.event.tags
                    )
                    .fixedSize(horizontal: false, vertical: true)
                    // Reply actions
                    HStack(spacing: OlasDesign.Spacing.lg) {
                        Button(action: {
                            showingNestedReplies.toggle()
                            OlasDesign.Haptic.selection()
                        }) {
                            HStack(spacing: 4) {
                                Image(systemName: "bubble.left")
                                    .font(.caption)
                                if reply.replyCount > 0 {
                                    Text("\(reply.replyCount)")
                                        .font(OlasDesign.Typography.caption)
                                }
                            }
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                        }
                        Spacer()
                    }
                    .padding(.top, OlasDesign.Spacing.xs)
                }
            }
            .padding(OlasDesign.Spacing.md)
            if showingNestedReplies && reply.replyCount > 0 {
                // TODO: Show nested replies
                Text("Nested replies coming soon...")
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textTertiary)
                    .padding(.leading, 60)
                    .padding(.bottom, OlasDesign.Spacing.sm)
            }
        }
    }
    private func formatTimestamp(_ timestamp: Timestamp) -> String {
        let date = Date(timeIntervalSince1970: TimeInterval(timestamp))
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}
struct EmptyRepliesView: View {
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            Image(systemName: "bubble.left.and.bubble.right")
                .font(.system(size: 48))
                .foregroundColor(OlasDesign.Colors.textTertiary)
            Text("No replies yet")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.textSecondary)
            Text("Be the first to reply!")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
        .frame(maxWidth: .infinity)
    }
}
@MainActor
class ReplyViewModel: ObservableObject {
    @Published var replies: [ReplyItem] = []
    @Published var parentProfile: NDKUserProfile?
    @Published var isLoading = false
    private var profileTasks: [String: Task<Void, Never>] = [:]
    func loadReplies(for event: NDKEvent, ndk: NDK) {
        isLoading = true
        Task {
            // Load parent profile
            if let profileManager = ndk.profileManager {
                for await profile in await profileManager.observe(for: event.pubkey, maxAge: 3600) {
                    if let profile = profile {
                        await MainActor.run {
                            self.parentProfile = profile
                        }
                        break
                    }
                }
            }
            // Load comments (NIP-22)
            let filter = NDKFilter(
                kinds: [EventKind.genericReply],
                tags: [
                    "E": Set([event.id]),  // Comments on this root event
                    "e": Set([event.id])   // Or direct parent references
                ]
            )
            let dataSource = ndk.observe(filter: filter, cachePolicy: .cacheWithNetwork)
            for await replyEvent in dataSource.events {
                // Check if this is a direct reply to our event (NIP-22)
                let isDirectReply = replyEvent.tags.contains { tag in
                    tag.count >= 2 && tag[0] == "e" && tag[1] == event.id
                } && replyEvent.tags.contains { tag in
                    tag.count >= 2 && tag[0] == "k" && (tag[1] == String(EventKind.image) || tag[1] == String(EventKind.genericReply))
                }
                if isDirectReply {
                    let replyItem = ReplyItem(event: replyEvent)
                    await MainActor.run {
                        if !replies.contains(where: { $0.id == replyItem.id }) {
                            replies.append(replyItem)
                            replies.sort { $0.event.createdAt < $1.event.createdAt }
                        }
                        isLoading = false
                    }
                    // Load profile for reply author
                    loadProfileReactively(for: replyEvent.pubkey, ndk: ndk)
                    // Count nested replies
                    countNestedReplies(for: replyEvent, ndk: ndk)
                }
            }
            await MainActor.run {
                isLoading = false
            }
        }
    }
    private func loadProfileReactively(for pubkey: String, ndk: NDK) {
        profileTasks[pubkey]?.cancel()
        profileTasks[pubkey] = Task {
            guard let profileManager = ndk.profileManager else { return }
            for await profile in await profileManager.observe(for: pubkey, maxAge: 3600) {
                if let profile = profile {
                    await MainActor.run {
                        updateRepliesWithProfile(pubkey: pubkey, profile: profile)
                    }
                }
            }
        }
    }
    private func updateRepliesWithProfile(pubkey: String, profile: NDKUserProfile) {
        for index in replies.indices {
            if replies[index].event.pubkey == pubkey {
                replies[index].profile = profile
            }
        }
    }
    private func countNestedReplies(for event: NDKEvent, ndk: NDK) {
        Task {
            // Count nested comments (NIP-22)
            let filter = NDKFilter(
                kinds: [EventKind.genericReply],
                tags: [
                    "e": Set([event.id])  // Comments with this as parent
                ]
            )
            let dataSource = ndk.observe(filter: filter, cachePolicy: .cacheOnly)
            let nestedReplies = await dataSource.collect(timeout: 1.0)
            let count = nestedReplies.filter { reply in
                reply.tags.contains { tag in
                    tag.count >= 2 && tag[0] == "e" && tag[1] == event.id
                } && reply.tags.contains { tag in
                    tag.count >= 2 && tag[0] == "k" && tag[1] == String(EventKind.genericReply)
                }
            }.count
            await MainActor.run {
                if let index = replies.firstIndex(where: { $0.id == event.id }) {
                    replies[index].replyCount = count
                }
            }
        }
    }
}
struct ReplyItem: Identifiable {
    let id: String
    let event: NDKEvent
    var profile: NDKUserProfile?
    var replyCount: Int = 0
    init(event: NDKEvent) {
        self.id = event.id
        self.event = event
    }
}
</file>

<file path="Olas/Views/Components/ZapView.swift">
import SwiftUI
import NDKSwift
import CoreImage.CIFilterBuiltins
#if canImport(UIKit)
import UIKit
#elseif canImport(AppKit)
import AppKit
#endif
struct ZapView: View {
    let event: NDKEvent
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @StateObject private var walletManager: OlasWalletManager
    @State private var selectedAmount = 1000
    @State private var customAmount = ""
    @State private var comment = ""
    @State private var isLoading = false
    @State private var errorMessage: String?
    @State private var showingSuccess = false
    @State private var recipientProfile: NDKUserProfile?
    let presetAmounts = [100, 500, 1000, 5000, 10000, 50000]
    init(event: NDKEvent, nostrManager: NostrManager) {
        self.event = event
        self._walletManager = StateObject(wrappedValue: OlasWalletManager(nostrManager: nostrManager))
    }
    var body: some View {
        NavigationView {
            VStack(spacing: OlasDesign.Spacing.lg) {
                // Header
                VStack(spacing: OlasDesign.Spacing.sm) {
                    Image(systemName: "bolt.fill")
                        .font(.system(size: 48))
                        .foregroundStyle(OlasDesign.Colors.warning)
                    Text("Send Lightning Zap")
                        .font(OlasDesign.Typography.title)
                        .foregroundStyle(OlasDesign.Colors.text)
                }
                .padding(.top, OlasDesign.Spacing.lg)
                // Amount Selection
                VStack(spacing: OlasDesign.Spacing.md) {
                    Text("Select Amount (sats)")
                        .font(OlasDesign.Typography.caption)
                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                    // Preset amounts
                    LazyVGrid(columns: [GridItem(.adaptive(minimum: 100))], spacing: OlasDesign.Spacing.sm) {
                        ForEach(presetAmounts, id: \.self) { amount in
                            OlasButton(
                                title: formatAmount(amount),
                                action: {
                                    selectedAmount = amount
                                    customAmount = ""
                                    OlasDesign.Haptic.selection()
                                },
                                style: selectedAmount == amount ? .primary : .secondary
                            )
                        }
                    }
                    // Custom amount
                    HStack {
                        OlasTextField(
                            text: $customAmount,
                            placeholder: "Custom amount",
                            icon: "bitcoinsign.circle"
                        )
                        #if os(iOS)
                        .keyboardType(.numberPad)
                        #endif
                        .onChange(of: customAmount) { _, newValue in
                            if !newValue.isEmpty, let amount = Int(newValue) {
                                selectedAmount = amount
                            }
                        }
                    }
                }
                .padding(.horizontal, OlasDesign.Spacing.md)
                // Comment
                VStack(spacing: OlasDesign.Spacing.sm) {
                    Text("Add a comment (optional)")
                        .font(OlasDesign.Typography.caption)
                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                    OlasTextField(
                        text: $comment,
                        placeholder: "Your message...",
                        icon: "text.bubble"
                    )
                }
                .padding(.horizontal, OlasDesign.Spacing.md)
                // Recipient info
                if let profile = recipientProfile {
                    VStack(spacing: OlasDesign.Spacing.xs) {
                        if profile.lud16 != nil || profile.lud06 != nil {
                            Label("Lightning enabled", systemImage: "checkmark.circle.fill")
                                .font(OlasDesign.Typography.caption)
                                .foregroundStyle(OlasDesign.Colors.success)
                        }
                        if let lud16 = profile.lud16 {
                            Text(lud16)
                                .font(OlasDesign.Typography.caption)
                                .foregroundStyle(OlasDesign.Colors.textSecondary)
                        }
                    }
                }
                Spacer()
                // Error message
                if let error = errorMessage {
                    Text(error)
                        .font(OlasDesign.Typography.caption)
                        .foregroundStyle(OlasDesign.Colors.error)
                        .padding(.horizontal, OlasDesign.Spacing.md)
                }
                // Action buttons
                VStack(spacing: OlasDesign.Spacing.md) {
                    OlasButton(
                        title: "Send Zap",
                        action: {
                            Task {
                                await sendZap()
                            }
                        },
                        style: .primary,
                        isLoading: isLoading,
                        isDisabled: !walletManager.isWalletConfigured || selectedAmount > walletManager.currentBalance
                    )
                    if walletManager.isWalletConfigured {
                        Text("Balance: \(formatSats(walletManager.currentBalance)) sats")
                            .font(OlasDesign.Typography.caption)
                            .foregroundStyle(OlasDesign.Colors.textSecondary)
                    }
                    OlasButton(
                        title: "Cancel",
                        action: {
                            dismiss()
                        },
                        style: .secondary
                    )
                }
                .padding(OlasDesign.Spacing.md)
            }
            .background(OlasDesign.Colors.background)
            #if os(iOS)
            .navigationBarHidden(true)
            #else
            .toolbar(.hidden)
            #endif
        }
        .alert("Success", isPresented: $showingSuccess) {
            Button("OK") {
                dismiss()
            }
        } message: {
            Text("Zap sent successfully!")
        }
        .task {
            await fetchRecipientInfo()
            await loadWallet()
        }
    }
    private func formatAmount(_ sats: Int) -> String {
        if sats >= 1000 {
            return "\(sats / 1000)k"
        }
        return "\(sats)"
    }
    private func formatSats(_ sats: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: sats)) ?? "0"
    }
    private func fetchRecipientInfo() async {
        guard let ndk = nostrManager.ndk,
              let profileManager = ndk.profileManager else { return }
        // Observe profile
        for await profile in await profileManager.observe(for: event.pubkey, maxAge: 3600) {
            await MainActor.run {
                recipientProfile = profile
                if let profile = profile {
                    if profile.lud16 == nil && profile.lud06 == nil {
                        errorMessage = "This user doesn't have Lightning enabled"
                    }
                } else {
                    errorMessage = "Unable to load user profile"
                }
            }
            break // Only need first result
        }
    }
    private func loadWallet() async {
        do {
            try await walletManager.loadWallet()
        } catch {
            await MainActor.run {
                errorMessage = "Failed to load wallet: \(error.localizedDescription)"
            }
        }
    }
    private func sendZap() async {
        guard walletManager.isWalletConfigured else {
            errorMessage = "Wallet not configured. Go to Wallet tab to set it up."
            return
        }
        let zapAmount = Int64(selectedAmount)
        guard zapAmount <= walletManager.currentBalance else {
            errorMessage = "Insufficient balance"
            OlasDesign.Haptic.error()
            return
        }
        await MainActor.run {
            isLoading = true
            errorMessage = nil
        }
        do {
            try await walletManager.zapEvent(
                event,
                amount: zapAmount,
                comment: comment.isEmpty ? nil : comment
            )
            await MainActor.run {
                showingSuccess = true
                OlasDesign.Haptic.success()
            }
        } catch {
            await MainActor.run {
                errorMessage = error.localizedDescription
                isLoading = false
                OlasDesign.Haptic.error()
            }
        }
    }
}
struct QRCodeView: View {
    let invoice: String
    @Environment(\.dismiss) var dismiss
    #if canImport(UIKit)
    var qrImage: UIImage? {
        let context = CIContext()
        let filter = CIFilter.qrCodeGenerator()
        filter.setValue(Data(invoice.utf8), forKey: "inputMessage")
        if let outputImage = filter.outputImage {
            let scaledImage = outputImage.transformed(by: CGAffineTransform(scaleX: 10, y: 10))
            if let cgImage = context.createCGImage(scaledImage, from: scaledImage.extent) {
                return UIImage(cgImage: cgImage)
            }
        }
        return nil
    }
    #elseif canImport(AppKit)
    var qrImage: NSImage? {
        let context = CIContext()
        let filter = CIFilter.qrCodeGenerator()
        filter.setValue(Data(invoice.utf8), forKey: "inputMessage")
        if let outputImage = filter.outputImage {
            let scaledImage = outputImage.transformed(by: CGAffineTransform(scaleX: 10, y: 10))
            if let cgImage = context.createCGImage(scaledImage, from: scaledImage.extent) {
                return NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
            }
        }
        return nil
    }
    #endif
    var body: some View {
        NavigationView {
            VStack(spacing: OlasDesign.Spacing.lg) {
                Text("Lightning Invoice")
                    .font(OlasDesign.Typography.title)
                if let image = qrImage {
                    #if canImport(UIKit)
                    Image(uiImage: image)
                        .interpolation(.none)
                        .resizable()
                        .scaledToFit()
                    #elseif canImport(AppKit)
                    Image(nsImage: image)
                        .resizable()
                        .scaledToFit()
                    .frame(width: 300, height: 300)
                    .background(Color.white)
                    .cornerRadius(OlasDesign.CornerRadius.md)
                    #endif
                }
                Text(invoice)
                    .font(.system(.caption, design: .monospaced))
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                    .padding()
                    .background(OlasDesign.Colors.surface)
                    .cornerRadius(OlasDesign.CornerRadius.sm)
                    .padding(.horizontal)
                OlasButton(title: "Copy Invoice", action: {
                    #if os(iOS)
                    UIPasteboard.general.string = invoice
                    #else
                    NSPasteboard.general.clearContents()
                    NSPasteboard.general.setString(invoice, forType: .string)
                    #endif
                    OlasDesign.Haptic.success()
                })
                OlasButton(title: "Done", action: {
                    dismiss()
                }, style: .secondary)
            }
            .padding()
            .background(OlasDesign.Colors.background)
            #if os(iOS)
            .navigationBarHidden(true)
            #else
            .toolbar(.hidden)
            #endif
        }
    }
}
</file>

<file path="Olas/Views/Explore/CategoryPill.swift">
import SwiftUI
struct CategoryPill: View {
    let category: ExploreView.ExploreCategory
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: OlasDesign.Spacing.xs) {
                Image(systemName: category.icon)
                    .font(.system(size: 14))
                Text(category.rawValue)
                    .font(OlasDesign.Typography.caption)
            }
            .foregroundColor(isSelected ? .white : OlasDesign.Colors.text)
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.sm)
            .background(
                Group {
                    if isSelected {
                        LinearGradient(
                            colors: [OlasDesign.Colors.primary, OlasDesign.Colors.secondary],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    } else {
                        OlasDesign.Colors.surface
                    }
                }
            )
            .cornerRadius(20)
            .overlay(
                RoundedRectangle(cornerRadius: 20)
                    .stroke(isSelected ? Color.clear : OlasDesign.Colors.border, lineWidth: 1)
            )
            .scaleEffect(isSelected ? 1.05 : 1.0)
            .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
        }
    }
}
</file>

<file path="Olas/Views/Explore/ExploreGridItem.swift">
import SwiftUI
import NDKSwift
struct ExploreGridItem: View {
    let post: NDKEvent
    let profile: NDKUserProfile?
    let height: CGFloat
    @State private var imageUrls: [String] = []
    @State private var showingPost = false
    var body: some View {
        NavigationLink(destination: PostDetailView(event: post)) {
            ZStack(alignment: .bottomLeading) {
                // Image
                if let firstImageUrl = imageUrls.first,
                   let url = URL(string: firstImageUrl) {
                    AsyncImage(url: url) { phase in
                        switch phase {
                        case .empty:
                            shimmerPlaceholder
                        case .success(let image):
                            image
                                .resizable()
                                .scaledToFill()
                                .frame(height: height)
                                .clipped()
                        case .failure:
                            imagePlaceholder
                        @unknown default:
                            shimmerPlaceholder
                        }
                    }
                } else {
                    imagePlaceholder
                }
                // Gradient overlay
                LinearGradient(
                    colors: [
                        Color.black.opacity(0),
                        Color.black.opacity(0.3),
                        Color.black.opacity(0.6)
                    ],
                    startPoint: .center,
                    endPoint: .bottom
                )
                // Content overlay
                VStack(alignment: .leading, spacing: 4) {
                    // Profile info
                    HStack(spacing: OlasDesign.Spacing.xs) {
                        OlasAvatar(
                            url: profile?.picture,
                            size: 24,
                            pubkey: post.pubkey
                        )
                        Text(profile?.displayName ?? profile?.name ?? "...")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(.white)
                            .lineLimit(1)
                        Spacer()
                    }
                    // Preview text
                    if !post.content.isEmpty {
                        Text(cleanContent(post.content))
                            .font(.system(size: 11))
                            .foregroundColor(.white.opacity(0.9))
                            .lineLimit(2)
                            .multilineTextAlignment(.leading)
                    }
                }
                .padding(OlasDesign.Spacing.sm)
            }
            .frame(height: height)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(0)
        }
        .buttonStyle(PlainButtonStyle())
        .onAppear {
            imageUrls = extractImageUrls(from: post.content)
        }
    }
    @ViewBuilder
    private var shimmerPlaceholder: some View {
        Rectangle()
            .fill(OlasDesign.Colors.surface)
            .overlay(
                ShimmerView()
            )
            .frame(height: height)
    }
    @ViewBuilder
    private var imagePlaceholder: some View {
        ZStack {
            OlasDesign.Colors.surface
            Image(systemName: "photo")
                .font(.system(size: 30))
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
        .frame(height: height)
    }
    private func cleanContent(_ content: String) -> String {
        // Remove image URLs and clean up the text
        var cleaned = content
        // Remove URLs
        let urlPattern = "https?://[^\\s]+"
        cleaned = cleaned.replacingOccurrences(
            of: urlPattern,
            with: "",
            options: .regularExpression
        )
        // Remove extra whitespace
        cleaned = cleaned
            .split(separator: " ")
            .filter { !$0.isEmpty }
            .joined(separator: " ")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        return cleaned
    }
    private func extractImageUrls(from content: String) -> [String] {
        let pattern = "(https?://[^\\s]+\\.(jpg|jpeg|png|gif|webp)[^\\s]*)"
        let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)
        let matches = regex?.matches(in: content, options: [], range: NSRange(content.startIndex..., in: content)) ?? []
        return matches.compactMap { match in
            guard let range = Range(match.range, in: content) else { return nil }
            return String(content[range])
        }
    }
}
// Simple shimmer effect
struct ShimmerView: View {
    @State private var offset: CGFloat = -1
    var body: some View {
        LinearGradient(
            colors: [
                OlasDesign.Colors.surface,
                OlasDesign.Colors.surface.opacity(0.7),
                OlasDesign.Colors.surface
            ],
            startPoint: .leading,
            endPoint: .trailing
        )
        .offset(x: offset * 200)
        .onAppear {
            withAnimation(
                .linear(duration: 1.5)
                .repeatForever(autoreverses: false)
            ) {
                offset = 2
            }
        }
    }
}
</file>

<file path="Olas/Views/Explore/ExploreView.swift">
import SwiftUI
import NDKSwift
struct ExploreView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @StateObject private var viewModel = ExploreViewModel()
    @State private var selectedCategory: ExploreCategory = .trending
    @State private var showingHashtagView = false
    @State private var selectedHashtag = ""
    private let columns = [
        GridItem(.flexible(), spacing: 1),
        GridItem(.flexible(), spacing: 1)
    ]
    enum ExploreCategory: String, CaseIterable {
        case trending = "Trending"
        case art = "Art"
        case photography = "Photography"
        case nature = "Nature"
        case portrait = "Portrait"
        case street = "Street"
        case landscape = "Landscape"
        case food = "Food"
        case architecture = "Architecture"
        var hashtag: String {
            switch self {
            case .trending: return ""
            case .art: return "art"
            case .photography: return "photography"
            case .nature: return "nature"
            case .portrait: return "portrait"
            case .street: return "streetphotography"
            case .landscape: return "landscape"
            case .food: return "foodphotography"
            case .architecture: return "architecture"
            }
        }
        var icon: String {
            switch self {
            case .trending: return "flame.fill"
            case .art: return "paintbrush.fill"
            case .photography: return "camera.fill"
            case .nature: return "leaf.fill"
            case .portrait: return "person.fill"
            case .street: return "building.2.fill"
            case .landscape: return "photo.fill"
            case .food: return "fork.knife"
            case .architecture: return "building.columns.fill"
            }
        }
    }
    struct TrendingHashtag: Identifiable {
        let id = UUID()
        let tag: String
        let count: Int
        let velocity: Double // posts per hour
    }
    var body: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                ScrollView {
                    VStack(spacing: 0) {
                        // Search bar - navigates to dedicated search view
                        NavigationLink(destination: SearchView()) {
                            searchBarButton
                        }
                        .padding(.horizontal, OlasDesign.Spacing.md)
                        .padding(.top, OlasDesign.Spacing.sm)
                        .padding(.bottom, OlasDesign.Spacing.md)
                        // Category pills
                        categoryPills
                            .padding(.bottom, OlasDesign.Spacing.md)
                        // Trending hashtags (only show for trending category)
                        if selectedCategory == .trending && !viewModel.trendingHashtags.isEmpty {
                            trendingHashtagsView
                                .padding(.bottom, OlasDesign.Spacing.md)
                        }
                        // Content
                        if viewModel.isLoading {
                            loadingView
                        } else if filteredPosts.isEmpty {
                            emptyStateView
                        } else {
                            masonryGrid
                        }
                    }
                }
            }
            .navigationTitle("Explore")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.large)
            #endif
            .task {
                if let ndk = nostrManager.ndk {
                    viewModel.startObserving(ndk: ndk, category: selectedCategory)
                }
            }
            .onChange(of: selectedCategory) { _, newCategory in
                if let ndk = nostrManager.ndk {
                    viewModel.changeCategory(to: newCategory, ndk: ndk)
                }
            }
            .sheet(isPresented: $showingHashtagView) {
                HashtagView(hashtag: selectedHashtag)
                    .environmentObject(appState)
                    .environment(nostrManager)
            }
        }
    }
    // MARK: - Views
    @ViewBuilder
    private var searchBarButton: some View {
        HStack(spacing: OlasDesign.Spacing.sm) {
            Image(systemName: "magnifyingglass")
                .foregroundColor(OlasDesign.Colors.textSecondary)
                .font(.body)
            Text("Search posts, hashtags, or users")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textSecondary)
            Spacer()
        }
        .padding(OlasDesign.Spacing.md)
        .background(OlasDesign.Colors.surface)
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(OlasDesign.Colors.border, lineWidth: 1)
        )
    }
    @ViewBuilder
    private var categoryPills: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: OlasDesign.Spacing.sm) {
                ForEach(ExploreCategory.allCases, id: \.self) { category in
                    CategoryPill(
                        category: category,
                        isSelected: selectedCategory == category,
                        action: {
                            withAnimation(.spring()) {
                                selectedCategory = category
                            }
                            OlasDesign.Haptic.selection()
                        }
                    )
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
        }
    }
    @ViewBuilder
    private var trendingHashtagsView: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            Text("Trending Hashtags")
                .font(OlasDesign.Typography.bodyMedium)
                .foregroundColor(OlasDesign.Colors.text)
                .padding(.horizontal, OlasDesign.Spacing.md)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: OlasDesign.Spacing.sm) {
                    ForEach(viewModel.trendingHashtags) { hashtag in
                        TrendingHashtagPill(
                            hashtag: hashtag,
                            action: {
                                selectedHashtag = hashtag.tag
                                showingHashtagView = true
                                OlasDesign.Haptic.selection()
                            }
                        )
                    }
                }
                .padding(.horizontal, OlasDesign.Spacing.md)
            }
        }
    }
    @ViewBuilder
    private var masonryGrid: some View {
        LazyVGrid(columns: columns, spacing: 1) {
            ForEach(Array(filteredPosts.enumerated()), id: \.element.id) { index, item in
                ExploreGridItem(
                    post: item.event,
                    profile: item.profile,
                    height: gridHeights[index % gridHeights.count]
                )
            }
        }
        .padding(.horizontal, 1)
    }
    @ViewBuilder
    private var loadingView: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: OlasDesign.Colors.primary))
                .scaleEffect(1.5)
            Text("Discovering amazing content...")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .frame(maxWidth: .infinity, minHeight: 400)
        .padding(OlasDesign.Spacing.xl)
    }
    @ViewBuilder
    private var emptyStateView: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            Image(systemName: "photo.stack")
                .font(.system(size: 60))
                .foregroundStyle(
                    LinearGradient(
                        colors: [OlasDesign.Colors.primary, OlasDesign.Colors.secondary],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
            Text("No posts found")
                .font(OlasDesign.Typography.title)
                .foregroundColor(OlasDesign.Colors.text)
            Text("Try a different category or search term")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textSecondary)
                .multilineTextAlignment(.center)
        }
        .frame(maxWidth: .infinity, minHeight: 400)
        .padding(OlasDesign.Spacing.xl)
    }
    // MARK: - Data
    private var filteredPosts: [ExploreItem] {
        viewModel.items
    }
    // Random heights for masonry effect
    private let gridHeights: [CGFloat] = [
        180, 220, 200, 240, 190, 210, 230, 195, 215, 225
    ]
}
// MARK: - View Model
@MainActor
class ExploreViewModel: ObservableObject {
    @Published var items: [ExploreItem] = []
    @Published var trendingHashtags: [ExploreView.TrendingHashtag] = []
    @Published var isLoading = false
    private var exploreTask: Task<Void, Never>?
    private var profileTasks: [String: Task<Void, Never>] = [:]
    func startObserving(ndk: NDK, category: ExploreView.ExploreCategory) {
        // Cancel existing task
        exploreTask?.cancel()
        isLoading = true
        exploreTask = Task {
            // Create filter based on category
            var filter: NDKFilter
            if category == .trending {
                // For trending, get both kind 20 (picture posts) and kind 1 with images
                filter = NDKFilter(kinds: [20, 1], limit: 200)
            } else {
                // For specific categories, filter by hashtag
                filter = NDKFilter(
                    kinds: [20, 1],
                    limit: 100,
                    tags: ["t": Set([category.hashtag])]
                )
            }
            // Create data source with reactive pattern
            let dataSource = ndk.observe(
                filter: filter,
                maxAge: 0,  // Real-time updates
                cachePolicy: .cacheWithNetwork
            )
            for await event in dataSource.events {
                // Check if has images
                let imageUrls: [String]
                if event.kind == 20 {
                    imageUrls = ExploreItem.extractImagesFromTags(event.tags)
                } else {
                    imageUrls = ExploreItem.extractImageURLs(from: event.content)
                }
                if !imageUrls.isEmpty {
                    let item = ExploreItem(event: event, imageUrls: imageUrls)
                    await MainActor.run {
                        // Insert sorted by timestamp
                        if let insertIndex = items.firstIndex(where: { $0.event.createdAt < event.createdAt }) {
                            items.insert(item, at: insertIndex)
                        } else {
                            items.append(item)
                        }
                        // Limit items for performance
                        if items.count > 100 {
                            items.removeLast(items.count - 100)
                        }
                        isLoading = false
                    }
                    // Load profile reactively
                    loadProfileReactively(for: event.pubkey, ndk: ndk)
                }
            }
        }
        // Load trending hashtags for trending category
        if category == .trending {
            loadTrendingHashtags()
        }
    }
    func changeCategory(to category: ExploreView.ExploreCategory, ndk: NDK) {
        // Clear existing items
        items.removeAll()
        trendingHashtags.removeAll()
        // Cancel existing tasks
        exploreTask?.cancel()
        profileTasks.values.forEach { $0.cancel() }
        profileTasks.removeAll()
        // Start new observation
        startObserving(ndk: ndk, category: category)
    }
    private func loadProfileReactively(for pubkey: String, ndk: NDK) {
        // Cancel existing task if any
        profileTasks[pubkey]?.cancel()
        profileTasks[pubkey] = Task {
            guard let profileManager = ndk.profileManager else { return }
            for await profile in await profileManager.observe(for: pubkey, maxAge: 3600) {
                if let profile = profile {
                    await MainActor.run {
                        updateItemsWithProfile(pubkey: pubkey, profile: profile)
                    }
                }
            }
        }
    }
    private func updateItemsWithProfile(pubkey: String, profile: NDKUserProfile) {
        for index in items.indices {
            if items[index].event.pubkey == pubkey {
                items[index].profile = profile
            }
        }
    }
    private func loadTrendingHashtags() {
        // For now, use mock data
        // In a real implementation, this would analyze recent posts
        trendingHashtags = [
            ExploreView.TrendingHashtag(tag: "photography", count: 1234, velocity: 45.2),
            ExploreView.TrendingHashtag(tag: "nostr", count: 892, velocity: 38.7),
            ExploreView.TrendingHashtag(tag: "art", count: 756, velocity: 28.3),
            ExploreView.TrendingHashtag(tag: "bitcoin", count: 623, velocity: 22.1),
            ExploreView.TrendingHashtag(tag: "nature", count: 489, velocity: 18.5)
        ]
    }
}
// MARK: - Data Models
struct ExploreItem: Identifiable {
    let id: String
    let event: NDKEvent
    let imageUrls: [String]
    var profile: NDKUserProfile?
    init(event: NDKEvent, imageUrls: [String]) {
        self.id = event.id
        self.event = event
        self.imageUrls = imageUrls
    }
    static func extractImageURLs(from content: String) -> [String] {
        let pattern = "(https?://[^\\s]+\\.(jpg|jpeg|png|gif|webp)[^\\s]*)"
        let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)
        let matches = regex?.matches(in: content, options: [], range: NSRange(content.startIndex..., in: content)) ?? []
        return matches.compactMap { match in
            guard let range = Range(match.range, in: content) else { return nil }
            return String(content[range])
        }
    }
    static func extractImagesFromTags(_ tags: [[String]]) -> [String] {
        var imageURLs: [String] = []
        // Look for imeta tags (NIP-92)
        for tag in tags {
            if tag.count >= 2 && tag[0] == "imeta" {
                // Parse imeta tag values
                for i in 1..<tag.count {
                    let parts = tag[i].components(separatedBy: " ")
                    for part in parts {
                        if part.hasPrefix("url=") {
                            let url = String(part.dropFirst(4))
                            imageURLs.append(url)
                        }
                    }
                }
            }
        }
        // Fallback: look for regular URL tags
        if imageURLs.isEmpty {
            for tag in tags {
                if tag.count >= 2 && tag[0] == "r" && isImageURL(tag[1]) {
                    imageURLs.append(tag[1])
                }
            }
        }
        return imageURLs
    }
    private static func isImageURL(_ url: String) -> Bool {
        let imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".heic"]
        let lowercasedURL = url.lowercased()
        // Check for direct image extensions
        if imageExtensions.contains(where: { lowercasedURL.contains($0) }) {
            return true
        }
        // Check for image hosting services
        let imageHosts = ["imgur.com", "i.imgur.com", "nostr.build", "void.cat", "imgprxy.stacker.news"]
        return imageHosts.contains(where: { lowercasedURL.contains($0) })
    }
}
</file>

<file path="Olas/Views/Explore/HashtagView.swift">
import SwiftUI
import NDKSwift
struct HashtagView: View {
    let hashtag: String
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var posts: [NDKEvent] = []
    @State private var profiles: [String: NDKUserProfile] = [:]
    @State private var isLoading = true
    @State private var isFollowing = false
    @State private var stats = HashtagStats()
    struct HashtagStats {
        var totalPosts: Int = 0
        var postsToday: Int = 0
        var uniqueAuthors: Int = 0
    }
    private let columns = [
        GridItem(.flexible(), spacing: 1),
        GridItem(.flexible(), spacing: 1),
        GridItem(.flexible(), spacing: 1)
    ]
    var body: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                ScrollView {
                    VStack(spacing: 0) {
                        // Header
                        hashtagHeader
                            .padding(OlasDesign.Spacing.lg)
                        // Stats
                        statsView
                            .padding(.horizontal, OlasDesign.Spacing.lg)
                            .padding(.bottom, OlasDesign.Spacing.lg)
                        // Content
                        if isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: OlasDesign.Colors.primary))
                                .scaleEffect(1.5)
                                .frame(minHeight: 300)
                        } else if posts.isEmpty {
                            emptyState
                        } else {
                            postsGrid
                        }
                    }
                }
            }
            .navigationTitle("#\(hashtag)")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(OlasDesign.Colors.primary)
                }
            }
            #else
            .toolbar {
                ToolbarItem(placement: .automatic) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(OlasDesign.Colors.primary)
                }
            }
            #endif
            .task {
                await loadHashtagPosts()
            }
        }
    }
    @ViewBuilder
    private var hashtagHeader: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            // Large hashtag display
            Text("#\(hashtag)")
                .font(.system(size: 36, weight: .bold, design: .rounded))
                .foregroundStyle(
                    LinearGradient(
                        colors: [OlasDesign.Colors.primary, OlasDesign.Colors.secondary],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
            // Follow button
            OlasButton(
                title: isFollowing ? "Following" : "Follow Hashtag",
                action: {
                    isFollowing.toggle()
                    OlasDesign.Haptic.success()
                },
                style: isFollowing ? .secondary : .primary
            )
            .frame(width: 200)
        }
    }
    @ViewBuilder
    private var statsView: some View {
        HStack(spacing: OlasDesign.Spacing.xl) {
            VStack(spacing: 4) {
                Text("\(stats.totalPosts)")
                    .font(OlasDesign.Typography.title)
                    .foregroundColor(OlasDesign.Colors.text)
                Text("Total Posts")
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
            }
            Divider()
                .frame(height: 40)
            VStack(spacing: 4) {
                Text("\(stats.postsToday)")
                    .font(OlasDesign.Typography.title)
                    .foregroundColor(OlasDesign.Colors.text)
                Text("Today")
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
            }
            Divider()
                .frame(height: 40)
            VStack(spacing: 4) {
                Text("\(stats.uniqueAuthors)")
                    .font(OlasDesign.Typography.title)
                    .foregroundColor(OlasDesign.Colors.text)
                Text("Authors")
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
            }
        }
        .padding(OlasDesign.Spacing.md)
        .background(OlasDesign.Colors.surface)
        .cornerRadius(12)
    }
    @ViewBuilder
    private var postsGrid: some View {
        LazyVGrid(columns: columns, spacing: 1) {
            ForEach(posts, id: \.id) { post in
                HashtagGridItem(
                    post: post,
                    profile: profiles[post.pubkey]
                )
                .onAppear {
                    loadProfileIfNeeded(for: post.pubkey)
                }
            }
        }
        .padding(.horizontal, 1)
    }
    @ViewBuilder
    private var emptyState: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            Image(systemName: "number.square")
                .font(.system(size: 60))
                .foregroundColor(OlasDesign.Colors.textTertiary)
            Text("No posts yet")
                .font(OlasDesign.Typography.title)
                .foregroundColor(OlasDesign.Colors.text)
            Text("Be the first to post with #\(hashtag)")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .frame(minHeight: 300)
        .padding(OlasDesign.Spacing.xl)
    }
    private func loadHashtagPosts() async {
        guard let ndk = nostrManager.ndk else { return }
        // Create filter for posts containing this hashtag
        let filter = NDKFilter(
            kinds: [EventKind.textNote],
            limit: 100
        )
        Task {
            let dataSource = ndk.observe(filter: filter)
            let events = await dataSource.collect(timeout: 5.0)
            // Filter posts with hashtag and images
            let loadedPosts = events.filter { event in
                event.content.lowercased().contains("#\(hashtag.lowercased())") &&
                extractImageUrls(from: event.content).count > 0
            }
            // Calculate stats
            var uniqueAuthors = Set<String>()
            let today = Calendar.current.startOfDay(for: Date())
            var postsToday = 0
            for post in loadedPosts {
                uniqueAuthors.insert(post.pubkey)
                let eventDate = Date(timeIntervalSince1970: TimeInterval(post.createdAt))
                if eventDate >= today {
                    postsToday += 1
                }
            }
            await MainActor.run {
                self.posts = Array(loadedPosts.prefix(50))
                self.stats = HashtagStats(
                    totalPosts: loadedPosts.count,
                    postsToday: postsToday,
                    uniqueAuthors: uniqueAuthors.count
                )
                isLoading = false
            }
        }
    }
    private func loadProfileIfNeeded(for pubkey: String) {
        guard profiles[pubkey] == nil,
              let ndk = nostrManager.ndk,
              let profileManager = ndk.profileManager else { return }
        Task {
            for await profile in await profileManager.observe(for: pubkey, maxAge: 3600) {
                await MainActor.run {
                    profiles[pubkey] = profile
                }
                break
            }
        }
    }
    private func extractImageUrls(from content: String) -> [String] {
        let pattern = "(https?://[^\\s]+\\.(jpg|jpeg|png|gif|webp)[^\\s]*)"
        let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)
        let matches = regex?.matches(in: content, options: [], range: NSRange(content.startIndex..., in: content)) ?? []
        return matches.compactMap { match in
            guard let range = Range(match.range, in: content) else { return nil }
            return String(content[range])
        }
    }
}
struct HashtagGridItem: View {
    let post: NDKEvent
    let profile: NDKUserProfile?
    @State private var imageUrls: [String] = []
    var body: some View {
        NavigationLink(destination: PostDetailView(event: post)) {
            GeometryReader { geometry in
                if let firstImageUrl = imageUrls.first,
                   let url = URL(string: firstImageUrl) {
                    AsyncImage(url: url) { phase in
                        switch phase {
                        case .empty:
                            Rectangle()
                                .fill(OlasDesign.Colors.surface)
                                .overlay(ShimmerView())
                        case .success(let image):
                            image
                                .resizable()
                                .scaledToFill()
                                .frame(width: geometry.size.width, height: geometry.size.width)
                                .clipped()
                        case .failure:
                            ZStack {
                                OlasDesign.Colors.surface
                                Image(systemName: "photo")
                                    .foregroundColor(OlasDesign.Colors.textTertiary)
                            }
                        @unknown default:
                            Rectangle()
                                .fill(OlasDesign.Colors.surface)
                        }
                    }
                } else {
                    ZStack {
                        OlasDesign.Colors.surface
                        Image(systemName: "photo")
                            .foregroundColor(OlasDesign.Colors.textTertiary)
                    }
                }
            }
            .aspectRatio(1, contentMode: .fit)
        }
        .buttonStyle(PlainButtonStyle())
        .onAppear {
            imageUrls = extractImageUrls(from: post.content)
        }
    }
    private func extractImageUrls(from content: String) -> [String] {
        let pattern = "(https?://[^\\s]+\\.(jpg|jpeg|png|gif|webp)[^\\s]*)"
        let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)
        let matches = regex?.matches(in: content, options: [], range: NSRange(content.startIndex..., in: content)) ?? []
        return matches.compactMap { match in
            guard let range = Range(match.range, in: content) else { return nil }
            return String(content[range])
        }
    }
}
</file>

<file path="Olas/Views/Explore/TrendingHashtagPill.swift">
import SwiftUI
struct TrendingHashtagPill: View {
    let hashtag: ExploreView.TrendingHashtag
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(alignment: .leading, spacing: 4) {
                HStack(spacing: 4) {
                    Text("#\(hashtag.tag)")
                        .font(OlasDesign.Typography.bodyMedium)
                        .foregroundColor(OlasDesign.Colors.primary)
                    // Trending indicator
                    Image(systemName: "arrow.up.right")
                        .font(.system(size: 10, weight: .bold))
                        .foregroundColor(OlasDesign.Colors.success)
                }
                HStack(spacing: 8) {
                    Text("\(hashtag.count)")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.text)
                    Text("")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textTertiary)
                    Text("\(Int(hashtag.velocity))/hr")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.sm)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(OlasDesign.Colors.border, lineWidth: 1)
            )
        }
    }
}
</file>

<file path="Olas/Views/Onboarding/OnboardingView.swift">
import SwiftUI
struct OnboardingView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var currentPage = 0
    @State private var animateContent = false
    var body: some View {
        ZStack {
            // Dynamic gradient background
            TimeBasedGradient()
                .ignoresSafeArea()
            TabView(selection: $currentPage) {
                WelcomePageView()
                    .tag(0)
                NostrExplainerView()
                    .tag(1)
                KeyGenerationView()
                    .tag(2)
                SecurityEducationView()
                    .tag(3)
                    .environmentObject(appState)
                    .environment(nostrManager)
            }
            #if os(iOS)
            .tabViewStyle(.page(indexDisplayMode: .never))
            #endif
            // Skip button
            if currentPage < 2 {
                VStack {
                    HStack {
                        Spacer()
                        Button("Skip") {
                            withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                                currentPage = 2
                            }
                        }
                        .font(OlasDesign.Typography.body)
                        .foregroundStyle(.white.opacity(0.8))
                        .padding()
                    }
                    Spacer()
                }
            }
        }
        .onAppear {
            withAnimation(.easeOut(duration: 0.8)) {
                animateContent = true
            }
        }
    }
}
// MARK: - Welcome Page
struct WelcomePageView: View {
    @State private var animate = false
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.xxxl) {
            Spacer()
            // Animated Olas logo
            ZStack {
                ForEach(0..<3) { index in
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [
                                    OlasDesign.Colors.primaryGradient.first!,
                                    OlasDesign.Colors.primaryGradient.last!
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 120, height: 120)
                        .opacity(0.3)
                        .scaleEffect(animate ? 1.5 : 1.0)
                        .animation(
                            .easeInOut(duration: 2.0)
                            .repeatForever(autoreverses: true)
                            .delay(Double(index) * 0.3),
                            value: animate
                        )
                }
                Text("Olas")
                    .font(.system(size: 48, weight: .bold, design: .rounded))
                    .foregroundStyle(.white)
            }
            VStack(spacing: OlasDesign.Spacing.lg) {
                Text("Picture-First Social")
                    .font(.system(size: 32, weight: .semibold, design: .rounded))
                    .foregroundStyle(.white)
                Text("Share your visual story on the\ndecentralized web")
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(.white.opacity(0.8))
                    .multilineTextAlignment(.center)
            }
            .opacity(animate ? 1 : 0)
            .offset(y: animate ? 0 : 20)
            .animation(.easeOut(duration: 0.8).delay(0.3), value: animate)
            Spacer()
            // Swipe indicator
            HStack(spacing: 8) {
                ForEach(0..<4) { index in
                    Capsule()
                        .fill(index == 0 ? .white : .white.opacity(0.3))
                        .frame(width: index == 0 ? 24 : 8, height: 8)
                }
            }
            .padding(.bottom, 50)
        }
        .padding(.horizontal, OlasDesign.Spacing.xl)
        .onAppear {
            animate = true
        }
    }
}
// MARK: - Nostr Explainer
struct NostrExplainerView: View {
    @State private var animate = false
    @State private var nodeAnimations: [Bool] = Array(repeating: false, count: 6)
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.xxxl) {
            Spacer()
            // Network visualization
            NetworkVisualization(animate: animate, nodeAnimations: nodeAnimations)
                .frame(width: 300, height: 300)
            VStack(spacing: OlasDesign.Spacing.lg) {
                Text("Your Content, Everywhere")
                    .font(.system(size: 28, weight: .semibold, design: .rounded))
                    .foregroundStyle(.white)
                Text("No single company controls your photos.\nThey live on a network of independent servers.")
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(.white.opacity(0.8))
                    .multilineTextAlignment(.center)
            }
            .opacity(animate ? 1 : 0)
            .offset(y: animate ? 0 : 20)
            .animation(.easeOut(duration: 0.8).delay(0.5), value: animate)
            Spacer()
            // Page indicator
            HStack(spacing: 8) {
                ForEach(0..<4) { index in
                    Capsule()
                        .fill(index == 1 ? .white : .white.opacity(0.3))
                        .frame(width: index == 1 ? 24 : 8, height: 8)
                }
            }
            .padding(.bottom, 50)
        }
        .padding(.horizontal, OlasDesign.Spacing.xl)
        .onAppear {
            animate = true
            for i in 0..<6 {
                nodeAnimations[i] = true
            }
        }
    }
}
// MARK: - Network Visualization Component
struct NetworkVisualization: View {
    let animate: Bool
    let nodeAnimations: [Bool]
    var body: some View {
        ZStack {
            // Connection lines
            ForEach(0..<5) { index in
                ConnectionLine(index: index, animate: animate)
            }
            // Center node
            CenterNode(isAnimating: nodeAnimations[0])
            // Surrounding nodes
            ForEach(0..<5) { index in
                SurroundingNode(index: index, isAnimating: nodeAnimations[index + 1])
            }
        }
    }
}
struct ConnectionLine: View {
    let index: Int
    let animate: Bool
    private var angle: Double {
        Double(index) * 72 * .pi / 180
    }
    private var endPoint: CGPoint {
        let center = CGPoint(x: 150, y: 150)
        return CGPoint(
            x: center.x + cos(angle) * 100,
            y: center.y + sin(angle) * 100
        )
    }
    private var gradientEndPoint: UnitPoint {
        UnitPoint(
            x: 0.5 + cos(angle) * 0.5,
            y: 0.5 + sin(angle) * 0.5
        )
    }
    var body: some View {
        Path { path in
            let center = CGPoint(x: 150, y: 150)
            path.move(to: center)
            path.addLine(to: endPoint)
        }
        .stroke(
            LinearGradient(
                colors: [.white.opacity(0.2), .white.opacity(0.6)],
                startPoint: .center,
                endPoint: gradientEndPoint
            ),
            lineWidth: 2
        )
        .opacity(animate ? 1 : 0)
        .animation(.easeOut(duration: 0.5).delay(Double(index) * 0.1), value: animate)
    }
}
struct CenterNode: View {
    let isAnimating: Bool
    var body: some View {
        Circle()
            .fill(
                LinearGradient(
                    colors: OlasDesign.Colors.primaryGradient,
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .frame(width: 60, height: 60)
            .overlay(
                Image(systemName: "person.fill")
                    .foregroundStyle(.white)
                    .font(.title2)
            )
            .scaleEffect(isAnimating ? 1.1 : 1.0)
            .animation(
                .easeInOut(duration: 1.5).repeatForever(autoreverses: true),
                value: isAnimating
            )
    }
}
struct SurroundingNode: View {
    let index: Int
    let isAnimating: Bool
    var body: some View {
        Circle()
            .fill(
                LinearGradient(
                    colors: [.purple, .pink],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .frame(width: 40, height: 40)
            .overlay(
                Image(systemName: "server.rack")
                    .foregroundStyle(.white)
                    .font(.caption)
            )
            .offset(
                x: cos(Double(index) * 72 * .pi / 180) * 100,
                y: sin(Double(index) * 72 * .pi / 180) * 100
            )
            .scaleEffect(isAnimating ? 1.1 : 1.0)
            .animation(
                .easeInOut(duration: 1.5)
                .repeatForever(autoreverses: true)
                .delay(Double(index) * 0.2),
                value: isAnimating
            )
    }
}
// MARK: - Key Generation
struct KeyGenerationView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var animate = false
    @State private var particles: [Particle] = []
    @State private var keyGenerated = false
    @State private var privateKey: String = ""
    @State private var showMnemonic = false
    struct Particle: Identifiable {
        let id = UUID()
        var position: CGPoint
        var velocity: CGVector
        var opacity: Double
        var scale: CGFloat
    }
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.xxxl) {
            Spacer()
            // Particle animation container
            ZStack {
                // Particles
                ForEach(particles) { particle in
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [.purple, .pink, .blue].shuffled(),
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 10, height: 10)
                        .scaleEffect(particle.scale)
                        .opacity(particle.opacity)
                        .position(particle.position)
                }
                // Key visualization
                if keyGenerated {
                    ZStack {
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: OlasDesign.Colors.primaryGradient,
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 120, height: 120)
                            .blur(radius: 20)
                            .scaleEffect(animate ? 1.2 : 1.0)
                            .animation(
                                .easeInOut(duration: 2).repeatForever(autoreverses: true),
                                value: animate
                            )
                        Image(systemName: "key.fill")
                            .font(.system(size: 60))
                            .foregroundStyle(.white)
                            .rotationEffect(.degrees(animate ? 360 : 0))
                            .animation(
                                .linear(duration: 20).repeatForever(autoreverses: false),
                                value: animate
                            )
                    }
                    .transition(.scale.combined(with: .opacity))
                }
            }
            .frame(width: 300, height: 300)
            .onAppear {
                startParticleAnimation()
            }
            VStack(spacing: OlasDesign.Spacing.lg) {
                Text(keyGenerated ? "Your Identity is Ready" : "Creating Your Identity")
                    .font(.system(size: 28, weight: .semibold, design: .rounded))
                    .foregroundStyle(.white)
                Text(keyGenerated ? 
                     "Your unique cryptographic identity has been created" :
                     "Generating your secure keys...")
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(.white.opacity(0.8))
                    .multilineTextAlignment(.center)
            }
            Spacer()
            if keyGenerated {
                Button {
                    completeOnboarding()
                } label: {
                    Text("Continue")
                        .font(OlasDesign.Typography.bodyBold)
                        .foregroundStyle(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 56)
                        .background(
                            LinearGradient(
                                colors: OlasDesign.Colors.primaryGradient,
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .clipShape(RoundedRectangle(cornerRadius: 16))
                }
                .padding(.horizontal, OlasDesign.Spacing.xl)
                .transition(.move(edge: .bottom).combined(with: .opacity))
            }
            // Page indicator
            HStack(spacing: 8) {
                ForEach(0..<4) { index in
                    Capsule()
                        .fill(index == 2 ? .white : .white.opacity(0.3))
                        .frame(width: index == 2 ? 24 : 8, height: 8)
                }
            }
            .padding(.bottom, 50)
        }
    }
    private func startParticleAnimation() {
        // Create initial particles
        for _ in 0..<50 {
            let particle = Particle(
                position: CGPoint(x: CGFloat.random(in: 50...250),
                                y: CGFloat.random(in: 50...250)),
                velocity: CGVector(dx: CGFloat.random(in: -2...2),
                                 dy: CGFloat.random(in: -2...2)),
                opacity: Double.random(in: 0.3...1.0),
                scale: CGFloat.random(in: 0.5...1.5)
            )
            particles.append(particle)
        }
        // Animate particles converging
        Timer.scheduledTimer(withTimeInterval: 0.016, repeats: true) { timer in
            withAnimation(.linear(duration: 0.016)) {
                for i in particles.indices {
                    // Move towards center
                    let center = CGPoint(x: 150, y: 150)
                    let dx = (center.x - particles[i].position.x) * 0.02
                    let dy = (center.y - particles[i].position.y) * 0.02
                    particles[i].position.x += dx
                    particles[i].position.y += dy
                    particles[i].opacity *= 0.98
                    // Remove particles that are too faded
                    if particles[i].opacity < 0.1 {
                        particles[i].position = CGPoint(
                            x: CGFloat.random(in: 50...250),
                            y: CGFloat.random(in: 50...250)
                        )
                        particles[i].opacity = 1.0
                    }
                }
            }
        }
        // Generate key after animation
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            generateKey()
        }
    }
    private func generateKey() {
        privateKey = generateRandomKey()
        withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
            keyGenerated = true
            animate = true
        }
        OlasDesign.Haptic.success()
    }
    private func generateRandomKey() -> String {
        var bytes = [UInt8](repeating: 0, count: 32)
        _ = SecRandomCopyBytes(kSecRandomDefault, bytes.count, &bytes)
        return bytes.map { String(format: "%02x", $0) }.joined()
    }
    private func completeOnboarding() {
        Task {
            do {
                _ = try await nostrManager.createNewAccount(
                    displayName: "Olas User",
                    about: "Visual storyteller on Nostr "
                )
                UserDefaults.standard.set(true, forKey: "hasSeenOnboarding")
                await MainActor.run {
                    dismiss()
                }
            } catch {
                print("Failed to create account: \(error)")
            }
        }
    }
}
// MARK: - Security Education
struct SecurityEducationView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var animate = false
    @State private var lockAnimation = false
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.xxxl) {
            Spacer()
            // Lock animation
            ZStack {
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [.green, .mint],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 160, height: 160)
                    .blur(radius: 30)
                    .scaleEffect(lockAnimation ? 1.2 : 0.8)
                    .animation(
                        .easeInOut(duration: 2).repeatForever(autoreverses: true),
                        value: lockAnimation
                    )
                Image(systemName: lockAnimation ? "lock.fill" : "lock.open.fill")
                    .font(.system(size: 80))
                    .foregroundStyle(.white)
                    .animation(.spring(response: 0.5, dampingFraction: 0.6), value: lockAnimation)
            }
            VStack(spacing: OlasDesign.Spacing.lg) {
                Text("Your Keys, Your Control")
                    .font(.system(size: 28, weight: .semibold, design: .rounded))
                    .foregroundStyle(.white)
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
                    SecurityPoint(
                        icon: "key.fill",
                        text: "You own your identity",
                        delay: 0.1
                    )
                    SecurityPoint(
                        icon: "lock.shield.fill",
                        text: "No company can ban you",
                        delay: 0.2
                    )
                    SecurityPoint(
                        icon: "arrow.triangle.2.circlepath",
                        text: "Take your content anywhere",
                        delay: 0.3
                    )
                }
            }
            .opacity(animate ? 1 : 0)
            .offset(y: animate ? 0 : 20)
            .animation(.easeOut(duration: 0.8).delay(0.5), value: animate)
            Spacer()
            Button {
                completeOnboarding()
            } label: {
                Text("Get Started")
                    .font(OlasDesign.Typography.bodyBold)
                    .foregroundStyle(.white)
                    .frame(maxWidth: .infinity)
                    .frame(height: 56)
                    .background(
                        LinearGradient(
                            colors: OlasDesign.Colors.primaryGradient,
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .clipShape(RoundedRectangle(cornerRadius: 16))
            }
            .padding(.horizontal, OlasDesign.Spacing.xl)
            .transition(.move(edge: .bottom).combined(with: .opacity))
            // Page indicator
            HStack(spacing: 8) {
                ForEach(0..<4) { index in
                    Capsule()
                        .fill(index == 3 ? .white : .white.opacity(0.3))
                        .frame(width: index == 3 ? 24 : 8, height: 8)
                }
            }
            .padding(.bottom, 50)
        }
        .padding(.horizontal, OlasDesign.Spacing.xl)
        .onAppear {
            animate = true
            withAnimation(.easeInOut(duration: 0.8).delay(0.3)) {
                lockAnimation = true
            }
        }
    }
    private func completeOnboarding() {
        Task {
            do {
                _ = try await nostrManager.createNewAccount(
                    displayName: "Olas User",
                    about: "Visual storyteller on Nostr "
                )
                UserDefaults.standard.set(true, forKey: "hasSeenOnboarding")
                await MainActor.run {
                    dismiss()
                }
            } catch {
                print("Failed to create account: \(error)")
            }
        }
    }
}
struct SecurityPoint: View {
    let icon: String
    let text: String
    let delay: Double
    @State private var animate = false
    var body: some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundStyle(
                    LinearGradient(
                        colors: [.green, .mint],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 32)
            Text(text)
                .font(OlasDesign.Typography.body)
                .foregroundStyle(.white.opacity(0.9))
        }
        .opacity(animate ? 1 : 0)
        .offset(x: animate ? 0 : -20)
        .onAppear {
            withAnimation(.spring(response: 0.5, dampingFraction: 0.8).delay(delay)) {
                animate = true
            }
        }
    }
}
#Preview {
    OnboardingView()
        .environmentObject(AppState())
}
</file>

<file path="Olas/Views/Profile/FollowersListView.swift">
import SwiftUI
import NDKSwift
struct FollowersListView: View {
    let pubkey: String
    let mode: FollowMode
    @Environment(\.dismiss) private var dismiss
    @Environment(NostrManager.self) private var nostrManager
    @StateObject private var viewModel = FollowersViewModel()
    @State private var searchText = ""
    enum FollowMode {
        case followers
        case following
        var title: String {
            switch self {
            case .followers: return "Followers"
            case .following: return "Following"
            }
        }
    }
    var body: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                ScrollView {
                    VStack(spacing: 0) {
                        // Search bar
                        searchBar
                            .padding(.horizontal, OlasDesign.Spacing.md)
                            .padding(.vertical, OlasDesign.Spacing.sm)
                        // Users list
                        if viewModel.isLoading {
                            loadingView
                        } else if filteredUsers.isEmpty && !searchText.isEmpty {
                            noResultsView
                        } else if filteredUsers.isEmpty {
                            emptyStateView
                        } else {
                            usersList
                        }
                    }
                }
            }
            .navigationTitle(mode.title)
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            .task {
                if let ndk = nostrManager.ndk {
                    await viewModel.loadUsers(pubkey: pubkey, mode: mode, ndk: ndk)
                }
            }
        }
    }
    private var searchBar: some View {
        HStack(spacing: OlasDesign.Spacing.sm) {
            Image(systemName: "magnifyingglass")
                .foregroundColor(OlasDesign.Colors.textSecondary)
                .font(.system(size: 16))
            TextField("Search", text: $searchText)
                .textFieldStyle(PlainTextFieldStyle())
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.text)
            if !searchText.isEmpty {
                Button {
                    searchText = ""
                    OlasDesign.Haptic.selection()
                } label: {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        .font(.system(size: 16))
                }
            }
        }
        .padding(.horizontal, OlasDesign.Spacing.md)
        .padding(.vertical, OlasDesign.Spacing.sm)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full)
                .fill(OlasDesign.Colors.surface)
        )
    }
    private var filteredUsers: [FollowUser] {
        if searchText.isEmpty {
            return viewModel.users
        } else {
            return viewModel.users.filter { user in
                user.profile?.name?.localizedCaseInsensitiveContains(searchText) ?? false ||
                user.profile?.displayName?.localizedCaseInsensitiveContains(searchText) ?? false ||
                user.pubkey.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    private var usersList: some View {
        LazyVStack(spacing: 0) {
            ForEach(filteredUsers) { user in
                FollowUserRow(user: user)
                if user.id != filteredUsers.last?.id {
                    Divider()
                        .padding(.leading, 70)
                }
            }
        }
        .padding(.horizontal, OlasDesign.Spacing.md)
    }
    private var loadingView: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            ForEach(0..<10) { _ in
                HStack(spacing: OlasDesign.Spacing.md) {
                    Circle()
                        .fill(OlasDesign.Colors.surface)
                        .frame(width: 50, height: 50)
                        .shimmer()
                    VStack(alignment: .leading, spacing: 4) {
                        RoundedRectangle(cornerRadius: 4)
                            .fill(OlasDesign.Colors.surface)
                            .frame(width: 120, height: 16)
                            .shimmer()
                        RoundedRectangle(cornerRadius: 4)
                            .fill(OlasDesign.Colors.surface)
                            .frame(width: 80, height: 14)
                            .shimmer()
                    }
                    Spacer()
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full)
                        .fill(OlasDesign.Colors.surface)
                        .frame(width: 90, height: 32)
                        .shimmer()
                }
                .padding(.vertical, OlasDesign.Spacing.sm)
            }
        }
        .padding(.horizontal, OlasDesign.Spacing.md)
    }
    private var noResultsView: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            Image(systemName: "magnifyingglass")
                .font(.system(size: 48))
                .foregroundColor(OlasDesign.Colors.textTertiary)
            Text("No users found")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, OlasDesign.Spacing.xxl)
    }
    private var emptyStateView: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            Image(systemName: mode == .followers ? "person.2" : "person.badge.plus")
                .font(.system(size: 60))
                .foregroundStyle(
                    LinearGradient(
                        colors: OlasDesign.Colors.primaryGradient,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
            Text(mode == .followers ? "No followers yet" : "Not following anyone")
                .font(OlasDesign.Typography.title)
                .foregroundColor(OlasDesign.Colors.text)
            Text(mode == .followers ? 
                 "When people follow this account, they'll appear here" : 
                 "Find interesting people to follow")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textSecondary)
                .multilineTextAlignment(.center)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, OlasDesign.Spacing.xxl)
        .padding(.horizontal, OlasDesign.Spacing.xl)
    }
}
// MARK: - Follow User Row
struct FollowUserRow: View {
    let user: FollowUser
    @Environment(NostrManager.self) private var nostrManager
    @State private var isFollowing = false
    @State private var isLoading = false
    @State private var showProfile = false
    var body: some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            // Avatar
            Button {
                showProfile = true
            } label: {
                OlasAvatar(
                    url: user.profile?.picture,
                    size: 50,
                    pubkey: user.pubkey
                )
            }
            // User info
            VStack(alignment: .leading, spacing: 2) {
                Text(user.profile?.displayName ?? user.profile?.name ?? "User")
                    .font(OlasDesign.Typography.bodyMedium)
                    .foregroundColor(OlasDesign.Colors.text)
                    .lineLimit(1)
                Text("@\(user.profile?.name ?? String(user.pubkey.prefix(16)))")
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
                    .lineLimit(1)
                if let about = user.profile?.about {
                    Text(about)
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        .lineLimit(2)
                        .padding(.top, 2)
                }
            }
            Spacer()
            // Follow button
            if user.pubkey != nostrManager.authManager.activeSession?.pubkey {
                Button {
                    Task {
                        await toggleFollow()
                    }
                } label: {
                    if isLoading {
                        ProgressView()
                            .scaleEffect(0.8)
                            .frame(width: 90, height: 32)
                    } else {
                        Text(isFollowing ? "Following" : "Follow")
                            .font(OlasDesign.Typography.caption.bold())
                            .foregroundStyle(isFollowing ? OlasDesign.Colors.text : .white)
                            .frame(width: 90, height: 32)
                            .background(
                                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full)
                                    .stroke(isFollowing ? OlasDesign.Colors.divider : Color.clear, lineWidth: 1)
                                    .fill(isFollowing ? 
                                          AnyShapeStyle(Color.clear) :
                                          AnyShapeStyle(LinearGradient(
                                              colors: OlasDesign.Colors.primaryGradient,
                                              startPoint: .leading,
                                              endPoint: .trailing
                                          ))
                                    )
                            )
                    }
                }
                .animation(.spring(response: 0.3, dampingFraction: 0.8), value: isFollowing)
                .disabled(isLoading)
            }
        }
        .padding(.vertical, OlasDesign.Spacing.sm)
        .contentShape(Rectangle())
        .onTapGesture {
            showProfile = true
        }
        .navigationDestination(isPresented: $showProfile) {
            ProfileView(pubkey: user.pubkey)
        }
        .task {
            await checkFollowStatus()
        }
    }
    private func checkFollowStatus() async {
        guard let ndk = nostrManager.ndk else { return }
        do {
            let contactList = try await ndk.fetchContactList()
            let follows = contactList?.tags.contains { tag in
                tag.count >= 2 && tag[0] == "p" && tag[1] == user.pubkey
            } ?? false
            await MainActor.run {
                isFollowing = follows
            }
        } catch {
            print("Failed to check follow status: \(error)")
        }
    }
    private func toggleFollow() async {
        guard let ndk = nostrManager.ndk else { return }
        isLoading = true
        defer { isLoading = false }
        do {
            let user = NDKUser(pubkey: user.pubkey)
            if isFollowing {
                try await ndk.unfollow(user)
            } else {
                try await ndk.follow(user)
            }
            await MainActor.run {
                isFollowing.toggle()
                OlasDesign.Haptic.success()
            }
        } catch {
            print("Failed to toggle follow: \(error)")
            OlasDesign.Haptic.error()
        }
    }
}
// MARK: - View Model
@MainActor
class FollowersViewModel: ObservableObject {
    @Published var users: [FollowUser] = []
    @Published var isLoading = true
    func loadUsers(pubkey: String, mode: FollowersListView.FollowMode, ndk: NDK) async {
        isLoading = true
        switch mode {
        case .followers:
            await loadFollowers(pubkey: pubkey, ndk: ndk)
        case .following:
            await loadFollowing(pubkey: pubkey, ndk: ndk)
        }
        isLoading = false
    }
    private func loadFollowers(pubkey: String, ndk: NDK) async {
        // Load all contact lists that follow this user
        let filter = NDKFilter(
            kinds: [3], // Contact list
            limit: 1000
        )
        let dataSource = ndk.observe(
            filter: filter,
            maxAge: 0,
            cachePolicy: .cacheWithNetwork
        )
        var followers: [FollowUser] = []
        var processedPubkeys = Set<String>()
        for await event in dataSource.events {
            // Check if this contact list follows our target pubkey
            let pTags = event.tags.filter { $0.count >= 2 && $0[0] == "p" }
            let followsTarget = pTags.contains { $0[1] == pubkey }
            if followsTarget && !processedPubkeys.contains(event.pubkey) {
                processedPubkeys.insert(event.pubkey)
                let follower = FollowUser(pubkey: event.pubkey)
                followers.append(follower)
            }
        }
        self.users = followers
        // Load profiles
        await loadProfiles(ndk: ndk)
    }
    private func loadFollowing(pubkey: String, ndk: NDK) async {
        // Load contact list for this user
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [3],
            limit: 1
        )
        let dataSource = ndk.observe(
            filter: filter,
            maxAge: 0,
            cachePolicy: .cacheWithNetwork
        )
        for await event in dataSource.events {
            // Extract followed users from p tags
            let following = event.tags.compactMap { tag -> FollowUser? in
                guard tag.count >= 2, tag[0] == "p" else { return nil }
                return FollowUser(pubkey: tag[1])
            }
            self.users = following
            // Load profiles
            await loadProfiles(ndk: ndk)
            // Break after first event since we only need one contact list
            break
        }
    }
    private func loadProfiles(ndk: NDK) async {
        guard let profileManager = ndk.profileManager else { return }
        for (index, user) in users.enumerated() {
            Task {
                for await profile in await profileManager.observe(for: user.pubkey, maxAge: 3600) {
                    if let profile = profile {
                        await MainActor.run {
                            if index < self.users.count {
                                self.users[index].profile = profile
                            }
                        }
                    }
                    break
                }
            }
        }
    }
}
// MARK: - Models
struct FollowUser: Identifiable {
    let id = UUID()
    let pubkey: String
    var profile: NDKUserProfile?
}
// MARK: - Shimmer Modifier
struct ShimmerModifier: ViewModifier {
    @State private var phase = 0.0
    func body(content: Content) -> some View {
        content
            .overlay(
                LinearGradient(
                    colors: [
                        .clear,
                        Color.white.opacity(0.2),
                        .clear
                    ],
                    startPoint: .leading,
                    endPoint: .trailing
                )
                .rotationEffect(.degrees(30))
                .offset(x: phase * 200 - 100)
                .mask(content)
            )
            .onAppear {
                withAnimation(.linear(duration: 1.5).repeatForever(autoreverses: false)) {
                    phase = 1
                }
            }
    }
}
extension View {
    func shimmer() -> some View {
        modifier(ShimmerModifier())
    }
}
</file>

<file path="Olas/Views/Search/SearchView.swift">
import SwiftUI
import NDKSwift
struct SearchView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @StateObject private var viewModel = SearchViewModel()
    @State private var searchText = ""
    @State private var selectedTab = 0
    @FocusState private var isSearchFocused: Bool
    @State private var searchHistory: [String] = []
    enum SearchTab: String, CaseIterable {
        case top = "Top"
        case accounts = "Accounts"
        case hashtags = "Tags"
        case places = "Places"
        var icon: String {
            switch self {
            case .top: return "sparkles"
            case .accounts: return "person.2"
            case .hashtags: return "number"
            case .places: return "location"
            }
        }
    }
    var body: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: 0) {
                    // Search bar
                    searchBar
                        .padding(.horizontal, OlasDesign.Spacing.md)
                        .padding(.vertical, OlasDesign.Spacing.sm)
                    // Tab selector
                    if !searchText.isEmpty {
                        searchTabs
                            .padding(.bottom, OlasDesign.Spacing.sm)
                    }
                    // Content
                    ScrollView {
                        if searchText.isEmpty {
                            // Show search history and suggestions
                            searchHistoryView
                        } else {
                            // Show search results
                            searchResultsView
                        }
                    }
                }
            }
            .navigationTitle("Search")
            .navigationBarTitleDisplayMode(.inline)
            .onAppear {
                isSearchFocused = true
                loadSearchHistory()
            }
            .onChange(of: searchText) { _, newValue in
                Task {
                    await viewModel.search(query: newValue, ndk: nostrManager.ndk)
                }
            }
        }
    }
    private var searchBar: some View {
        HStack(spacing: OlasDesign.Spacing.sm) {
            HStack(spacing: OlasDesign.Spacing.sm) {
                Image(systemName: "magnifyingglass")
                    .foregroundColor(OlasDesign.Colors.textSecondary)
                    .font(.system(size: 16))
                TextField("Search", text: $searchText)
                    .textFieldStyle(PlainTextFieldStyle())
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                    .focused($isSearchFocused)
                    .autocapitalization(.none)
                    .autocorrectionDisabled()
                    .submitLabel(.search)
                    .onSubmit {
                        addToSearchHistory(searchText)
                    }
                if !searchText.isEmpty {
                    Button {
                        searchText = ""
                        OlasDesign.Haptic.selection()
                    } label: {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                            .font(.system(size: 16))
                    }
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.sm)
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full)
                    .fill(OlasDesign.Colors.surface)
            )
            if !searchText.isEmpty {
                Button("Cancel") {
                    searchText = ""
                    isSearchFocused = false
                    OlasDesign.Haptic.selection()
                }
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.primary)
            }
        }
    }
    private var searchTabs: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: OlasDesign.Spacing.xs) {
                ForEach(Array(SearchTab.allCases.enumerated()), id: \.offset) { index, tab in
                    SearchTabButton(
                        title: tab.rawValue,
                        icon: tab.icon,
                        isSelected: selectedTab == index
                    ) {
                        selectedTab = index
                        OlasDesign.Haptic.selection()
                    }
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
        }
    }
    private var searchHistoryView: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.lg) {
            // Recent searches
            if !searchHistory.isEmpty {
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
                    HStack {
                        Text("Recent")
                            .font(OlasDesign.Typography.bodyBold)
                            .foregroundColor(OlasDesign.Colors.text)
                        Spacer()
                        Button("Clear All") {
                            clearSearchHistory()
                            OlasDesign.Haptic.selection()
                        }
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.primary)
                    }
                    .padding(.horizontal, OlasDesign.Spacing.md)
                    ForEach(searchHistory, id: \.self) { query in
                        SearchHistoryRow(query: query) {
                            searchText = query
                        } onDelete: {
                            removeFromSearchHistory(query)
                        }
                    }
                }
            }
            // Suggested users
            if !viewModel.suggestedUsers.isEmpty {
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
                    Text("Suggested for You")
                        .font(OlasDesign.Typography.bodyBold)
                        .foregroundColor(OlasDesign.Colors.text)
                        .padding(.horizontal, OlasDesign.Spacing.md)
                    ForEach(viewModel.suggestedUsers) { user in
                        UserSearchRow(user: user)
                    }
                }
                .padding(.top, OlasDesign.Spacing.lg)
            }
        }
        .padding(.vertical, OlasDesign.Spacing.sm)
    }
    private var searchResultsView: some View {
        Group {
            switch SearchTab.allCases[selectedTab] {
            case .top:
                topSearchResults
            case .accounts:
                accountSearchResults
            case .hashtags:
                hashtagSearchResults
            case .places:
                placesSearchResults
            }
        }
    }
    private var topSearchResults: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            // Mix of users and posts
            if !viewModel.searchUsers.isEmpty {
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                    Text("Accounts")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        .padding(.horizontal, OlasDesign.Spacing.md)
                    ForEach(viewModel.searchUsers.prefix(3)) { user in
                        UserSearchRow(user: user)
                    }
                    if viewModel.searchUsers.count > 3 {
                        Button {
                            selectedTab = 1 // Switch to accounts tab
                        } label: {
                            Text("See all accounts")
                                .font(OlasDesign.Typography.bodyMedium)
                                .foregroundColor(OlasDesign.Colors.primary)
                                .padding(.horizontal, OlasDesign.Spacing.md)
                        }
                    }
                }
            }
            if !viewModel.searchPosts.isEmpty {
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                    Text("Posts")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        .padding(.horizontal, OlasDesign.Spacing.md)
                        .padding(.top, OlasDesign.Spacing.md)
                    PostSearchGrid(posts: viewModel.searchPosts)
                }
            }
        }
    }
    private var accountSearchResults: some View {
        VStack(spacing: 0) {
            if viewModel.isSearching && viewModel.searchUsers.isEmpty {
                ForEach(0..<5) { _ in
                    UserSearchRowSkeleton()
                }
            } else if viewModel.searchUsers.isEmpty {
                noResultsView(for: "accounts")
            } else {
                ForEach(viewModel.searchUsers) { user in
                    UserSearchRow(user: user)
                    if user.id != viewModel.searchUsers.last?.id {
                        Divider()
                            .padding(.leading, 70)
                    }
                }
            }
        }
    }
    private var hashtagSearchResults: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            if viewModel.isSearching && viewModel.searchHashtags.isEmpty {
                loadingView
            } else if viewModel.searchHashtags.isEmpty {
                noResultsView(for: "hashtags")
            } else {
                ForEach(viewModel.searchHashtags) { hashtag in
                    HashtagSearchRow(hashtag: hashtag)
                }
            }
        }
        .padding(.horizontal, OlasDesign.Spacing.md)
    }
    private var placesSearchResults: some View {
        VStack {
            Text("Places search coming soon")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textSecondary)
                .padding(.top, 100)
        }
    }
    private var loadingView: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: OlasDesign.Colors.primary))
                .scaleEffect(1.2)
            Text("Searching...")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 100)
    }
    private func noResultsView(for type: String) -> some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            Image(systemName: "magnifyingglass")
                .font(.system(size: 48))
                .foregroundColor(OlasDesign.Colors.textTertiary)
            Text("No \(type) found")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textSecondary)
            Text("Try searching for something else")
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 100)
    }
    // MARK: - Search History Management
    private func loadSearchHistory() {
        searchHistory = UserDefaults.standard.stringArray(forKey: "OlasSearchHistory") ?? []
    }
    private func addToSearchHistory(_ query: String) {
        guard !query.isEmpty else { return }
        // Remove if already exists
        searchHistory.removeAll { $0 == query }
        // Add to beginning
        searchHistory.insert(query, at: 0)
        // Limit to 10 items
        if searchHistory.count > 10 {
            searchHistory = Array(searchHistory.prefix(10))
        }
        // Save
        UserDefaults.standard.set(searchHistory, forKey: "OlasSearchHistory")
    }
    private func removeFromSearchHistory(_ query: String) {
        searchHistory.removeAll { $0 == query }
        UserDefaults.standard.set(searchHistory, forKey: "OlasSearchHistory")
    }
    private func clearSearchHistory() {
        searchHistory.removeAll()
        UserDefaults.standard.removeObject(forKey: "OlasSearchHistory")
    }
}
// MARK: - Search Tab Button
struct SearchTabButton: View {
    let title: String
    let icon: String
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.caption)
                Text(title)
                    .font(OlasDesign.Typography.caption).fontWeight(.bold)
            }
            .foregroundColor(isSelected ? .white : OlasDesign.Colors.text)
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.sm)
            .background(
                Group {
                    if isSelected {
                        LinearGradient(
                            colors: OlasDesign.Colors.primaryGradient,
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    } else {
                        Color.clear
                    }
                }
            )
            .overlay(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full)
                    .stroke(
                        isSelected ? Color.clear : OlasDesign.Colors.divider,
                        lineWidth: 1
                    )
            )
            .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full))
        }
    }
}
// MARK: - Search History Row
struct SearchHistoryRow: View {
    let query: String
    let onTap: () -> Void
    let onDelete: () -> Void
    var body: some View {
        HStack {
            Button(action: onTap) {
                HStack(spacing: OlasDesign.Spacing.md) {
                    Image(systemName: "clock.arrow.circlepath")
                        .font(.system(size: 20))
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Text(query)
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                    Spacer()
                }
            }
            .buttonStyle(PlainButtonStyle())
            Button(action: onDelete) {
                Image(systemName: "xmark")
                    .font(.system(size: 14))
                    .foregroundColor(OlasDesign.Colors.textSecondary)
            }
        }
        .padding(.horizontal, OlasDesign.Spacing.md)
        .padding(.vertical, OlasDesign.Spacing.sm)
    }
}
// MARK: - User Search Row
struct UserSearchRow: View {
    let user: SearchUser
    @State private var showProfile = false
    var body: some View {
        Button {
            showProfile = true
        } label: {
            HStack(spacing: OlasDesign.Spacing.md) {
                OlasAvatar(
                    url: user.profile?.picture,
                    size: 54,
                    pubkey: user.pubkey
                )
                VStack(alignment: .leading, spacing: 2) {
                    Text(user.profile?.displayName ?? user.profile?.name ?? "User")
                        .font(OlasDesign.Typography.bodyMedium)
                        .foregroundColor(OlasDesign.Colors.text)
                        .lineLimit(1)
                    Text("@\(user.profile?.name ?? String(user.pubkey.prefix(16)))")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        .lineLimit(1)
                    if let about = user.profile?.about {
                        Text(about)
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textTertiary)
                            .lineLimit(1)
                    }
                }
                Spacer()
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.sm)
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
        .navigationDestination(isPresented: $showProfile) {
            ProfileView(pubkey: user.pubkey)
        }
    }
}
// MARK: - User Search Row Skeleton
struct UserSearchRowSkeleton: View {
    var body: some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            Circle()
                .fill(OlasDesign.Colors.surface)
                .frame(width: 54, height: 54)
                .shimmer()
            VStack(alignment: .leading, spacing: 6) {
                RoundedRectangle(cornerRadius: 4)
                    .fill(OlasDesign.Colors.surface)
                    .frame(width: 120, height: 16)
                    .shimmer()
                RoundedRectangle(cornerRadius: 4)
                    .fill(OlasDesign.Colors.surface)
                    .frame(width: 80, height: 14)
                    .shimmer()
            }
            Spacer()
        }
        .padding(.horizontal, OlasDesign.Spacing.md)
        .padding(.vertical, OlasDesign.Spacing.sm)
    }
}
// MARK: - Hashtag Search Row
struct HashtagSearchRow: View {
    let hashtag: SearchHashtag
    @State private var showHashtagView = false
    var body: some View {
        Button {
            showHashtagView = true
        } label: {
            HStack(spacing: OlasDesign.Spacing.md) {
                Circle()
                    .fill(
                        LinearGradient(
                            colors: OlasDesign.Colors.primaryGradient,
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 54, height: 54)
                    .overlay(
                        Text("#")
                            .font(.system(size: 28, weight: .bold))
                            .foregroundColor(.white)
                    )
                VStack(alignment: .leading, spacing: 2) {
                    Text("#\(hashtag.tag)")
                        .font(OlasDesign.Typography.bodyMedium)
                        .foregroundColor(OlasDesign.Colors.text)
                    Text("\(hashtag.postCount) posts")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Spacer()
            }
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
        .navigationDestination(isPresented: $showHashtagView) {
            HashtagView(hashtag: hashtag.tag)
        }
    }
}
// MARK: - Post Search Grid
struct PostSearchGrid: View {
    let posts: [SearchPost]
    let columns = [
        GridItem(.flexible(), spacing: 1),
        GridItem(.flexible(), spacing: 1),
        GridItem(.flexible(), spacing: 1)
    ]
    var body: some View {
        LazyVGrid(columns: columns, spacing: 1) {
            ForEach(posts) { post in
                PostSearchGridItem(post: post)
            }
        }
    }
}
struct PostSearchGridItem: View {
    let post: SearchPost
    @State private var showDetail = false
    var body: some View {
        GeometryReader { geometry in
            Button {
                showDetail = true
            } label: {
                if let imageURL = post.imageURLs.first, let url = URL(string: imageURL) {
                    AsyncImage(url: url) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: geometry.size.width, height: geometry.size.width)
                            .clipped()
                    } placeholder: {
                        Rectangle()
                            .fill(OlasDesign.Colors.surface)
                            .overlay(
                                ProgressView()
                            )
                    }
                } else {
                    Rectangle()
                        .fill(OlasDesign.Colors.surface)
                        .overlay(
                            Image(systemName: "photo")
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                        )
                }
            }
        }
        .aspectRatio(1, contentMode: .fit)
        .navigationDestination(isPresented: $showDetail) {
            PostDetailView(event: post.event)
        }
    }
}
// MARK: - View Model
@MainActor
class SearchViewModel: ObservableObject {
    @Published var searchUsers: [SearchUser] = []
    @Published var searchPosts: [SearchPost] = []
    @Published var searchHashtags: [SearchHashtag] = []
    @Published var suggestedUsers: [SearchUser] = []
    @Published var isSearching = false
    private var searchTask: Task<Void, Never>?
    func search(query: String, ndk: NDK?) async {
        searchTask?.cancel()
        guard !query.isEmpty, let ndk = ndk else {
            searchUsers = []
            searchPosts = []
            searchHashtags = []
            isSearching = false
            return
        }
        isSearching = true
        searchTask = Task {
            // Simulate search delay
            try? await Task.sleep(nanoseconds: 300_000_000) // 0.3 seconds
            guard !Task.isCancelled else { return }
            // Search users
            await searchForUsers(query: query, ndk: ndk)
            // Search posts
            await searchForPosts(query: query, ndk: ndk)
            // Extract hashtags from query
            searchForHashtags(query: query)
            isSearching = false
        }
    }
    private func searchForUsers(query: String, ndk: NDK) async {
        let filter = NDKFilter(
            kinds: [0], // Metadata
            limit: 20
        )
        do {
            let dataSource = ndk.observe(filter: filter)
            let events = await dataSource.collect(timeout: 5.0)
            var users: [SearchUser] = []
            for event in events {
                guard let metadata = try? JSONDecoder().decode(NDKUserProfile.self, from: Data(event.content.utf8)) else { continue }
                // Check if name or display name matches query
                let nameMatch = metadata.name?.localizedCaseInsensitiveContains(query) ?? false
                let displayNameMatch = metadata.displayName?.localizedCaseInsensitiveContains(query) ?? false
                if nameMatch || displayNameMatch {
                    let user = SearchUser(
                        pubkey: event.pubkey,
                        profile: metadata
                    )
                    users.append(user)
                }
            }
            self.searchUsers = users
        } catch {
            print("Failed to search users: \(error)")
        }
    }
    private func searchForPosts(query: String, ndk: NDK) async {
        // Search in recent posts
        let filter = NDKFilter(
            kinds: [EventKind.image],
            limit: 50
        )
        do {
            let dataSource = ndk.observe(filter: filter)
            let events = await dataSource.collect(timeout: 5.0)
            var posts: [SearchPost] = []
            for event in events {
                // Check if content contains query
                if event.content.localizedCaseInsensitiveContains(query) ||
                   event.tags.contains(where: { tag in
                       tag.count >= 2 && tag[0] == "t" && tag[1].localizedCaseInsensitiveContains(query)
                   }) {
                    let post = SearchPost(event: event)
                    posts.append(post)
                }
            }
            self.searchPosts = Array(posts.prefix(12))
        } catch {
            print("Failed to search posts: \(error)")
        }
    }
    private func searchForHashtags(query: String) {
        // Extract hashtags from query
        let words = query.split(separator: " ")
        var hashtags: [SearchHashtag] = []
        for word in words {
            let cleanedWord = String(word).trimmingCharacters(in: .punctuationCharacters)
            if cleanedWord.hasPrefix("#") {
                let tag = String(cleanedWord.dropFirst())
                if !tag.isEmpty {
                    hashtags.append(SearchHashtag(tag: tag, postCount: Int.random(in: 10...1000)))
                }
            } else if !cleanedWord.isEmpty {
                // Also search for tags without the # prefix
                hashtags.append(SearchHashtag(tag: cleanedWord, postCount: Int.random(in: 10...1000)))
            }
        }
        self.searchHashtags = hashtags
    }
    func loadSuggestedUsers(ndk: NDK) async {
        // Load some random users as suggestions
        let filter = NDKFilter(
            kinds: [0],
            limit: 10
        )
        do {
            let dataSource = ndk.observe(filter: filter)
            let events = await dataSource.collect(timeout: 5.0)
            let users = events.compactMap { event -> SearchUser? in
                guard let metadata = try? JSONDecoder().decode(NDKUserProfile.self, from: Data(event.content.utf8)) else { return nil }
                return SearchUser(pubkey: event.pubkey, profile: metadata)
            }
            self.suggestedUsers = Array(users.prefix(5))
        } catch {
            print("Failed to load suggested users: \(error)")
        }
    }
}
// MARK: - Models
struct SearchUser: Identifiable {
    let id = UUID()
    let pubkey: String
    let profile: NDKUserProfile?
}
struct SearchPost: Identifiable {
    let id: String
    let event: NDKEvent
    var imageURLs: [String] {
        event.imageURLs
    }
    init(event: NDKEvent) {
        self.id = event.id
        self.event = event
    }
}
struct SearchHashtag: Identifiable {
    let id = UUID()
    let tag: String
    let postCount: Int
}
</file>

<file path="Olas/Views/Settings/AccountSettingsView.swift">
import SwiftUI
import NDKSwift
import CryptoKit
struct AccountSettingsView: View {
    @EnvironmentObject var appState: AppState
    @State private var showKeyBackup = false
    @State private var showCopyAlert = false
    @State private var copiedText = ""
    @State private var showBiometricToggle = false
    @State private var biometricEnabled = false
    @State private var showNsecWarning = false
    @State private var userProfile: NDKUserProfile?
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            ScrollView {
                VStack(spacing: OlasDesign.Spacing.xl) {
                    // Profile section
                    profileSection
                    // Key management section
                    keyManagementSection
                    // Security section
                    securitySection
                    // Data management section
                    dataManagementSection
                }
                .padding(OlasDesign.Spacing.lg)
            }
        }
        .navigationTitle("Account Settings")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.large)
        #endif
        .task {
            if let currentUser = appState.currentUser {
                userProfile = await currentUser.profile
            }
        }
        .sheet(isPresented: $showKeyBackup) {
            keyBackupSheet
        }
        .alert("Copied!", isPresented: $showCopyAlert) {
            Button("OK") { }
        } message: {
            Text("\(copiedText) copied to clipboard")
        }
        .alert("Private Key Warning", isPresented: $showNsecWarning) {
            Button("I Understand", role: .destructive) {
                showKeyBackup = true
            }
            Button("Cancel", role: .cancel) { }
        } message: {
            Text("Your private key (nsec) controls your account. Anyone with this key has full access. Keep it secure and never share it.")
        }
    }
    // MARK: - Sections
    @ViewBuilder
    private var profileSection: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            // Avatar
            if let currentUser = appState.currentUser {
                AsyncImage(url: URL(string: userProfile?.picture ?? "")) { image in
                    image
                        .resizable()
                        .scaledToFill()
                } placeholder: {
                    Image(systemName: "person.circle.fill")
                        .font(.system(size: 80))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [OlasDesign.Colors.primary, OlasDesign.Colors.secondary],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                }
                .frame(width: 100, height: 100)
                .clipShape(Circle())
                .overlay(
                    Circle()
                        .stroke(OlasDesign.Colors.border, lineWidth: 2)
                )
                VStack(spacing: OlasDesign.Spacing.sm) {
                    Text(userProfile?.displayName ?? userProfile?.name ?? "Unknown")
                        .font(OlasDesign.Typography.title2)
                        .foregroundColor(OlasDesign.Colors.text)
                    if let nip05 = userProfile?.nip05 {
                        Text(nip05)
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                }
            }
            OlasButton(
                title: "Edit Profile",
                action: {
                    // TODO: Navigate to profile edit
                    OlasDesign.Haptic.selection()
                },
                style: .secondary
            )
        }
        .frame(maxWidth: .infinity)
        .padding(OlasDesign.Spacing.lg)
        .background(OlasDesign.Colors.surface)
        .cornerRadius(16)
    }
    @ViewBuilder
    private var keyManagementSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Key Management")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            VStack(spacing: OlasDesign.Spacing.sm) {
                // Public key
                keyRow(
                    title: "Public Key",
                    subtitle: "Your public identity",
                    icon: "key",
                    action: copyPublicKey
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                // Private key backup
                keyRow(
                    title: "Backup Private Key",
                    subtitle: "Secure your account",
                    icon: "lock.shield",
                    action: {
                        showNsecWarning = true
                    },
                    isDestructive: true
                )
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
    }
    @ViewBuilder
    private var securitySection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Security")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            VStack(spacing: 0) {
                // Biometric lock
                HStack {
                    Image(systemName: "faceid")
                        .font(.body)
                        .foregroundColor(OlasDesign.Colors.primary)
                        .frame(width: 30)
                    VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                        Text("Biometric Lock")
                            .font(OlasDesign.Typography.body)
                            .foregroundColor(OlasDesign.Colors.text)
                        Text("Require Face ID to access")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    Spacer()
                    Toggle("", isOn: $biometricEnabled)
                        .tint(OlasDesign.Colors.primary)
                }
                .padding(OlasDesign.Spacing.md)
                Divider()
                    .background(OlasDesign.Colors.border)
                    .padding(.leading, 46)
                // Session management
                sessionRow(
                    title: "Active Sessions",
                    subtitle: "Manage logged in devices",
                    icon: "laptopcomputer.and.iphone",
                    badge: "3"
                )
            }
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
    }
    @ViewBuilder
    private var dataManagementSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Data Management")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            VStack(spacing: OlasDesign.Spacing.sm) {
                dataRow(
                    title: "Export Data",
                    subtitle: "Download all your content",
                    icon: "square.and.arrow.up"
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                dataRow(
                    title: "Clear Cache",
                    subtitle: "Free up storage space",
                    icon: "trash",
                    isDestructive: true
                )
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
    }
    // MARK: - Components
    @ViewBuilder
    private func keyRow(title: String, subtitle: String, icon: String, action: @escaping () -> Void, isDestructive: Bool = false) -> some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .font(.body)
                    .foregroundColor(isDestructive ? OlasDesign.Colors.warning : OlasDesign.Colors.primary)
                    .frame(width: 30)
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                    Text(title)
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                    Text(subtitle)
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Spacer()
                Image(systemName: "chevron.right")
                    .font(.caption)
                    .foregroundColor(OlasDesign.Colors.textTertiary)
            }
            .padding(.vertical, OlasDesign.Spacing.sm)
        }
    }
    @ViewBuilder
    private func sessionRow(title: String, subtitle: String, icon: String, badge: String? = nil) -> some View {
        HStack {
            Image(systemName: icon)
                .font(.body)
                .foregroundColor(OlasDesign.Colors.primary)
                .frame(width: 30)
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                Text(title)
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                Text(subtitle)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
            }
            Spacer()
            if let badge = badge {
                Text(badge)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(.white)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 2)
                    .background(OlasDesign.Colors.primary)
                    .cornerRadius(10)
            }
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
        .padding(OlasDesign.Spacing.md)
    }
    @ViewBuilder
    private func dataRow(title: String, subtitle: String, icon: String, isDestructive: Bool = false) -> some View {
        Button(action: {
            // TODO: Implement actions
            OlasDesign.Haptic.selection()
        }) {
            HStack {
                Image(systemName: icon)
                    .font(.body)
                    .foregroundColor(isDestructive ? OlasDesign.Colors.warning : OlasDesign.Colors.primary)
                    .frame(width: 30)
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                    Text(title)
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                    Text(subtitle)
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Spacer()
                Image(systemName: "chevron.right")
                    .font(.caption)
                    .foregroundColor(OlasDesign.Colors.textTertiary)
            }
            .padding(.vertical, OlasDesign.Spacing.sm)
        }
    }
    // MARK: - Key Backup Sheet
    @ViewBuilder
    private var keyBackupSheet: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: OlasDesign.Spacing.xl) {
                    // Warning
                    VStack(spacing: OlasDesign.Spacing.md) {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .font(.system(size: 50))
                            .foregroundColor(OlasDesign.Colors.warning)
                        Text("Private Key Backup")
                            .font(OlasDesign.Typography.title2)
                            .foregroundColor(OlasDesign.Colors.text)
                        Text("Keep this key secure. Anyone with access can control your account.")
                            .font(OlasDesign.Typography.body)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.top, OlasDesign.Spacing.xl)
                    // Key display
                    if let signer = NDKAuthManager.shared.activeSigner as? NDKPrivateKeySigner {
                        VStack(spacing: OlasDesign.Spacing.lg) {
                            // Hex format
                            keyDisplayBox(
                                title: "Hex Format",
                                value: signer.privateKeyValue,
                                action: {
                                    copyToClipboard(signer.privateKeyValue, label: "Private key (hex)")
                                }
                            )
                            // nsec format
                            if let nsec = try? signer.nsec {
                                keyDisplayBox(
                                    title: "nsec Format",
                                    value: nsec,
                                    action: {
                                        copyToClipboard(nsec, label: "Private key (nsec)")
                                    }
                                )
                            }
                        }
                    }
                    Spacer()
                    // Done button
                    OlasButton(
                        title: "Done",
                        action: {
                            showKeyBackup = false
                        },
                        style: .primary
                    )
                    .padding(.bottom, OlasDesign.Spacing.lg)
                }
                .padding(.horizontal, OlasDesign.Spacing.lg)
            }
        }
    }
    @ViewBuilder
    private func keyDisplayBox(title: String, value: String, action: @escaping () -> Void) -> some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            Text(title)
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textSecondary)
            HStack {
                Text(value)
                    .font(.system(.caption, design: .monospaced))
                    .foregroundColor(OlasDesign.Colors.text)
                    .lineLimit(1)
                    .truncationMode(.middle)
                Spacer()
                Button(action: action) {
                    Image(systemName: "doc.on.doc")
                        .font(.body)
                        .foregroundColor(OlasDesign.Colors.primary)
                }
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(8)
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(OlasDesign.Colors.border, lineWidth: 1)
            )
        }
    }
    // MARK: - Methods
    private func copyPublicKey() {
        guard let signer = NDKAuthManager.shared.activeSigner as? NDKPrivateKeySigner else { return }
        Task {
            do {
                let pubkey = try await signer.pubkey
                await MainActor.run {
                    copyToClipboard(pubkey, label: "Public key")
                }
            } catch {
                print("Failed to get public key: \(error)")
            }
        }
    }
    private func copyToClipboard(_ text: String, label: String) {
        #if canImport(UIKit)
        UIPasteboard.general.string = text
        #elseif canImport(AppKit)
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(text, forType: .string)
        #endif
        copiedText = label
        showCopyAlert = true
        OlasDesign.Haptic.success()
    }
}
// MARK: - Preview
struct AccountSettingsView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            AccountSettingsView()
                .environmentObject(AppState())
        }
    }
}
</file>

<file path="Olas/Views/Settings/NotificationSettingsView.swift">
import SwiftUI
struct NotificationSettingsView: View {
    @State private var pushNotificationsEnabled = true
    @State private var newFollowers = true
    @State private var mentions = true
    @State private var replies = true
    @State private var zaps = true
    @State private var directMessages = true
    @State private var showSoundSettings = false
    @State private var selectedSound = "Default"
    private let notificationSounds = ["Default", "Chime", "Pop", "Ding", "None"]
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            ScrollView {
                VStack(spacing: OlasDesign.Spacing.xl) {
                    // Master toggle
                    masterToggleSection
                    if pushNotificationsEnabled {
                        // Notification types
                        notificationTypesSection
                        // Sound settings
                        soundSettingsSection
                        // Quiet hours
                        quietHoursSection
                    }
                }
                .padding(OlasDesign.Spacing.lg)
            }
        }
        .navigationTitle("Notifications")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.large)
        #endif
        .sheet(isPresented: $showSoundSettings) {
            soundSelectionSheet
        }
    }
    // MARK: - Sections
    @ViewBuilder
    private var masterToggleSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            HStack {
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                    Text("Push Notifications")
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                    Text("Get notified about activity")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Spacer()
                Toggle("", isOn: $pushNotificationsEnabled)
                    .tint(OlasDesign.Colors.primary)
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
        .onChange(of: pushNotificationsEnabled) { _, enabled in
            OlasDesign.Haptic.selection()
            if enabled {
                requestNotificationPermission()
            }
        }
    }
    @ViewBuilder
    private var notificationTypesSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Notification Types")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            VStack(spacing: 0) {
                notificationToggle(
                    title: "New Followers",
                    subtitle: "When someone follows you",
                    icon: "person.badge.plus",
                    isOn: $newFollowers
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                    .padding(.leading, 46)
                notificationToggle(
                    title: "Mentions",
                    subtitle: "When you're @mentioned",
                    icon: "at",
                    isOn: $mentions
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                    .padding(.leading, 46)
                notificationToggle(
                    title: "Replies",
                    subtitle: "Responses to your posts",
                    icon: "bubble.left",
                    isOn: $replies
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                    .padding(.leading, 46)
                notificationToggle(
                    title: "Zaps",
                    subtitle: "Lightning payments received",
                    icon: "bolt.fill",
                    isOn: $zaps
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                    .padding(.leading, 46)
                notificationToggle(
                    title: "Direct Messages",
                    subtitle: "Private messages",
                    icon: "envelope",
                    isOn: $directMessages
                )
            }
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
    }
    @ViewBuilder
    private var soundSettingsSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Sound")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            Button(action: {
                showSoundSettings = true
                OlasDesign.Haptic.selection()
            }) {
                HStack {
                    Image(systemName: "speaker.wave.2")
                        .font(.body)
                        .foregroundColor(OlasDesign.Colors.primary)
                        .frame(width: 30)
                    Text("Notification Sound")
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                    Spacer()
                    Text(selectedSound)
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Image(systemName: "chevron.right")
                        .font(.caption)
                        .foregroundColor(OlasDesign.Colors.textTertiary)
                }
                .padding(OlasDesign.Spacing.md)
                .background(OlasDesign.Colors.surface)
                .cornerRadius(12)
            }
        }
    }
    @ViewBuilder
    private var quietHoursSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Quiet Hours")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            VStack(spacing: OlasDesign.Spacing.md) {
                quietHourRow(
                    title: "Do Not Disturb",
                    subtitle: "Silence notifications",
                    icon: "moon.fill"
                )
                quietHourRow(
                    title: "Schedule",
                    subtitle: "10:00 PM - 7:00 AM",
                    icon: "clock"
                )
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
    }
    // MARK: - Components
    @ViewBuilder
    private func notificationToggle(title: String, subtitle: String, icon: String, isOn: Binding<Bool>) -> some View {
        HStack {
            Image(systemName: icon)
                .font(.body)
                .foregroundColor(OlasDesign.Colors.primary)
                .frame(width: 30)
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                Text(title)
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                Text(subtitle)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
            }
            Spacer()
            Toggle("", isOn: isOn)
                .tint(OlasDesign.Colors.primary)
        }
        .padding(OlasDesign.Spacing.md)
        .onChange(of: isOn.wrappedValue) { _, _ in
            OlasDesign.Haptic.selection()
        }
    }
    @ViewBuilder
    private func quietHourRow(title: String, subtitle: String, icon: String) -> some View {
        HStack {
            Image(systemName: icon)
                .font(.body)
                .foregroundColor(OlasDesign.Colors.primary)
                .frame(width: 30)
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                Text(title)
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                Text(subtitle)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
            }
            Spacer()
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
    }
    // MARK: - Sound Selection Sheet
    @ViewBuilder
    private var soundSelectionSheet: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: 0) {
                    // Header
                    HStack {
                        Button("Cancel") {
                            showSoundSettings = false
                        }
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        Spacer()
                        Text("Notification Sound")
                            .font(OlasDesign.Typography.title3)
                            .foregroundColor(OlasDesign.Colors.text)
                        Spacer()
                        Button("Done") {
                            showSoundSettings = false
                        }
                        .foregroundColor(OlasDesign.Colors.primary)
                    }
                    .padding(OlasDesign.Spacing.lg)
                    // Sound options
                    VStack(spacing: OlasDesign.Spacing.sm) {
                        ForEach(notificationSounds, id: \.self) { sound in
                            Button(action: {
                                selectedSound = sound
                                playSound(sound)
                                OlasDesign.Haptic.selection()
                            }) {
                                HStack {
                                    Text(sound)
                                        .font(OlasDesign.Typography.body)
                                        .foregroundColor(OlasDesign.Colors.text)
                                    Spacer()
                                    if selectedSound == sound {
                                        Image(systemName: "checkmark")
                                            .font(.body)
                                            .foregroundColor(OlasDesign.Colors.primary)
                                    }
                                }
                                .padding(OlasDesign.Spacing.md)
                                .background(OlasDesign.Colors.surface)
                                .cornerRadius(8)
                            }
                        }
                    }
                    .padding(OlasDesign.Spacing.lg)
                    Spacer()
                }
            }
        }
    }
    // MARK: - Methods
    private func requestNotificationPermission() {
        #if os(iOS)
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) { granted, error in
            if granted {
                print("Notification permission granted")
            } else if let error = error {
                print("Notification permission error: \(error)")
            }
        }
        #endif
    }
    private func playSound(_ sound: String) {
        // In a real app, you'd play the actual sound here
        print("Playing sound: \(sound)")
    }
}
// MARK: - Preview
struct NotificationSettingsView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            NotificationSettingsView()
        }
    }
}
</file>

<file path="Olas/Views/Settings/RelayManagementView.swift">
import SwiftUI
import NDKSwift
struct RelayManagementView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var relays: [RelayInfo] = []
    @State private var newRelayURL = ""
    @State private var showAddRelay = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var isConnecting = false
    @State private var relayToRemove: RelayInfo?
    @State private var showRemoveConfirmation = false
    struct RelayInfo: Identifiable {
        let id = UUID()
        let url: String
        var status: RelayStatus
        var isRead: Bool
        var isWrite: Bool
        var latency: Int? // in milliseconds
    }
    enum RelayStatus {
        case connected
        case connecting
        case disconnected
        case error
        var color: Color {
            switch self {
            case .connected: return .green
            case .connecting: return .orange
            case .disconnected: return .gray
            case .error: return .red
            }
        }
        var icon: String {
            switch self {
            case .connected: return "circle.fill"
            case .connecting: return "circle.dotted"
            case .disconnected: return "circle"
            case .error: return "exclamationmark.circle"
            }
        }
    }
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            VStack(spacing: 0) {
                // Header with add button
                HStack {
                    Text("Relay Management")
                        .font(OlasDesign.Typography.title)
                        .foregroundColor(OlasDesign.Colors.text)
                    Spacer()
                    Button(action: {
                        showAddRelay = true
                        OlasDesign.Haptic.selection()
                    }) {
                        Image(systemName: "plus.circle.fill")
                            .font(.title2)
                            .foregroundStyle(
                                LinearGradient(
                                    colors: [OlasDesign.Colors.primary, OlasDesign.Colors.secondary],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                    }
                }
                .padding(OlasDesign.Spacing.lg)
                // Relay statistics
                relayStatsView
                    .padding(.horizontal, OlasDesign.Spacing.lg)
                    .padding(.bottom, OlasDesign.Spacing.lg)
                // Relay list
                ScrollView {
                    VStack(spacing: OlasDesign.Spacing.md) {
                        ForEach(relays) { relay in
                            relayRow(relay)
                        }
                    }
                    .padding(OlasDesign.Spacing.lg)
                }
            }
        }
        .onAppear {
            loadRelays()
        }
        .sheet(isPresented: $showAddRelay) {
            addRelaySheet
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .alert("Remove Relay", isPresented: $showRemoveConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("Remove", role: .destructive) {
                if let relay = relayToRemove {
                    removeRelay(relay)
                }
            }
        } message: {
            Text("Are you sure you want to remove \(relayToRemove?.url ?? "")?")
        }
    }
    // MARK: - Views
    @ViewBuilder
    private var relayStatsView: some View {
        HStack(spacing: OlasDesign.Spacing.lg) {
            statsCard(
                title: "Connected",
                value: "\(relays.filter { $0.status == .connected }.count)",
                color: .green
            )
            statsCard(
                title: "Total",
                value: "\(relays.count)",
                color: OlasDesign.Colors.primary
            )
            statsCard(
                title: "Avg Latency",
                value: formatLatency(averageLatency()),
                color: .blue
            )
        }
    }
    @ViewBuilder
    private func statsCard(title: String, value: String, color: Color) -> some View {
        VStack(spacing: OlasDesign.Spacing.xs) {
            Text(value)
                .font(OlasDesign.Typography.title)
                .foregroundColor(color)
            Text(title)
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .frame(maxWidth: .infinity)
        .padding(OlasDesign.Spacing.md)
        .background(OlasDesign.Colors.surface)
        .cornerRadius(12)
    }
    @ViewBuilder
    private func relayRow(_ relay: RelayInfo) -> some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            // Status indicator
            Image(systemName: relay.status.icon)
                .foregroundColor(relay.status.color)
                .font(.body)
            // Relay info
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                Text(relay.url)
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                    .lineLimit(1)
                HStack(spacing: OlasDesign.Spacing.sm) {
                    if relay.isRead {
                        Label("Read", systemImage: "arrow.down.circle")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    if relay.isWrite {
                        Label("Write", systemImage: "arrow.up.circle")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    if let latency = relay.latency {
                        Label("\(latency)ms", systemImage: "speedometer")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                }
            }
            Spacer()
            // Actions
            Menu {
                Button(action: {
                    toggleRead(relay)
                }) {
                    Label(relay.isRead ? "Disable Read" : "Enable Read", systemImage: "arrow.down.circle")
                }
                Button(action: {
                    toggleWrite(relay)
                }) {
                    Label(relay.isWrite ? "Disable Write" : "Enable Write", systemImage: "arrow.up.circle")
                }
                if relay.status == .disconnected {
                    Button(action: {
                        reconnectRelay(relay)
                    }) {
                        Label("Reconnect", systemImage: "arrow.counterclockwise")
                    }
                }
                Button(role: .destructive, action: {
                    relayToRemove = relay
                    showRemoveConfirmation = true
                }) {
                    Label("Remove", systemImage: "trash")
                }
            } label: {
                Image(systemName: "ellipsis")
                    .font(.body)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
                    .frame(width: 44, height: 44)
            }
        }
        .padding(OlasDesign.Spacing.md)
        .background(OlasDesign.Colors.surface)
        .cornerRadius(12)
    }
    @ViewBuilder
    private var addRelaySheet: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: OlasDesign.Spacing.lg) {
                    Text("Add New Relay")
                        .font(OlasDesign.Typography.title2)
                        .foregroundColor(OlasDesign.Colors.text)
                        .padding(.top, OlasDesign.Spacing.lg)
                    VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                        Text("Relay URL")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                        TextField("wss://relay.example.com", text: $newRelayURL)
                            .textFieldStyle(.plain)
                            .padding(OlasDesign.Spacing.md)
                            .background(OlasDesign.Colors.surface)
                            .cornerRadius(8)
                            .overlay(
                                RoundedRectangle(cornerRadius: 8)
                                    .stroke(OlasDesign.Colors.border, lineWidth: 1)
                            )
                            #if os(iOS)
                            .autocapitalization(.none)
                            #endif
                            .disableAutocorrection(true)
                    }
                    // Popular relays
                    VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                        Text("Popular Relays")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: OlasDesign.Spacing.sm) {
                                ForEach(popularRelays, id: \.self) { relay in
                                    Button(action: {
                                        newRelayURL = relay
                                        OlasDesign.Haptic.selection()
                                    }) {
                                        Text(relay)
                                            .font(OlasDesign.Typography.caption)
                                            .padding(.horizontal, OlasDesign.Spacing.md)
                                            .padding(.vertical, OlasDesign.Spacing.sm)
                                            .background(OlasDesign.Colors.surface)
                                            .cornerRadius(20)
                                            .overlay(
                                                RoundedRectangle(cornerRadius: 20)
                                                    .stroke(OlasDesign.Colors.border, lineWidth: 1)
                                            )
                                    }
                                    .foregroundColor(OlasDesign.Colors.text)
                                }
                            }
                        }
                    }
                    Spacer()
                    // Action buttons
                    HStack(spacing: OlasDesign.Spacing.md) {
                        OlasButton(
                            title: "Cancel",
                            action: {
                                showAddRelay = false
                                newRelayURL = ""
                            },
                            style: .secondary
                        )
                        OlasButton(
                            title: isConnecting ? "Connecting..." : "Add Relay",
                            action: addNewRelay,
                            style: .primary,
                            isLoading: isConnecting
                        )
                        .disabled(newRelayURL.isEmpty || isConnecting)
                    }
                    .padding(.bottom, OlasDesign.Spacing.lg)
                }
                .padding(.horizontal, OlasDesign.Spacing.lg)
            }
        }
    }
    // MARK: - Data
    private let popularRelays = [
        "wss://relay.damus.io",
        "wss://relay.nostr.band",
        "wss://nos.lol",
        "wss://nostr.wine",
        "wss://relay.snort.social"
    ]
    // MARK: - Methods
    private func loadRelays() {
        guard let ndk = nostrManager.ndk else { return }
        Task {
            var loadedRelays: [RelayInfo] = []
            // Load default relays
            for relay in nostrManager.defaultRelays {
                let status = nostrManager.relayStatus[relay] ?? false
                let relayInfo = RelayInfo(
                    url: relay,
                    status: status ? .connected : .disconnected,
                    isRead: true,
                    isWrite: true,
                    latency: nil
                )
                loadedRelays.append(relayInfo)
            }
            // Load user-added relays
            for relay in nostrManager.userAddedRelays {
                let status = nostrManager.relayStatus[relay] ?? false
                let relayInfo = RelayInfo(
                    url: relay,
                    status: status ? .connected : .disconnected,
                    isRead: true,
                    isWrite: true,
                    latency: nil
                )
                loadedRelays.append(relayInfo)
            }
            await MainActor.run {
                self.relays = loadedRelays
                // Measure latency for connected relays
                for (index, relay) in relays.enumerated() where relay.status == .connected {
                    measureLatency(for: relay) { latency in
                        if let latency = latency {
                            self.relays[index].latency = latency
                        }
                    }
                }
            }
        }
    }
    private func addNewRelay() {
        guard !newRelayURL.isEmpty else { return }
        isConnecting = true
        Task {
            // Normalize the URL
            var normalizedURL = newRelayURL
            if !normalizedURL.hasPrefix("wss://") && !normalizedURL.hasPrefix("ws://") {
                normalizedURL = "wss://\(normalizedURL)"
            }
            // Add relay using NostrManager
            await nostrManager.addUserRelay(normalizedURL)
            await MainActor.run {
                OlasDesign.Haptic.success()
                showAddRelay = false
                newRelayURL = ""
                isConnecting = false
                loadRelays()
            }
        }
    }
    private func removeRelay(_ relay: RelayInfo) {
        Task {
            // Remove relay using NostrManager
            await nostrManager.removeUserRelay(relay.url)
            await MainActor.run {
                relays.removeAll { $0.id == relay.id }
                OlasDesign.Haptic.success()
            }
        }
    }
    private func toggleRead(_ relay: RelayInfo) {
        if let index = relays.firstIndex(where: { $0.id == relay.id }) {
            relays[index].isRead.toggle()
            // TODO: Update relay configuration in NDK
        }
    }
    private func toggleWrite(_ relay: RelayInfo) {
        if let index = relays.firstIndex(where: { $0.id == relay.id }) {
            relays[index].isWrite.toggle()
            // TODO: Update relay configuration in NDK
        }
    }
    private func reconnectRelay(_ relay: RelayInfo) {
        guard let ndk = nostrManager.ndk else { return }
        if let index = relays.firstIndex(where: { $0.id == relay.id }) {
            relays[index].status = .connecting
            Task {
                // Try to reconnect by re-adding the relay
                await ndk.addRelay(relay.url)
                await MainActor.run {
                    loadRelays()
                }
            }
        }
    }
    private func measureLatency(for relay: RelayInfo, completion: @escaping (Int?) -> Void) {
        // Simple latency measurement - in production, you'd send a ping event
        let start = Date()
        Task {
            // Simulate latency measurement
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s
            let latency = Int(Date().timeIntervalSince(start) * 1000)
            await MainActor.run {
                completion(latency)
            }
        }
    }
    private func averageLatency() -> Int? {
        let latencies = relays.compactMap { $0.latency }
        guard !latencies.isEmpty else { return nil }
        return latencies.reduce(0, +) / latencies.count
    }
    private func formatLatency(_ latency: Int?) -> String {
        guard let latency = latency else { return "N/A" }
        return "\(latency)ms"
    }
}
// MARK: - Preview
struct RelayManagementView_Previews: PreviewProvider {
    static var previews: some View {
        RelayManagementView()
            .environmentObject(AppState())
    }
}
</file>

<file path="Olas/Views/Settings/ThemeSettingsView.swift">
import SwiftUI
struct ThemeSettingsView: View {
    @State private var selectedTheme = "Auto"
    @State private var accentColor = "Purple"
    @State private var appIcon = "Default"
    private let themes = ["Auto", "Light", "Dark"]
    private let accentColors = [
        ("Purple", Color.purple),
        ("Blue", Color.blue),
        ("Pink", Color.pink),
        ("Orange", Color.orange),
        ("Green", Color.green),
        ("Red", Color.red)
    ]
    private let appIcons = ["Default", "Dark", "Gradient", "Minimal"]
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            ScrollView {
                VStack(spacing: OlasDesign.Spacing.xl) {
                    // Theme selection
                    themeSection
                    // Accent color
                    accentColorSection
                    // App icon
                    appIconSection
                    // Preview
                    previewSection
                }
                .padding(OlasDesign.Spacing.lg)
            }
        }
        .navigationTitle("Theme")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.large)
        #endif
    }
    // MARK: - Sections
    @ViewBuilder
    private var themeSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Appearance")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            HStack(spacing: OlasDesign.Spacing.md) {
                ForEach(themes, id: \.self) { theme in
                    themeOption(theme)
                }
            }
        }
    }
    @ViewBuilder
    private func themeOption(_ theme: String) -> some View {
        Button(action: {
            selectedTheme = theme
            OlasDesign.Haptic.selection()
        }) {
            VStack(spacing: OlasDesign.Spacing.sm) {
                // Preview
                ZStack {
                    RoundedRectangle(cornerRadius: 12)
                        .fill(theme == "Dark" ? Color.black : theme == "Light" ? Color.white : Color.gray)
                        .frame(height: 100)
                    VStack(spacing: 4) {
                        RoundedRectangle(cornerRadius: 4)
                            .fill(theme == "Dark" ? Color.gray : Color.black.opacity(0.8))
                            .frame(width: 40, height: 4)
                        HStack(spacing: 4) {
                            ForEach(0..<3) { _ in
                                RoundedRectangle(cornerRadius: 2)
                                    .fill(theme == "Dark" ? Color.gray.opacity(0.5) : Color.gray.opacity(0.3))
                                    .frame(width: 20, height: 20)
                            }
                        }
                        .padding(.top, 8)
                    }
                }
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(selectedTheme == theme ? OlasDesign.Colors.primary : OlasDesign.Colors.border, lineWidth: 2)
                )
                Text(theme)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(selectedTheme == theme ? OlasDesign.Colors.primary : OlasDesign.Colors.textSecondary)
            }
        }
        .frame(maxWidth: .infinity)
    }
    @ViewBuilder
    private var accentColorSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Accent Color")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: OlasDesign.Spacing.md), count: 3), spacing: OlasDesign.Spacing.md) {
                ForEach(accentColors, id: \.0) { name, color in
                    Button(action: {
                        accentColor = name
                        OlasDesign.Haptic.selection()
                    }) {
                        VStack(spacing: OlasDesign.Spacing.sm) {
                            Circle()
                                .fill(color)
                                .frame(width: 60, height: 60)
                                .overlay(
                                    Circle()
                                        .stroke(accentColor == name ? Color.white : Color.clear, lineWidth: 3)
                                        .padding(3)
                                )
                                .overlay(
                                    Circle()
                                        .stroke(accentColor == name ? color : OlasDesign.Colors.border, lineWidth: 2)
                                )
                            Text(name)
                                .font(OlasDesign.Typography.caption)
                                .foregroundColor(accentColor == name ? color : OlasDesign.Colors.textSecondary)
                        }
                    }
                }
            }
        }
    }
    @ViewBuilder
    private var appIconSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("App Icon")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: OlasDesign.Spacing.md), count: 4), spacing: OlasDesign.Spacing.md) {
                ForEach(appIcons, id: \.self) { icon in
                    Button(action: {
                        appIcon = icon
                        changeAppIcon(to: icon)
                        OlasDesign.Haptic.selection()
                    }) {
                        VStack(spacing: OlasDesign.Spacing.sm) {
                            // Icon preview
                            RoundedRectangle(cornerRadius: 16)
                                .fill(
                                    icon == "Default" ? LinearGradient(
                                        colors: [.purple, .pink],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ) : icon == "Dark" ? LinearGradient(
                                        colors: [.black, .gray],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ) : icon == "Gradient" ? LinearGradient(
                                        colors: [.blue, .green],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ) : LinearGradient(
                                        colors: [.white, .gray],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 60, height: 60)
                                .overlay(
                                    Text("O")
                                        .font(.system(size: 30, weight: .bold, design: .rounded))
                                        .foregroundColor(icon == "Minimal" ? .black : .white)
                                )
                                .overlay(
                                    RoundedRectangle(cornerRadius: 16)
                                        .stroke(appIcon == icon ? OlasDesign.Colors.primary : OlasDesign.Colors.border, lineWidth: 2)
                                )
                            Text(icon)
                                .font(.system(size: 10))
                                .foregroundColor(appIcon == icon ? OlasDesign.Colors.primary : OlasDesign.Colors.textSecondary)
                        }
                    }
                }
            }
        }
    }
    @ViewBuilder
    private var previewSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Preview")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            // Mock feed item
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
                // Header
                HStack(spacing: OlasDesign.Spacing.sm) {
                    Circle()
                        .fill(LinearGradient(
                            colors: [.purple, .pink],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ))
                        .frame(width: 40, height: 40)
                    VStack(alignment: .leading, spacing: 2) {
                        Text("Preview User")
                            .font(OlasDesign.Typography.bodyBold)
                            .foregroundColor(OlasDesign.Colors.text)
                        Text("2 minutes ago")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    Spacer()
                }
                // Image
                RoundedRectangle(cornerRadius: 12)
                    .fill(LinearGradient(
                        colors: getAccentGradient(),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ))
                    .aspectRatio(1, contentMode: .fit)
                    .overlay(
                        Image(systemName: "photo")
                            .font(.largeTitle)
                            .foregroundColor(.white.opacity(0.5))
                    )
                // Actions
                HStack(spacing: OlasDesign.Spacing.lg) {
                    Button(action: {}) {
                        Image(systemName: "heart")
                            .font(.title3)
                            .foregroundColor(getAccentColor())
                    }
                    Button(action: {}) {
                        Image(systemName: "bubble.left")
                            .font(.title3)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    Button(action: {}) {
                        Image(systemName: "bolt")
                            .font(.title3)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    Spacer()
                    Button(action: {}) {
                        Image(systemName: "square.and.arrow.up")
                            .font(.title3)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                }
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(16)
        }
    }
    // MARK: - Methods
    private func getAccentColor() -> Color {
        switch accentColor {
        case "Purple": return .purple
        case "Blue": return .blue
        case "Pink": return .pink
        case "Orange": return .orange
        case "Green": return .green
        case "Red": return .red
        default: return .purple
        }
    }
    private func getAccentGradient() -> [Color] {
        switch accentColor {
        case "Purple": return [.purple, .pink]
        case "Blue": return [.blue, .cyan]
        case "Pink": return [.pink, .red]
        case "Orange": return [.orange, .yellow]
        case "Green": return [.green, .mint]
        case "Red": return [.red, .orange]
        default: return [.purple, .pink]
        }
    }
    private func changeAppIcon(to iconName: String) {
        #if os(iOS)
        guard UIApplication.shared.supportsAlternateIcons else { return }
        let alternateIconName: String? = iconName == "Default" ? nil : iconName
        UIApplication.shared.setAlternateIconName(alternateIconName) { error in
            if let error = error {
                print("Error changing app icon: \(error.localizedDescription)")
            }
        }
        #endif
    }
}
// MARK: - Preview
struct ThemeSettingsView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            ThemeSettingsView()
        }
    }
}
</file>

<file path="Olas/Views/Stories/CreateStoryView.swift">
import SwiftUI
import PhotosUI
struct CreateStoryView: View {
    @ObservedObject var storiesManager: StoriesManager
    @Environment(\.dismiss) private var dismiss
    @State private var selectedImage: UIImage?
    @State private var storyText = ""
    @State private var showingImagePicker = false
    @State private var showingCamera = false
    @State private var isUploading = false
    @State private var selectedBackground = 0
    let gradientBackgrounds: [LinearGradient] = [
        LinearGradient(colors: [.purple, .pink], startPoint: .topLeading, endPoint: .bottomTrailing),
        LinearGradient(colors: [.blue, .cyan], startPoint: .topLeading, endPoint: .bottomTrailing),
        LinearGradient(colors: [.orange, .red], startPoint: .topLeading, endPoint: .bottomTrailing),
        LinearGradient(colors: [.green, .mint], startPoint: .topLeading, endPoint: .bottomTrailing),
        LinearGradient(colors: [.indigo, .purple], startPoint: .topLeading, endPoint: .bottomTrailing),
        LinearGradient(colors: [.yellow, .orange], startPoint: .topLeading, endPoint: .bottomTrailing)
    ]
    var body: some View {
        NavigationStack {
            ZStack {
                // Background
                if selectedImage != nil {
                    Color.black.ignoresSafeArea()
                } else {
                    gradientBackgrounds[selectedBackground]
                        .ignoresSafeArea()
                }
                VStack {
                    // Content area
                    ZStack {
                        if let image = selectedImage {
                            // Show selected image
                            Image(uiImage: image)
                                .resizable()
                                .aspectRatio(contentMode: .fit)
                                .frame(maxWidth: .infinity, maxHeight: .infinity)
                        } else {
                            // Text-only story
                            VStack {
                                Spacer()
                                TextField("What's on your mind?", text: $storyText, axis: .vertical)
                                    .font(.system(size: 28, weight: .medium))
                                    .foregroundColor(.white)
                                    .multilineTextAlignment(.center)
                                    .padding()
                                    .background(
                                        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                                            .fill(Color.black.opacity(0.3))
                                    )
                                    .padding()
                                Spacer()
                            }
                        }
                        // Text overlay on image
                        if selectedImage != nil && !storyText.isEmpty {
                            VStack {
                                Spacer()
                                Text(storyText)
                                    .font(.system(size: 24, weight: .medium))
                                    .foregroundColor(.white)
                                    .multilineTextAlignment(.center)
                                    .padding()
                                    .background(
                                        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                            .fill(Color.black.opacity(0.6))
                                    )
                                    .padding()
                                Spacer()
                                    .frame(height: 100)
                            }
                        }
                    }
                    // Bottom controls
                    VStack(spacing: OlasDesign.Spacing.md) {
                        if selectedImage == nil {
                            // Background selector for text-only stories
                            ScrollView(.horizontal, showsIndicators: false) {
                                HStack(spacing: OlasDesign.Spacing.sm) {
                                    ForEach(0..<gradientBackgrounds.count, id: \.self) { index in
                                        Circle()
                                            .fill(gradientBackgrounds[index])
                                            .frame(width: 40, height: 40)
                                            .overlay(
                                                Circle()
                                                    .stroke(Color.white, lineWidth: selectedBackground == index ? 3 : 0)
                                            )
                                            .onTapGesture {
                                                withAnimation(.spring(response: 0.3)) {
                                                    selectedBackground = index
                                                }
                                                OlasDesign.Haptic.selection()
                                            }
                                    }
                                }
                                .padding(.horizontal)
                            }
                        }
                        // Action buttons
                        HStack(spacing: OlasDesign.Spacing.lg) {
                            // Photo picker
                            Button {
                                showingImagePicker = true
                            } label: {
                                VStack(spacing: 4) {
                                    Image(systemName: "photo.fill")
                                        .font(.system(size: 24))
                                    Text("Gallery")
                                        .font(.caption)
                                }
                                .foregroundColor(.white)
                            }
                            // Camera
                            Button {
                                showingCamera = true
                            } label: {
                                VStack(spacing: 4) {
                                    Image(systemName: "camera.fill")
                                        .font(.system(size: 24))
                                    Text("Camera")
                                        .font(.caption)
                                }
                                .foregroundColor(.white)
                            }
                            if selectedImage != nil {
                                // Remove image
                                Button {
                                    withAnimation {
                                        selectedImage = nil
                                        storyText = ""
                                    }
                                } label: {
                                    VStack(spacing: 4) {
                                        Image(systemName: "xmark.circle.fill")
                                            .font(.system(size: 24))
                                        Text("Remove")
                                            .font(.caption)
                                    }
                                    .foregroundColor(.white)
                                }
                            }
                        }
                        .padding()
                        .background(
                            Capsule()
                                .fill(Color.black.opacity(0.5))
                        )
                    }
                    .padding(.bottom, 30)
                }
            }
            .navigationTitle("Create Story")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(.white)
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Share") {
                        Task {
                            await shareStory()
                        }
                    }
                    .foregroundColor(.white)
                    .fontWeight(.semibold)
                    .disabled(selectedImage == nil && storyText.isEmpty)
                    .opacity((selectedImage == nil && storyText.isEmpty) ? 0.5 : 1)
                }
            }
            .toolbarBackground(.hidden, for: .navigationBar)
        }
        .sheet(isPresented: $showingImagePicker) {
            ImagePicker(image: $selectedImage)
        }
        .sheet(isPresented: $showingCamera) {
            CameraView(capturedImage: $selectedImage)
        }
        .overlay {
            if isUploading {
                ZStack {
                    Color.black.opacity(0.7)
                        .ignoresSafeArea()
                    VStack(spacing: OlasDesign.Spacing.md) {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
                            .scaleEffect(1.5)
                        Text("Sharing your story...")
                            .font(OlasDesign.Typography.body)
                            .foregroundColor(.white)
                    }
                    .padding(OlasDesign.Spacing.xl)
                    .background(
                        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                            .fill(Color.black.opacity(0.8))
                    )
                }
            }
        }
    }
    private func shareStory() async {
        isUploading = true
        defer { isUploading = false }
        // Convert image to data and create story
        if let selectedImage = selectedImage,
           let imageData = selectedImage.jpegData(compressionQuality: 0.8) {
            do {
                try await storiesManager.createStory(
                    with: imageData,
                    caption: storyText.isEmpty ? "" : storyText
                )
            } catch {
                print("Failed to create story: \(error)")
            }
        }
        dismiss()
    }
}
// MARK: - Image Picker
struct ImagePicker: UIViewControllerRepresentable {
    @Binding var image: UIImage?
    @Environment(\.dismiss) private var dismiss
    func makeUIViewController(context: Context) -> PHPickerViewController {
        var config = PHPickerConfiguration()
        config.filter = .images
        config.selectionLimit = 1
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = context.coordinator
        return picker
    }
    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    class Coordinator: NSObject, PHPickerViewControllerDelegate {
        let parent: ImagePicker
        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            parent.dismiss()
            guard let provider = results.first?.itemProvider else { return }
            if provider.canLoadObject(ofClass: UIImage.self) {
                provider.loadObject(ofClass: UIImage.self) { image, _ in
                    DispatchQueue.main.async {
                        self.parent.image = image as? UIImage
                    }
                }
            }
        }
    }
}
// MARK: - Camera View
struct CameraView: UIViewControllerRepresentable {
    @Binding var capturedImage: UIImage?
    @Environment(\.dismiss) private var dismiss
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.sourceType = .camera
        picker.delegate = context.coordinator
        return picker
    }
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: CameraView
        init(_ parent: CameraView) {
            self.parent = parent
        }
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let image = info[.originalImage] as? UIImage {
                parent.capturedImage = image
            }
            parent.dismiss()
        }
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.dismiss()
        }
    }
}
</file>

<file path="Olas/Views/Stories/OlasStoriesView.swift">
import SwiftUI
import NDKSwift
// Wrapper for Int to make it Identifiable
struct StoryIndexWrapper: Identifiable {
    let id: Int
    init(_ index: Int) {
        self.id = index
    }
}
struct OlasStoriesView: View {
    @ObservedObject var storiesManager: StoriesManager
    @State private var selectedStoryWrapper: StoryIndexWrapper?
    @State private var showCreateStory = false
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: OlasDesign.Spacing.sm) {
                // Add Story button
                AddStoryButton(showCreateStory: $showCreateStory)
                // User stories
                ForEach(storiesManager.userStories.flatMap { $0.stories }.indices, id: \.self) { index in
                    let allStories = storiesManager.userStories.flatMap { $0.stories }
                    if index < allStories.count {
                        let story = allStories[index]
                        // Convert Story to UserStory for compatibility
                        let userStory = UserStory(
                            user: StoryUser(
                                pubkey: story.authorPubkey,
                                displayName: storiesManager.userStories.first { $0.authorPubkey == story.authorPubkey }?.authorProfile?.name ?? "User",
                                avatarURL: storiesManager.userStories.first { $0.authorPubkey == story.authorPubkey }?.authorProfile?.picture
                            ),
                            imageURL: story.mediaURLs.first,
                            text: story.content,
                            timestamp: story.timestamp,
                            isViewed: storiesManager.isStoryViewed(story.id)
                        )
                        StoryCircle(
                            story: userStory,
                            index: index,
                            selectedStoryIndex: Binding(
                                get: { selectedStoryWrapper?.id == index ? index : nil },
                            set: { _ in selectedStoryWrapper = StoryIndexWrapper(index) }
                        )
                    )
                    }
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
        }
        .frame(height: 100)
        .fullScreenCover(item: $selectedStoryWrapper) { wrapper in
            let allStories = storiesManager.userStories.flatMap { collection in
                collection.stories.map { story in
                    UserStory(
                        user: StoryUser(
                            pubkey: story.authorPubkey,
                            displayName: collection.authorProfile?.name ?? "User",
                            avatarURL: collection.authorProfile?.picture
                        ),
                        imageURL: story.mediaURLs.first,
                        text: story.content,
                        timestamp: story.timestamp,
                        isViewed: storiesManager.isStoryViewed(story.id)
                    )
                }
            }
            OlasStoryViewerView(
                stories: allStories,
                initialIndex: wrapper.id,
                onDismiss: {
                    selectedStoryWrapper = nil
                }
            )
        }
        .sheet(isPresented: $showCreateStory) {
            CreateStoryView(storiesManager: storiesManager)
        }
    }
}
// MARK: - Add Story Button
struct AddStoryButton: View {
    @Binding var showCreateStory: Bool
    @State private var isPressed = false
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.xs) {
            ZStack {
                // User avatar placeholder
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [
                                OlasDesign.Colors.primary.opacity(0.2),
                                OlasDesign.Colors.primary.opacity(0.1)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 70, height: 70)
                // Plus icon
                ZStack {
                    Circle()
                        .fill(OlasDesign.Colors.primary)
                        .frame(width: 24, height: 24)
                    Image(systemName: "plus")
                        .font(.system(size: 14, weight: .bold))
                        .foregroundColor(.white)
                }
                .offset(x: 25, y: 25)
            }
            .scaleEffect(isPressed ? 0.95 : 1)
            Text("Your Story")
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.text)
        }
        .onTapGesture {
            showCreateStory = true
            OlasDesign.Haptic.selection()
        }
        .onLongPressGesture(minimumDuration: .infinity, maximumDistance: .infinity, pressing: { pressing in
            withAnimation(.easeInOut(duration: 0.1)) {
                isPressed = pressing
            }
        }, perform: {})
    }
}
// MARK: - Story Circle
struct StoryCircle: View {
    let story: UserStory
    let index: Int
    @Binding var selectedStoryIndex: Int?
    @State private var isPressed = false
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.xs) {
            ZStack {
                // Gradient ring for unviewed stories
                if !story.isViewed {
                    Circle()
                        .stroke(
                            LinearGradient(
                                colors: [
                                    Color.purple,
                                    Color.pink,
                                    Color.orange
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 3
                        )
                        .frame(width: 74, height: 74)
                } else {
                    Circle()
                        .stroke(Color.gray.opacity(0.3), lineWidth: 2)
                        .frame(width: 74, height: 74)
                }
                // User avatar
                if let avatarURL = story.user.avatarURL {
                    AsyncImage(url: URL(string: avatarURL)) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: 66, height: 66)
                            .clipShape(Circle())
                    } placeholder: {
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: [
                                        Color.gray.opacity(0.3),
                                        Color.gray.opacity(0.1)
                                    ],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 66, height: 66)
                    }
                } else {
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color(hue: Double(story.user.pubkey.prefix(6).hashValue % 360) / 360, saturation: 0.5, brightness: 0.8),
                                    Color(hue: Double(story.user.pubkey.suffix(6).hashValue % 360) / 360, saturation: 0.5, brightness: 0.6)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 66, height: 66)
                        .overlay(
                            Text(story.user.displayName.prefix(1).uppercased())
                                .font(.system(size: 24, weight: .semibold))
                                .foregroundColor(.white)
                        )
                }
            }
            .scaleEffect(isPressed ? 0.95 : 1)
            Text(story.user.displayName)
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.text)
                .lineLimit(1)
                .frame(width: 70)
        }
        .onTapGesture {
            selectedStoryIndex = index
            OlasDesign.Haptic.selection()
        }
        .onLongPressGesture(minimumDuration: .infinity, maximumDistance: .infinity, pressing: { pressing in
            withAnimation(.easeInOut(duration: 0.1)) {
                isPressed = pressing
            }
        }, perform: {})
    }
}
// MARK: - Story Viewer
struct OlasStoryViewerView: View {
    let stories: [UserStory]
    let initialIndex: Int
    let onDismiss: () -> Void
    @State private var currentIndex: Int
    @State private var dragOffset: CGSize = .zero
    @GestureState private var isDragging = false
    init(stories: [UserStory], initialIndex: Int, onDismiss: @escaping () -> Void) {
        self.stories = stories
        self.initialIndex = initialIndex
        self.onDismiss = onDismiss
        self._currentIndex = State(initialValue: initialIndex)
    }
    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()
            if currentIndex < stories.count {
                StoryView(
                    story: stories[currentIndex],
                    onNext: {
                        if currentIndex < stories.count - 1 {
                            withAnimation(.easeInOut(duration: 0.3)) {
                                currentIndex += 1
                            }
                        } else {
                            onDismiss()
                        }
                    },
                    onPrevious: {
                        if currentIndex > 0 {
                            withAnimation(.easeInOut(duration: 0.3)) {
                                currentIndex -= 1
                            }
                        }
                    },
                    onDismiss: onDismiss
                )
                .transition(.asymmetric(
                    insertion: .move(edge: .trailing),
                    removal: .move(edge: .leading)
                ))
            }
        }
        .offset(y: dragOffset.height)
        .scaleEffect(isDragging ? 0.9 : 1)
        .animation(.interactiveSpring(), value: dragOffset)
        .gesture(
            DragGesture()
                .updating($isDragging) { _, state, _ in
                    state = true
                }
                .onChanged { value in
                    dragOffset = value.translation
                }
                .onEnded { value in
                    if value.translation.height > 100 {
                        onDismiss()
                    } else {
                        withAnimation(.spring()) {
                            dragOffset = .zero
                        }
                    }
                }
        )
    }
}
// MARK: - Individual Story View
struct StoryView: View {
    let story: UserStory
    let onNext: () -> Void
    let onPrevious: () -> Void
    let onDismiss: () -> Void
    @State private var progress: Double = 0
    @State private var timer: Timer?
    @State private var isPaused = false
    let storyDuration: TimeInterval = 5.0
    var body: some View {
        ZStack {
            // Story content
            if let imageURL = story.imageURL {
                AsyncImage(url: URL(string: imageURL)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } placeholder: {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                }
            }
            // Overlay content
            VStack {
                // Progress bars and header
                VStack(spacing: OlasDesign.Spacing.sm) {
                    // Progress indicator
                    ProgressBar(progress: progress)
                        .frame(height: 2)
                        .padding(.horizontal)
                    // Header
                    HStack {
                        // User info
                        HStack(spacing: OlasDesign.Spacing.sm) {
                            if let avatarURL = story.user.avatarURL {
                                AsyncImage(url: URL(string: avatarURL)) { image in
                                    image
                                        .resizable()
                                        .aspectRatio(contentMode: .fill)
                                        .frame(width: 32, height: 32)
                                        .clipShape(Circle())
                                } placeholder: {
                                    Circle()
                                        .fill(Color.gray.opacity(0.3))
                                        .frame(width: 32, height: 32)
                                }
                            }
                            VStack(alignment: .leading, spacing: 2) {
                                Text(story.user.displayName)
                                    .font(OlasDesign.Typography.bodyMedium)
                                    .foregroundColor(.white)
                                Text(formatTimeAgo(story.timestamp))
                                    .font(OlasDesign.Typography.caption)
                                    .foregroundColor(.white.opacity(0.8))
                            }
                        }
                        Spacer()
                        // Close button
                        Button(action: onDismiss) {
                            Image(systemName: "xmark")
                                .font(.system(size: 20))
                                .foregroundColor(.white)
                                .padding(8)
                                .background(Circle().fill(Color.black.opacity(0.3)))
                        }
                    }
                    .padding(.horizontal)
                }
                .padding(.top, 50)
                Spacer()
                // Story text if available
                if let text = story.text {
                    Text(text)
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(.white)
                        .multilineTextAlignment(.center)
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                .fill(Color.black.opacity(0.6))
                        )
                        .padding()
                }
                Spacer()
            }
            // Tap areas
            HStack(spacing: 0) {
                // Previous
                Color.clear
                    .contentShape(Rectangle())
                    .onTapGesture {
                        onPrevious()
                    }
                // Pause/Play
                Color.clear
                    .frame(width: 100)
                    .contentShape(Rectangle())
                    .onLongPressGesture(minimumDuration: 0.1, maximumDistance: .infinity, pressing: { pressing in
                        isPaused = pressing
                    }, perform: {})
                // Next
                Color.clear
                    .contentShape(Rectangle())
                    .onTapGesture {
                        onNext()
                    }
            }
        }
        .onAppear {
            startTimer()
        }
        .onDisappear {
            timer?.invalidate()
        }
    }
    private func startTimer() {
        timer?.invalidate()
        progress = 0
        timer = Timer.scheduledTimer(withTimeInterval: 0.05, repeats: true) { _ in
            if !isPaused {
                withAnimation(.linear(duration: 0.05)) {
                    progress += 0.05 / storyDuration
                }
                if progress >= 1 {
                    timer?.invalidate()
                    onNext()
                }
            }
        }
    }
    private func formatTimeAgo(_ date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}
// MARK: - Progress Bar
struct ProgressBar: View {
    let progress: Double
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                Rectangle()
                    .fill(Color.white.opacity(0.3))
                Rectangle()
                    .fill(Color.white)
                    .frame(width: geometry.size.width * CGFloat(progress))
            }
        }
    }
}
// Removed duplicate StoriesManager and models - using the one from Models/StoriesManager.swift
// MARK: - Models
struct UserStory: Identifiable {
    let id = UUID()
    let user: StoryUser
    let imageURL: String?
    let text: String?
    let timestamp: Date
    let isViewed: Bool
}
struct StoryUser {
    let pubkey: String
    let displayName: String
    let avatarURL: String?
}
</file>

<file path="Olas/Views/Stories/StoriesContainerView.swift">
import SwiftUI
import NDKSwift
struct StoriesContainerView: View {
    @Environment(NostrManager.self) private var nostrManager
    @StateObject private var storiesManager: StoriesManager
    init() {
        // Initialize StoriesManager with a temporary placeholder
        // We'll update it with the actual NostrManager in onAppear
        let tempManager = NostrManager()
        self._storiesManager = StateObject(wrappedValue: StoriesManager(nostrManager: tempManager))
    }
    var body: some View {
        VStack(spacing: 0) {
            if storiesManager.userStories.isEmpty && !storiesManager.isLoading {
                // Empty state
                emptyStoriesView
            } else {
                OlasStoriesView(storiesManager: storiesManager)
            }
        }
        .frame(height: 120)
        .background(OlasDesign.Colors.background)
        .onAppear {
            storiesManager.startObservingStories()
        }
    }
    private var emptyStoriesView: some View {
        VStack(spacing: OlasDesign.Spacing.sm) {
            Spacer()
            HStack(spacing: OlasDesign.Spacing.md) {
                // Add story button
                AddStoryButton(showCreateStory: .constant(false))
                    .disabled(true)
                    .opacity(0.7)
                // Placeholder circles
                ForEach(0..<3, id: \.self) { _ in
                    VStack(spacing: OlasDesign.Spacing.xs) {
                        Circle()
                            .fill(OlasDesign.Colors.surface)
                            .frame(width: 70, height: 70)
                        RoundedRectangle(cornerRadius: 4)
                            .fill(OlasDesign.Colors.surface)
                            .frame(width: 50, height: 10)
                    }
                }
                Spacer()
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            Spacer()
        }
    }
}
</file>

<file path="Olas/Views/Stories/StoriesView.swift">
import SwiftUI
import NDKSwift
#if os(iOS)
import UIKit
#endif
struct StoriesView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var stories: [Story] = []
    @State private var selectedStory: Story?
    @State private var showCreateStory = false
    @State private var isLoading = true
    @State private var hasLoadedStories = false
    @State private var storiesManager: StoriesManager?
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: OlasDesign.Spacing.md) {
                // Add Story button
                addStoryButton
                // Stories
                ForEach(stories) { story in
                    StoryCircleView(story: story) {
                        selectedStory = story
                    }
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.sm)
        }
        .frame(height: 100)
        .background(
            LinearGradient(
                colors: [
                    OlasDesign.Colors.background,
                    OlasDesign.Colors.background.opacity(0.95)
                ],
                startPoint: .top,
                endPoint: .bottom
            )
        )
        .onAppear {
            if storiesManager == nil {
                storiesManager = StoriesManager(nostrManager: nostrManager)
            }
        }
        .task {
            if !hasLoadedStories {
                hasLoadedStories = true
                await loadStories()
            }
        }
        .fullScreenCover(item: $selectedStory) { story in
            StoryViewerView(stories: stories, initialStory: story)
                .environment(nostrManager)
                .environmentObject(appState)
        }
        .sheet(isPresented: $showCreateStory) {
            if let storiesManager = storiesManager {
                CreateStoryView(storiesManager: storiesManager)
                    .environment(nostrManager)
                    .environmentObject(appState)
            }
        }
    }
    private var addStoryButton: some View {
        Button {
            showCreateStory = true
            OlasDesign.Haptic.selection()
        } label: {
            VStack(spacing: OlasDesign.Spacing.xs) {
                ZStack {
                    // User avatar
                    if let profilePicture = nostrManager.currentUserProfile?.picture {
                        AsyncImage(url: URL(string: profilePicture)) { image in
                            image
                                .resizable()
                                .scaledToFill()
                        } placeholder: {
                            Color.gray.opacity(0.3)
                        }
                        .frame(width: 70, height: 70)
                        .clipShape(Circle())
                    } else {
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: OlasDesign.Colors.primaryGradient,
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 70, height: 70)
                            .overlay(
                                Text(getUserInitial())
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            )
                    }
                    // Plus icon
                    Circle()
                        .fill(OlasDesign.Colors.primary)
                        .frame(width: 24, height: 24)
                        .overlay(
                            Image(systemName: "plus")
                                .font(.system(size: 14, weight: .bold))
                                .foregroundColor(.white)
                        )
                        .overlay(
                            Circle()
                                .stroke(OlasDesign.Colors.background, lineWidth: 2)
                        )
                        .offset(x: 25, y: 25)
                }
                Text("Your Story")
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.text)
                    .lineLimit(1)
            }
        }
    }
    private func getUserInitial() -> String {
        // Get current user's profile from nostrManager
        if let currentUser = nostrManager.currentUserProfile {
            if let name = currentUser.name, !name.isEmpty {
                return String(name.prefix(1)).uppercased()
            } else if let displayName = currentUser.displayName, !displayName.isEmpty {
                return String(displayName.prefix(1)).uppercased()
            }
        }
        // Fallback to first character of pubkey if no profile
        if let session = nostrManager.authManager.activeSession {
            return String(session.pubkey.prefix(1)).uppercased()
        }
        return "?"
    }
    private func loadStories() async {
        guard let ndk = nostrManager.ndk else { return }
        isLoading = true
        hasLoadedStories = true
        // Stories are kind 30024 events (NIP-51 highlights)
        let filter = NDKFilter(
            kinds: [30024],
            since: Timestamp(Int64(Date().addingTimeInterval(-86400).timeIntervalSince1970)) // Last 24 hours
        )
        // Create a data source to fetch events
        let dataSource = ndk.dataSource(filter: filter)
        // Collect events until EOSE
        var storyEvents: [NDKEvent] = []
        for await event in dataSource.events {
            storyEvents.append(event)
            // Check if we have enough or should stop
            if storyEvents.count > 100 { break }
        }
        // Convert to Story models
        var loadedStories: [Story] = []
        for event in storyEvents {
            // Extract story data from event
            let story = Story(from: event)
            loadedStories.append(story)
        }
        // Sort by timestamp
        loadedStories.sort { $0.timestamp > $1.timestamp }
        await MainActor.run {
            self.stories = loadedStories
            self.isLoading = false
        }
        // Load profiles for story authors
        await loadProfiles(for: loadedStories)
    }
    private func loadProfiles(for stories: [Story]) async {
        guard let profileManager = nostrManager.ndk?.profileManager else { return }
        for story in stories {
            Task {
                for await profile in await profileManager.observe(for: story.authorPubkey, maxAge: 3600) {
                    if let profile = profile {
                        await MainActor.run {
                            if let index = self.stories.firstIndex(where: { $0.id == story.id }) {
                                self.stories[index].authorProfile = profile
                            }
                        }
                    }
                    break
                }
            }
        }
    }
}
struct StoryCircleView: View {
    let story: Story
    let action: () -> Void
    @State private var hasViewed = false
    var body: some View {
        Button(action: action) {
            VStack(spacing: OlasDesign.Spacing.xs) {
                ZStack {
                    // Gradient ring
                    Circle()
                        .stroke(
                            hasViewed ?
                            LinearGradient(
                                colors: [Color.gray.opacity(0.5), Color.gray.opacity(0.3)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ) :
                            LinearGradient(
                                colors: OlasDesign.Colors.primaryGradient + [Color(hex: "FFD54F")],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 3
                        )
                        .frame(width: 74, height: 74)
                    // Avatar
                    if let picture = story.authorProfile?.picture {
                        AsyncImage(url: URL(string: picture)) { image in
                            image
                                .resizable()
                                .scaledToFill()
                        } placeholder: {
                            Color.gray.opacity(0.3)
                        }
                        .frame(width: 66, height: 66)
                        .clipShape(Circle())
                    } else {
                        Circle()
                            .fill(Color.gray.opacity(0.3))
                            .frame(width: 66, height: 66)
                            .overlay(
                                Text(String(story.authorProfile?.name?.first ?? "?").uppercased())
                                    .font(.title3)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            )
                    }
                }
                Text(story.authorProfile?.name ?? "Loading...")
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.text)
                    .lineLimit(1)
                    .frame(width: 70)
            }
        }
    }
}
// MARK: - Story Model
struct Story: Identifiable {
    let id: String
    let authorPubkey: String
    var authorProfile: NDKUserProfile?
    let content: String
    let mediaURLs: [String]
    let timestamp: Date
    let event: NDKEvent
    init(from event: NDKEvent) {
        self.id = event.id
        self.authorPubkey = event.pubkey
        self.content = event.content
        self.mediaURLs = event.imageURLs
        self.timestamp = Date(timeIntervalSince1970: TimeInterval(event.createdAt))
        self.event = event
    }
}
// MARK: - Story Viewer
struct StoryViewerView: View {
    let stories: [Story]
    let initialStory: Story
    @Environment(\.dismiss) private var dismiss
    @State private var currentIndex: Int
    @State private var progress: Double = 0
    @State private var timer: Timer?
    @State private var isPaused = false
    init(stories: [Story], initialStory: Story) {
        self.stories = stories
        self.initialStory = initialStory
        self._currentIndex = State(initialValue: stories.firstIndex(where: { $0.id == initialStory.id }) ?? 0)
    }
    var body: some View {
        ZStack {
            // Background
            Color.black
                .ignoresSafeArea()
            // Story content
            if currentIndex < stories.count {
                StoryContentView(story: stories[currentIndex])
                    .transition(.asymmetric(
                        insertion: .move(edge: .trailing),
                        removal: .move(edge: .leading)
                    ))
            }
            // Progress bars
            VStack {
                HStack(spacing: 4) {
                    ForEach(0..<stories.count, id: \.self) { index in
                        GeometryReader { geometry in
                            ZStack(alignment: .leading) {
                                Rectangle()
                                    .fill(Color.white.opacity(0.3))
                                    .frame(height: 3)
                                Rectangle()
                                    .fill(Color.white)
                                    .frame(width: progressWidth(for: index, totalWidth: geometry.size.width), height: 3)
                            }
                        }
                        .frame(height: 3)
                    }
                }
                .padding(.horizontal)
                .padding(.top, 50)
                Spacer()
            }
            // Close button
            VStack {
                HStack {
                    Spacer()
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.white)
                            .padding()
                            .background(Circle().fill(Color.black.opacity(0.5)))
                    }
                    .padding()
                }
                Spacer()
            }
            // Tap areas
            HStack(spacing: 0) {
                // Previous
                Color.clear
                    .contentShape(Rectangle())
                    .onTapGesture {
                        previousStory()
                    }
                // Next
                Color.clear
                    .contentShape(Rectangle())
                    .onTapGesture {
                        nextStory()
                    }
            }
            .gesture(
                DragGesture()
                    .onChanged { _ in
                        isPaused = true
                    }
                    .onEnded { value in
                        isPaused = false
                        if value.translation.height > 100 {
                            dismiss()
                        }
                    }
            )
        }
        .onAppear {
            startTimer()
        }
        .onDisappear {
            timer?.invalidate()
        }
    }
    private func progressWidth(for index: Int, totalWidth: CGFloat) -> CGFloat {
        if index < currentIndex {
            return totalWidth
        } else if index == currentIndex {
            return totalWidth * progress
        } else {
            return 0
        }
    }
    private func startTimer() {
        progress = 0
        timer?.invalidate()
        timer = Timer.scheduledTimer(withTimeInterval: 0.05, repeats: true) { _ in
            if !isPaused {
                withAnimation(.linear(duration: 0.05)) {
                    progress += 0.01
                    if progress >= 1 {
                        nextStory()
                    }
                }
            }
        }
    }
    private func nextStory() {
        withAnimation {
            if currentIndex < stories.count - 1 {
                currentIndex += 1
                startTimer()
            } else {
                dismiss()
            }
        }
    }
    private func previousStory() {
        withAnimation {
            if currentIndex > 0 {
                currentIndex -= 1
                startTimer()
            }
        }
    }
}
struct StoryContentView: View {
    let story: Story
    var body: some View {
        ZStack {
            // Media
            if let firstImage = story.mediaURLs.first {
                AsyncImage(url: URL(string: firstImage)) { image in
                    image
                        .resizable()
                        .scaledToFill()
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } placeholder: {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .scaleEffect(1.5)
                }
            } else {
                // Text-only story
                LinearGradient(
                    colors: OlasDesign.Colors.primaryGradient,
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            }
            // Content overlay
            VStack {
                // Author info
                HStack(spacing: OlasDesign.Spacing.sm) {
                    OlasAvatar(
                        url: story.authorProfile?.picture,
                        size: 40,
                        pubkey: story.authorPubkey
                    )
                    VStack(alignment: .leading, spacing: 2) {
                        Text(story.authorProfile?.displayName ?? story.authorProfile?.name ?? "Loading...")
                            .font(OlasDesign.Typography.bodyBold)
                            .foregroundColor(.white)
                        Text(RelativeTimeFormatter.format(story.timestamp))
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(.white.opacity(0.8))
                    }
                    Spacer()
                }
                .padding()
                .background(
                    LinearGradient(
                        colors: [Color.black.opacity(0.6), Color.clear],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )
                Spacer()
                // Caption
                if !story.content.isEmpty {
                    Text(story.content)
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(.white)
                        .multilineTextAlignment(.center)
                        .padding()
                        .background(
                            Color.black.opacity(0.6)
                                .blur(radius: 20)
                        )
                        .padding()
                }
            }
        }
        .ignoresSafeArea()
    }
}
// MARK: - Create Story View
// Moved to CreateStoryView.swift
/*
struct CreateStoryView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(NostrManager.self) private var nostrManager
    @State private var selectedImage: UIImage?
    @State private var caption = ""
    @State private var isPosting = false
    @State private var showingImagePicker = false
    @State private var showingCamera = false
    var body: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                if let image = selectedImage {
                    // Preview
                    VStack {
                        Image(uiImage: image)
                            .resizable()
                            .scaledToFit()
                            .frame(maxHeight: 400)
                            .cornerRadius(OlasDesign.CornerRadius.lg)
                        TextField("Add a caption...", text: $caption)
                            .textFieldStyle(PlainTextFieldStyle())
                            .font(OlasDesign.Typography.body)
                            .foregroundColor(OlasDesign.Colors.text)
                            .padding()
                            .background(
                                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                    .fill(OlasDesign.Colors.surface)
                            )
                            .padding(.horizontal)
                        Spacer()
                    }
                    .padding(.top)
                } else {
                    // Image selection
                    VStack(spacing: OlasDesign.Spacing.xl) {
                        Spacer()
                        Image(systemName: "photo.on.rectangle.angled")
                            .font(.system(size: 80))
                            .foregroundStyle(
                                LinearGradient(
                                    colors: OlasDesign.Colors.primaryGradient,
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                        Text("Create Your Story")
                            .font(OlasDesign.Typography.title)
                            .foregroundStyle(OlasDesign.Colors.text)
                        VStack(spacing: OlasDesign.Spacing.md) {
                            Button {
                                showingCamera = true
                            } label: {
                                Label("Take Photo", systemImage: "camera.fill")
                                    .font(OlasDesign.Typography.bodyMedium)
                                    .foregroundStyle(.white)
                                    .frame(maxWidth: .infinity)
                                    .padding()
                                    .background(
                                        LinearGradient(
                                            colors: OlasDesign.Colors.primaryGradient,
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        )
                                    )
                                    .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md))
                            }
                            Button {
                                showingImagePicker = true
                            } label: {
                                Label("Choose from Library", systemImage: "photo.fill")
                                    .font(OlasDesign.Typography.bodyMedium)
                                    .foregroundStyle(OlasDesign.Colors.text)
                                    .frame(maxWidth: .infinity)
                                    .padding()
                                    .background(
                                        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                            .fill(OlasDesign.Colors.surface)
                                    )
                            }
                        }
                        .padding(.horizontal, OlasDesign.Spacing.xl)
                        Spacer()
                    }
                }
            }
            .navigationTitle("New Story")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                if selectedImage != nil {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("Share") {
                            Task {
                                await postStory()
                            }
                        }
                        .disabled(isPosting)
                        .font(OlasDesign.Typography.bodyBold)
                    }
                }
            }
            .sheet(isPresented: $showingImagePicker) {
                ImagePicker(image: $selectedImage)
            }
            .sheet(isPresented: $showingCamera) {
                CameraPicker(image: $selectedImage)
            }
            .overlay {
                if isPosting {
                    ZStack {
                        Color.black.opacity(0.5)
                            .ignoresSafeArea()
                        VStack(spacing: OlasDesign.Spacing.md) {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                .scaleEffect(1.5)
                            Text("Posting story...")
                                .font(OlasDesign.Typography.body)
                                .foregroundStyle(.white)
                        }
                        .padding(OlasDesign.Spacing.xl)
                        .background(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                                .fill(OlasDesign.Colors.surface)
                        )
                    }
                }
            }
        }
    }
    private func postStory() async {
        guard let image = selectedImage,
              let ndk = nostrManager.ndk,
              let signer = NDKAuthManager.shared.activeSigner else { return }
        isPosting = true
        do {
            // Upload image to Blossom
            let imageData = image.jpegData(compressionQuality: 0.8) ?? Data()
            let uploadedURLs = try await nostrManager.blossomManager.uploadData(
                imageData,
                mimeType: "image/jpeg"
            )
            guard let imageURL = uploadedURLs.first else {
                throw NSError(domain: "StoryUpload", code: 0, userInfo: [NSLocalizedDescriptionKey: "Failed to upload image"])
            }
            // Create story event (kind 30024)
            let tags: [[String]] = [
                ["d", "story-\(UUID().uuidString)"],
                ["title", "Story"],
                ["image", imageURL],
                ["published_at", "\(Int(Date().timeIntervalSince1970))"],
                ["expiration", "\(Int(Date().addingTimeInterval(86400).timeIntervalSince1970))"] // 24 hours
            ]
            let storyEvent = try await NDKEventBuilder(ndk: ndk)
                .kind(30024)
                .content(caption)
                .tags(tags)
                .build(signer: signer)
            _ = try await ndk.publish(storyEvent)
            OlasDesign.Haptic.success()
            dismiss()
        } catch {
            print("Failed to post story: \(error)")
            OlasDesign.Haptic.error()
        }
        isPosting = false
    }
}
*/
// MARK: - Image Pickers
// Moved to CreateStoryView.swift
/*
struct ImagePicker: UIViewControllerRepresentable {
    @Binding var image: UIImage?
    @Environment(\.dismiss) private var dismiss
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = .photoLibrary
        return picker
    }
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: ImagePicker
        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let image = info[.originalImage] as? UIImage {
                parent.image = image
            }
            parent.dismiss()
        }
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.dismiss()
        }
    }
}
*/
struct CameraPicker: UIViewControllerRepresentable {
    @Binding var image: UIImage?
    @Environment(\.dismiss) private var dismiss
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = .camera
        picker.cameraCaptureMode = .photo
        return picker
    }
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: CameraPicker
        init(_ parent: CameraPicker) {
            self.parent = parent
        }
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let image = info[.originalImage] as? UIImage {
                parent.image = image
            }
            parent.dismiss()
        }
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.dismiss()
        }
    }
}
</file>

<file path="Olas/Views/Wallet/Components/GlassmorphicComponents.swift">
import SwiftUI
// MARK: - Glassmorphic Card
struct GlassmorphicCard<Content: View>: View {
    let content: Content
    var cornerRadius: CGFloat = OlasDesign.CornerRadius.lg
    var borderGradient: [Color] = [Color.white.opacity(0.6), Color.white.opacity(0.2)]
    init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }
    var body: some View {
        content
            .background(
                ZStack {
                    // Base glass effect
                    RoundedRectangle(cornerRadius: cornerRadius)
                        .fill(.ultraThinMaterial)
                    // Gradient overlay
                    RoundedRectangle(cornerRadius: cornerRadius)
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color.white.opacity(0.05),
                                    Color.white.opacity(0.02)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                }
            )
            .overlay(
                RoundedRectangle(cornerRadius: cornerRadius)
                    .stroke(
                        LinearGradient(
                            colors: borderGradient,
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 1
                    )
            )
            .shadow(color: Color.black.opacity(0.1), radius: 10, x: 0, y: 5)
    }
}
// MARK: - Animated Balance Display
struct AnimatedBalanceDisplay: View {
    let balance: Int64
    let btcPrice: Double?
    @State private var displayedBalance: Double = 0
    @State private var animateNumbers = false
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.xs) {
            // Animated balance
            HStack(alignment: .firstTextBaseline, spacing: 4) {
                Text(formatBalance(Int64(displayedBalance)))
                    .font(.system(size: 52, weight: .bold, design: .rounded))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [OlasDesign.Colors.text, OlasDesign.Colors.text.opacity(0.8)],
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
                    .contentTransition(.numericText())
                Text("sats")
                    .font(.system(size: 20, weight: .medium, design: .rounded))
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
            }
            .scaleEffect(animateNumbers ? 1 : 0.8)
            .opacity(animateNumbers ? 1 : 0)
            // USD value with shimmer effect
            if let price = btcPrice {
                let usdValue = Double(balance) * price / 100_000_000
                ShimmerText(
                    text: " $\(String(format: "%.2f", usdValue)) USD",
                    font: .system(size: 18, weight: .medium, design: .rounded),
                    color: OlasDesign.Colors.textTertiary
                )
            }
        }
        .onAppear {
            withAnimation(.spring(response: 0.8, dampingFraction: 0.7)) {
                displayedBalance = Double(balance)
                animateNumbers = true
            }
        }
        .onChange(of: balance) { _, newValue in
            withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                displayedBalance = Double(newValue)
            }
        }
    }
    private func formatBalance(_ balance: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: balance)) ?? "0"
    }
}
// MARK: - Shimmer Text
struct ShimmerText: View {
    let text: String
    let font: Font
    let color: Color
    @State private var shimmerOffset: CGFloat = -1
    var body: some View {
        Text(text)
            .font(font)
            .foregroundStyle(color)
            .overlay(
                GeometryReader { geometry in
                    LinearGradient(
                        colors: [
                            Color.clear,
                            Color.white.opacity(0.5),
                            Color.clear
                        ],
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                    .frame(width: geometry.size.width * 0.3)
                    .offset(x: shimmerOffset * (geometry.size.width * 1.3))
                    .opacity(shimmerOffset > -0.5 && shimmerOffset < 1.5 ? 1 : 0)
                }
                .mask(
                    Text(text)
                        .font(font)
                )
            )
            .onAppear {
                withAnimation(
                    .linear(duration: 2.5)
                    .repeatForever(autoreverses: false)
                    .delay(1)
                ) {
                    shimmerOffset = 1.5
                }
            }
    }
}
// MARK: - Floating Action Button
struct FloatingActionButton: View {
    let icon: String
    let title: String
    let gradient: [Color]
    let action: () -> Void
    @State private var isPressed = false
    @State private var rippleScale: CGFloat = 0
    @State private var rippleOpacity: Double = 0.5
    var body: some View {
        Button(action: {
            // Ripple effect
            withAnimation(.easeOut(duration: 0.6)) {
                rippleScale = 2
                rippleOpacity = 0
            }
            // Reset ripple
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.6) {
                rippleScale = 0
                rippleOpacity = 0.5
            }
            OlasDesign.Haptic.impact(.medium)
            action()
        }) {
            VStack(spacing: OlasDesign.Spacing.xs) {
                ZStack {
                    // Ripple effect
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: gradient,
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 56, height: 56)
                        .scaleEffect(rippleScale)
                        .opacity(rippleOpacity)
                    // Main button
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: gradient,
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 56, height: 56)
                        .overlay(
                            Circle()
                                .stroke(Color.white.opacity(0.2), lineWidth: 1)
                        )
                        .shadow(
                            color: gradient.first?.opacity(0.4) ?? Color.clear,
                            radius: isPressed ? 5 : 10,
                            x: 0,
                            y: isPressed ? 2 : 5
                        )
                    Image(systemName: icon)
                        .font(.system(size: 24, weight: .medium))
                        .foregroundStyle(.white)
                        .rotationEffect(.degrees(isPressed ? 10 : 0))
                }
                .scaleEffect(isPressed ? 0.95 : 1)
                Text(title)
                    .font(.system(size: 12, weight: .medium))
                    .foregroundStyle(OlasDesign.Colors.text)
                    .opacity(isPressed ? 0.8 : 1)
            }
        }
        .buttonStyle(PlainButtonStyle())
        .scaleEffect(isPressed ? 0.95 : 1)
        .onLongPressGesture(
            minimumDuration: .infinity,
            maximumDistance: .infinity,
            pressing: { pressing in
                withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                    isPressed = pressing
                }
            },
            perform: {}
        )
    }
}
// MARK: - Mint Allocation Chart
struct MintAllocationChart: View {
    let mintDistribution: [(mint: String, balance: Int, percentage: Double)]
    let mintColors: [Color]
    @State private var animationProgress: Double = 0
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            // Circular chart
            ZStack {
                // Background circle
                Circle()
                    .stroke(OlasDesign.Colors.divider, lineWidth: 2)
                    .frame(width: 180, height: 180)
                // Mint segments
                ForEach(Array(mintDistribution.enumerated()), id: \.offset) { index, item in
                    MintSegment(
                        startAngle: startAngle(for: index),
                        endAngle: endAngle(for: index),
                        color: mintColors[index % mintColors.count],
                        animationProgress: animationProgress
                    )
                }
                // Center info
                VStack(spacing: 4) {
                    Text("\(mintDistribution.count)")
                        .font(.system(size: 32, weight: .bold, design: .rounded))
                        .foregroundStyle(OlasDesign.Colors.text)
                    Text("Mints")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                }
                .scaleEffect(animationProgress)
                .opacity(animationProgress)
            }
            // Legend with animated bars
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                ForEach(Array(mintDistribution.enumerated()), id: \.offset) { index, item in
                    HStack(spacing: OlasDesign.Spacing.sm) {
                        // Color indicator
                        RoundedRectangle(cornerRadius: 4)
                            .fill(mintColors[index % mintColors.count])
                            .frame(width: 16, height: 16)
                            .overlay(
                                RoundedRectangle(cornerRadius: 4)
                                    .stroke(Color.white.opacity(0.3), lineWidth: 1)
                            )
                        // Mint name
                        Text(item.mint)
                            .font(.system(size: 14, weight: .medium))
                            .foregroundStyle(OlasDesign.Colors.text)
                            .lineLimit(1)
                        Spacer()
                        // Percentage bar
                        ZStack(alignment: .leading) {
                            RoundedRectangle(cornerRadius: 2)
                                .fill(OlasDesign.Colors.divider.opacity(0.3))
                                .frame(width: 50, height: 4)
                            RoundedRectangle(cornerRadius: 2)
                                .fill(mintColors[index % mintColors.count])
                                .frame(width: 50 * item.percentage / 100 * animationProgress, height: 4)
                        }
                        // Amount
                        Text("\(String(format: "%.1f", item.percentage))%")
                            .font(.system(size: 12, weight: .medium, design: .rounded))
                            .foregroundStyle(OlasDesign.Colors.textSecondary)
                            .opacity(animationProgress)
                    }
                }
            }
        }
        .onAppear {
            withAnimation(.spring(response: 1, dampingFraction: 0.8).delay(0.2)) {
                animationProgress = 1
            }
        }
    }
    private func startAngle(for index: Int) -> Angle {
        guard !mintDistribution.isEmpty else { return .zero }
        var angle: Double = -90
        for i in 0..<index {
            angle += mintDistribution[i].percentage * 3.6
        }
        return .degrees(angle)
    }
    private func endAngle(for index: Int) -> Angle {
        guard !mintDistribution.isEmpty else { return .zero }
        var angle: Double = -90
        for i in 0...index {
            angle += mintDistribution[i].percentage * 3.6
        }
        return .degrees(angle)
    }
}
// MARK: - Mint Segment
struct MintSegment: View {
    let startAngle: Angle
    let endAngle: Angle
    let color: Color
    let animationProgress: Double
    var body: some View {
        Circle()
            .trim(from: 0, to: animationProgress)
            .stroke(
                color,
                style: StrokeStyle(
                    lineWidth: 30,
                    lineCap: .round,
                    lineJoin: .round
                )
            )
            .rotationEffect(startAngle)
            .frame(width: 160, height: 160)
            .mask(
                Circle()
                    .trim(from: 0, to: (endAngle.degrees - startAngle.degrees) / 360)
                    .stroke(style: StrokeStyle(lineWidth: 30))
                    .frame(width: 160, height: 160)
            )
    }
}
// MARK: - Premium Button
struct PremiumActionButton: View {
    let title: String
    let icon: String?
    let gradient: [Color]
    let action: () -> Void
    let isLoading: Bool
    @State private var isPressed = false
    @State private var shimmerOffset: CGFloat = -1
    init(
        title: String,
        icon: String? = nil,
        gradient: [Color] = OlasDesign.Colors.primaryGradient,
        isLoading: Bool = false,
        action: @escaping () -> Void
    ) {
        self.title = title
        self.icon = icon
        self.gradient = gradient
        self.isLoading = isLoading
        self.action = action
    }
    var body: some View {
        Button(action: {
            if !isLoading {
                OlasDesign.Haptic.impact(.medium)
                action()
            }
        }) {
            ZStack {
                // Background with gradient
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full)
                    .fill(
                        LinearGradient(
                            colors: gradient,
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .overlay(
                        // Shimmer effect
                        LinearGradient(
                            colors: [
                                Color.white.opacity(0),
                                Color.white.opacity(0.3),
                                Color.white.opacity(0)
                            ],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                        .frame(width: 60)
                        .offset(x: shimmerOffset * 200)
                        .mask(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full)
                        )
                    )
                // Content
                HStack(spacing: OlasDesign.Spacing.sm) {
                    if isLoading {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
                            .scaleEffect(0.8)
                    } else {
                        if let icon = icon {
                            Image(systemName: icon)
                                .font(.system(size: 18, weight: .medium))
                        }
                        Text(title)
                            .font(.system(size: 16, weight: .semibold))
                    }
                }
                .foregroundStyle(.white)
                .padding(.horizontal, OlasDesign.Spacing.xl)
                .padding(.vertical, OlasDesign.Spacing.md)
            }
            .scaleEffect(isPressed ? 0.95 : 1)
            .shadow(
                color: gradient.first?.opacity(0.4) ?? Color.clear,
                radius: isPressed ? 5 : 10,
                x: 0,
                y: isPressed ? 2 : 5
            )
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(isLoading)
        .onLongPressGesture(
            minimumDuration: .infinity,
            maximumDistance: .infinity,
            pressing: { pressing in
                withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                    isPressed = pressing
                }
            },
            perform: {}
        )
        .onAppear {
            withAnimation(
                .linear(duration: 3)
                .repeatForever(autoreverses: false)
            ) {
                shimmerOffset = 1
            }
        }
    }
}
</file>

<file path="Olas/Views/Wallet/Components/ModernStatCard.swift">
import SwiftUI
struct ModernStatCard: View {
    let icon: String
    let value: String
    let label: String
    let gradient: [Color]
    @State private var isAnimating = false
    var body: some View {
        VStack(spacing: 8) {
            // Icon with gradient background
            ZStack {
                Circle()
                    .fill(
                        LinearGradient(
                            colors: gradient.map { $0.opacity(0.2) },
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 44, height: 44)
                    .overlay(
                        Circle()
                            .stroke(
                                LinearGradient(
                                    colors: gradient,
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ),
                                lineWidth: 1.5
                            )
                            .opacity(0.3)
                    )
                Image(systemName: icon)
                    .font(.system(size: 20, weight: .medium))
                    .foregroundStyle(
                        LinearGradient(
                            colors: gradient,
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .scaleEffect(isAnimating ? 1.1 : 1.0)
                    .animation(
                        Animation.easeInOut(duration: 2)
                            .repeatForever(autoreverses: true),
                        value: isAnimating
                    )
            }
            // Value
            Text(value)
                .font(.system(size: 20, weight: .bold, design: .rounded))
                .foregroundStyle(OlasDesign.Colors.text)
                .contentTransition(.numericText())
            // Label
            Text(label)
                .font(.system(size: 12, weight: .medium))
                .foregroundStyle(OlasDesign.Colors.textSecondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, OlasDesign.Spacing.md)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                .fill(OlasDesign.Colors.surface.opacity(0.5))
                .overlay(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                        .stroke(
                            LinearGradient(
                                colors: [
                                    Color.white.opacity(0.1),
                                    Color.white.opacity(0.05)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 1
                        )
                )
        )
        .shadow(
            color: gradient.first?.opacity(0.1) ?? .clear,
            radius: 10,
            x: 0,
            y: 5
        )
        .onAppear {
            isAnimating = true
        }
    }
}
</file>

<file path="Olas/Views/Wallet/Components/OlasBalanceCard.swift">
import SwiftUI
struct OlasBalanceCard: View {
    @ObservedObject var walletManager: OlasWalletManager
    @State private var isExpanded = false
    @State private var pulseAnimation = false
    @State private var balanceAnimation = false
    private let mintColors: [Color] = [
        Color(red: 0.98, green: 0.54, blue: 0.13), // Orange
        Color(red: 0.13, green: 0.59, blue: 0.95), // Blue  
        Color(red: 0.96, green: 0.26, blue: 0.21), // Red
        Color(red: 0.30, green: 0.69, blue: 0.31), // Green
        Color(red: 0.61, green: 0.35, blue: 0.71), // Purple
        Color(red: 0.95, green: 0.77, blue: 0.06), // Yellow
    ]
    private var mintDistribution: [(mint: String, balance: Int64, percentage: Double)] {
        let total = Double(walletManager.currentBalance)
        guard total > 0 else { return [] }
        return walletManager.mintBalances.compactMap { (mintURL, balance) in
            guard balance > 0 else { return nil }
            let percentage = (Double(balance) / total) * 100
            let mintName = mintURL.replacingOccurrences(of: "https://", with: "")
            return (mint: mintName, balance: balance, percentage: percentage)
        }.sorted { $0.balance > $1.balance }
    }
    var body: some View {
        VStack(spacing: 0) {
            // Main balance section
            VStack(spacing: OlasDesign.Spacing.md) {
                // Lightning bolt with gradient
                ZStack {
                    // Glow effect
                    Image(systemName: "bolt.circle.fill")
                        .font(.system(size: 80))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [Color.orange, Color.yellow],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .blur(radius: 20)
                        .opacity(0.5)
                        .scaleEffect(pulseAnimation ? 1.1 : 0.9)
                        .animation(
                            Animation.easeInOut(duration: 3)
                                .repeatForever(autoreverses: true),
                            value: pulseAnimation
                        )
                    // Main icon
                    Image(systemName: "bolt.circle.fill")
                        .font(.system(size: 80))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [Color.orange, Color.yellow],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .shadow(color: Color.orange.opacity(0.3), radius: 10, x: 0, y: 5)
                }
                .scaleEffect(balanceAnimation ? 1 : 0.8)
                .opacity(balanceAnimation ? 1 : 0)
                .animation(.spring(response: 0.6, dampingFraction: 0.8), value: balanceAnimation)
                // Balance amount
                VStack(spacing: OlasDesign.Spacing.xs) {
                    HStack(alignment: .firstTextBaseline, spacing: 4) {
                        Text(formatBalance(walletManager.currentBalance))
                            .font(.system(size: isExpanded ? 42 : 48, weight: .bold, design: .rounded))
                            .foregroundColor(OlasDesign.Colors.text)
                            .contentTransition(.numericText())
                            .animation(.spring(response: 0.4), value: walletManager.currentBalance)
                        Text("sats")
                            .font(.system(size: isExpanded ? 18 : 20, weight: .medium, design: .rounded))
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    // USD equivalent - TODO: Add BTC price fetch
                    /*
                    if let usdPrice = walletManager.btcPrice {
                        let usdValue = Double(walletManager.currentBalance) * usdPrice / 100_000_000
                        Text(" $\(String(format: "%.2f", usdValue)) USD")
                            .font(.system(size: 16, weight: .medium, design: .rounded))
                            .foregroundColor(OlasDesign.Colors.textTertiary)
                            .contentTransition(.numericText())
                            .animation(.easeInOut, value: usdValue)
                    }
                    */
                    // Mint distribution indicator
                    if !mintDistribution.isEmpty && !isExpanded {
                        HStack(spacing: OlasDesign.Spacing.sm) {
                            ForEach(0..<min(mintDistribution.count, 4), id: \.self) { index in
                                Circle()
                                    .fill(mintColors[index % mintColors.count])
                                    .frame(width: 8, height: 8)
                            }
                            if mintDistribution.count > 4 {
                                Text("+\(mintDistribution.count - 4)")
                                    .font(.system(size: 10, weight: .medium))
                                    .foregroundColor(OlasDesign.Colors.textTertiary)
                            }
                            Spacer()
                                .frame(width: OlasDesign.Spacing.xs)
                            Text("\(mintDistribution.count) mint\(mintDistribution.count == 1 ? "" : "s")")
                                .font(.system(size: 12, weight: .medium))
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                        }
                        .padding(.top, OlasDesign.Spacing.xs)
                    }
                }
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, OlasDesign.Spacing.xl)
            .padding(.horizontal, OlasDesign.Spacing.lg)
            .background(
                RoundedRectangle(cornerRadius: isExpanded ? OlasDesign.CornerRadius.xl : OlasDesign.CornerRadius.lg)
                    .fill(OlasDesign.Colors.surface)
                    .overlay(
                        RoundedRectangle(cornerRadius: isExpanded ? OlasDesign.CornerRadius.xl : OlasDesign.CornerRadius.lg)
                            .stroke(
                                LinearGradient(
                                    colors: [
                                        Color.orange.opacity(0.3),
                                        Color.yellow.opacity(0.3)
                                    ],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ),
                                lineWidth: 1
                            )
                    )
            )
            .contentShape(Rectangle())
            .onTapGesture {
                withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                    isExpanded.toggle()
                    OlasDesign.Haptic.selection()
                }
            }
            // Expanded mint distribution
            if isExpanded && !mintDistribution.isEmpty {
                VStack(spacing: OlasDesign.Spacing.md) {
                    // Pie chart
                    ZStack {
                        ForEach(Array(mintDistribution.enumerated()), id: \.offset) { index, item in
                            PieSlice(
                                startAngle: startAngle(for: index),
                                endAngle: endAngle(for: index),
                                color: mintColors[index % mintColors.count]
                            )
                        }
                    }
                    .frame(width: 160, height: 160)
                    .padding(.top, OlasDesign.Spacing.lg)
                    // Legend
                    VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                        ForEach(Array(mintDistribution.enumerated()), id: \.offset) { index, item in
                            HStack(spacing: OlasDesign.Spacing.sm) {
                                Circle()
                                    .fill(mintColors[index % mintColors.count])
                                    .frame(width: 12, height: 12)
                                Text(item.mint)
                                    .font(OlasDesign.Typography.bodyMedium)
                                    .foregroundColor(OlasDesign.Colors.text)
                                    .lineLimit(1)
                                Spacer()
                                VStack(alignment: .trailing, spacing: 2) {
                                    Text("\(item.balance) sats")
                                        .font(OlasDesign.Typography.caption)
                                        .foregroundColor(OlasDesign.Colors.text)
                                    Text("\(String(format: "%.1f", item.percentage))%")
                                        .font(.system(size: 10))
                                        .foregroundColor(OlasDesign.Colors.textTertiary)
                                }
                            }
                        }
                    }
                    .padding(.horizontal, OlasDesign.Spacing.md)
                }
                .padding(.bottom, OlasDesign.Spacing.lg)
                .transition(.asymmetric(
                    insertion: .opacity.combined(with: .move(edge: .top)),
                    removal: .opacity.combined(with: .scale(scale: 0.8))
                ))
            }
        }
        .animation(.spring(response: 0.5, dampingFraction: 0.8), value: isExpanded)
        .onAppear {
            pulseAnimation = true
            withAnimation(.easeOut(duration: 0.6)) {
                balanceAnimation = true
            }
        }
    }
    private func formatBalance(_ balance: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: balance)) ?? "0"
    }
    private func startAngle(for index: Int) -> Angle {
        let total = Double(walletManager.currentBalance)
        guard total > 0 else { return .zero }
        var angle: Double = -90 // Start from top
        for i in 0..<index {
            angle += (Double(mintDistribution[i].balance) / total) * 360
        }
        return .degrees(angle)
    }
    private func endAngle(for index: Int) -> Angle {
        let total = Double(walletManager.currentBalance)
        guard total > 0 else { return .zero }
        var angle: Double = -90 // Start from top
        for i in 0...index {
            angle += (Double(mintDistribution[i].balance) / total) * 360
        }
        return .degrees(angle)
    }
}
// MARK: - Pie Slice Shape
struct PieSlice: View {
    let startAngle: Angle
    let endAngle: Angle
    let color: Color
    var body: some View {
        GeometryReader { geometry in
            Path { path in
                let center = CGPoint(x: geometry.size.width / 2, y: geometry.size.height / 2)
                let radius = min(geometry.size.width, geometry.size.height) / 2
                path.move(to: center)
                path.addArc(
                    center: center,
                    radius: radius,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    clockwise: false
                )
                path.closeSubpath()
            }
            .fill(color)
            .overlay(
                Path { path in
                    let center = CGPoint(x: geometry.size.width / 2, y: geometry.size.height / 2)
                    let radius = min(geometry.size.width, geometry.size.height) / 2
                    path.move(to: center)
                    path.addArc(
                        center: center,
                        radius: radius,
                        startAngle: startAngle,
                        endAngle: endAngle,
                        clockwise: false
                    )
                    path.closeSubpath()
                }
                .stroke(Color.white.opacity(0.2), lineWidth: 1)
            )
        }
    }
}
</file>

<file path="Olas/Views/Wallet/Components/OlasEnhancedBalanceCard.swift">
import SwiftUI
import Charts
struct OlasEnhancedBalanceCard: View {
    @ObservedObject var walletManager: OlasWalletManager
    @State private var isExpanded = false
    @State private var showingBreakdown = false
    @State private var selectedMint: String?
    @State private var rotationAngle: Double = 0
    @State private var pulseAnimation = false
    private var totalBalance: Int64 {
        walletManager.currentBalance
    }
    private var formattedBalance: String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: totalBalance)) ?? "0"
    }
    private var mintData: [(mint: String, balance: Int64, percentage: Double)] {
        let total = Double(totalBalance)
        return walletManager.mintBalances.map { mint, balance in
            let percentage = total > 0 ? (Double(balance) / total) * 100 : 0
            return (mint: mint, balance: balance, percentage: percentage)
        }.sorted { $0.balance > $1.balance }
    }
    private var mintColors: [Color] {
        [
            Color(hex: "4ECDC4"),
            Color(hex: "F56565"),
            Color(hex: "805AD5"),
            Color(hex: "48BB78"),
            Color(hex: "ED8936"),
            Color(hex: "38B2AC")
        ]
    }
    var body: some View {
        VStack(spacing: 0) {
            // Main balance card
            Button {
                withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                    isExpanded.toggle()
                    showingBreakdown.toggle()
                }
                OlasDesign.Haptic.selection()
            } label: {
                VStack(spacing: OlasDesign.Spacing.md) {
                    // Header
                    HStack {
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Total Balance")
                                .font(.system(size: 14, weight: .medium))
                                .foregroundStyle(OlasDesign.Colors.textSecondary)
                            HStack(spacing: 6) {
                                Text(formattedBalance)
                                    .font(.system(size: 36, weight: .bold, design: .rounded))
                                    .foregroundStyle(OlasDesign.Colors.text)
                                    .contentTransition(.numericText())
                                Text("sats")
                                    .font(.system(size: 18, weight: .medium))
                                    .foregroundStyle(OlasDesign.Colors.textTertiary)
                                    .offset(y: 8)
                            }
                        }
                        Spacer()
                        // Visual balance indicator
                        ZStack {
                            // Background circle
                            Circle()
                                .stroke(OlasDesign.Colors.surface, lineWidth: 8)
                                .frame(width: 70, height: 70)
                            // Progress circles for each mint
                            ForEach(Array(mintData.enumerated()), id: \.element.mint) { index, data in
                                Circle()
                                    .trim(
                                        from: startAngle(for: index),
                                        to: endAngle(for: index)
                                    )
                                    .stroke(
                                        mintColors[index % mintColors.count],
                                        style: StrokeStyle(lineWidth: 8, lineCap: .round)
                                    )
                                    .frame(width: 70, height: 70)
                                    .rotationEffect(.degrees(-90))
                                    .animation(.spring(), value: data.percentage)
                            }
                            // Center icon
                            Image(systemName: "bitcoinsign.circle.fill")
                                .font(.system(size: 30))
                                .foregroundStyle(
                                    LinearGradient(
                                        colors: [
                                            OlasDesign.Colors.primary,
                                            OlasDesign.Colors.primary.opacity(0.7)
                                        ],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .rotationEffect(.degrees(rotationAngle))
                                .animation(
                                    .linear(duration: 20)
                                    .repeatForever(autoreverses: false),
                                    value: rotationAngle
                                )
                        }
                    }
                    // Expand indicator
                    HStack {
                        Text(isExpanded ? "Hide Details" : "Show Details")
                            .font(.system(size: 12, weight: .medium))
                            .foregroundStyle(OlasDesign.Colors.primary)
                        Image(systemName: "chevron.down")
                            .font(.system(size: 10, weight: .semibold))
                            .foregroundStyle(OlasDesign.Colors.primary)
                            .rotationEffect(.degrees(isExpanded ? 180 : 0))
                    }
                }
                .padding(OlasDesign.Spacing.lg)
                .background(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                        .fill(.ultraThinMaterial)
                        .overlay(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                                .fill(
                                    LinearGradient(
                                        colors: [
                                            OlasDesign.Colors.primary.opacity(0.05),
                                            OlasDesign.Colors.primary.opacity(0.02)
                                        ],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                                .stroke(
                                    LinearGradient(
                                        colors: [
                                            Color.white.opacity(0.2),
                                            Color.white.opacity(0.1)
                                        ],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ),
                                    lineWidth: 1
                                )
                        )
                )
                .shadow(
                    color: OlasDesign.Colors.primary.opacity(0.1),
                    radius: isExpanded ? 20 : 10,
                    x: 0,
                    y: isExpanded ? 10 : 5
                )
            }
            .buttonStyle(PlainButtonStyle())
            // Expanded breakdown
            if showingBreakdown {
                VStack(spacing: OlasDesign.Spacing.sm) {
                    ForEach(Array(mintData.enumerated()), id: \.element.mint) { index, data in
                        MintBreakdownRow(
                            mint: data.mint,
                            balance: data.balance,
                            percentage: data.percentage,
                            color: mintColors[index % mintColors.count],
                            isSelected: selectedMint == data.mint
                        )
                        .onTapGesture {
                            withAnimation(.spring()) {
                                selectedMint = selectedMint == data.mint ? nil : data.mint
                            }
                            OlasDesign.Haptic.selection()
                        }
                    }
                    if mintData.isEmpty {
                        Text("No mints configured")
                            .font(OlasDesign.Typography.body)
                            .foregroundStyle(OlasDesign.Colors.textTertiary)
                            .padding(.vertical, OlasDesign.Spacing.md)
                    }
                }
                .padding(OlasDesign.Spacing.lg)
                .background(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                        .fill(OlasDesign.Colors.surface.opacity(0.5))
                )
                .padding(.top, -OlasDesign.Spacing.sm)
                .transition(.asymmetric(
                    insertion: .push(from: .top).combined(with: .opacity),
                    removal: .push(from: .top).combined(with: .opacity)
                ))
            }
        }
        .onAppear {
            rotationAngle = 360
        }
    }
    private func startAngle(for index: Int) -> CGFloat {
        guard index > 0 else { return 0 }
        let previousPercentages = mintData.prefix(index).map { $0.percentage }.reduce(0, +)
        return previousPercentages / 100
    }
    private func endAngle(for index: Int) -> CGFloat {
        let currentAndPreviousPercentages = mintData.prefix(index + 1).map { $0.percentage }.reduce(0, +)
        return currentAndPreviousPercentages / 100
    }
}
struct MintBreakdownRow: View {
    let mint: String
    let balance: Int64
    let percentage: Double
    let color: Color
    let isSelected: Bool
    private var formattedMint: String {
        if let url = URL(string: mint),
           let host = url.host {
            return host.replacingOccurrences(of: "www.", with: "")
                .replacingOccurrences(of: ".com", with: "")
                .replacingOccurrences(of: ".cash", with: "")
                .replacingOccurrences(of: ".space", with: "")
        }
        return mint
    }
    var body: some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            // Color indicator
            Circle()
                .fill(color)
                .frame(width: 12, height: 12)
                .overlay(
                    Circle()
                        .stroke(color.opacity(0.3), lineWidth: isSelected ? 4 : 0)
                        .animation(.spring(), value: isSelected)
                )
            // Mint name
            VStack(alignment: .leading, spacing: 2) {
                Text(formattedMint)
                    .font(.system(size: 14, weight: .medium))
                    .foregroundStyle(OlasDesign.Colors.text)
                    .lineLimit(1)
                Text("\(String(format: "%.1f", percentage))% of total")
                    .font(.system(size: 11))
                    .foregroundStyle(OlasDesign.Colors.textTertiary)
            }
            Spacer()
            // Balance
            VStack(alignment: .trailing, spacing: 2) {
                Text("\(balance)")
                    .font(.system(size: 16, weight: .semibold, design: .rounded))
                    .foregroundStyle(OlasDesign.Colors.text)
                    .contentTransition(.numericText())
                Text("sats")
                    .font(.system(size: 11))
                    .foregroundStyle(OlasDesign.Colors.textTertiary)
            }
        }
        .padding(.horizontal, OlasDesign.Spacing.sm)
        .padding(.vertical, OlasDesign.Spacing.sm)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
                .fill(isSelected ? color.opacity(0.1) : Color.clear)
                .animation(.spring(), value: isSelected)
        )
    }
}
</file>

<file path="Olas/Views/Wallet/Components/WalletComponents.swift">
import SwiftUI
// MARK: - Stat Card
struct StatCard: View {
    let icon: String
    let value: String
    let label: String
    let color: Color
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.xs) {
            Image(systemName: icon)
                .font(.system(size: 20))
                .foregroundStyle(color)
            Text(value)
                .font(.system(size: 18, weight: .semibold, design: .rounded))
                .foregroundColor(OlasDesign.Colors.text)
            Text(label)
                .font(.system(size: 11))
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, OlasDesign.Spacing.md)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
                .fill(OlasDesign.Colors.surface)
                .overlay(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
                        .stroke(color.opacity(0.2), lineWidth: 1)
                )
        )
    }
}
// MARK: - Action Button
struct ActionButton: View {
    let icon: String
    let title: String
    let gradient: [Color]
    let action: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: {
            OlasDesign.Haptic.selection()
            action()
        }) {
            VStack(spacing: OlasDesign.Spacing.xs) {
                ZStack {
                    // Glow effect
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: gradient,
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 44, height: 44)
                        .blur(radius: isPressed ? 15 : 10)
                        .opacity(0.5)
                    Image(systemName: icon)
                        .font(.system(size: 24))
                        .foregroundStyle(
                            LinearGradient(
                                colors: gradient,
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                }
                .scaleEffect(isPressed ? 0.95 : 1)
                Text(title)
                    .font(.system(size: 13, weight: .medium))
                    .foregroundColor(OlasDesign.Colors.text)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, OlasDesign.Spacing.md)
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .fill(OlasDesign.Colors.surface)
                    .shadow(
                        color: gradient.first?.opacity(0.2) ?? Color.clear,
                        radius: isPressed ? 2 : 5,
                        x: 0,
                        y: isPressed ? 1 : 3
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
        .scaleEffect(isPressed ? 0.98 : 1)
        .onLongPressGesture(minimumDuration: .infinity, maximumDistance: .infinity, pressing: { pressing in
            withAnimation(.easeInOut(duration: 0.1)) {
                isPressed = pressing
            }
        }, perform: {})
    }
}
// MARK: - Empty Activity View
struct EmptyActivityView: View {
    @State private var animateGradient = false
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            ZStack {
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [
                                Color.orange.opacity(0.1),
                                Color.yellow.opacity(0.1)
                            ],
                            startPoint: animateGradient ? .topLeading : .bottomTrailing,
                            endPoint: animateGradient ? .bottomTrailing : .topLeading
                        )
                    )
                    .frame(width: 80, height: 80)
                Image(systemName: "bolt.slash.circle")
                    .font(.system(size: 40))
                    .foregroundStyle(Color.gray)
            }
            .onAppear {
                withAnimation(.easeInOut(duration: 3).repeatForever(autoreverses: true)) {
                    animateGradient.toggle()
                }
            }
            VStack(spacing: OlasDesign.Spacing.xs) {
                Text("No activity yet")
                    .font(OlasDesign.Typography.bodyMedium)
                    .foregroundColor(OlasDesign.Colors.text)
                Text("Your transactions will appear here")
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textTertiary)
                    .multilineTextAlignment(.center)
            }
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, OlasDesign.Spacing.xl)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                .fill(OlasDesign.Colors.surface.opacity(0.5))
                .overlay(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                        .stroke(
                            LinearGradient(
                                colors: [
                                    Color.gray.opacity(0.1),
                                    Color.gray.opacity(0.05)
                                ],
                                startPoint: .top,
                                endPoint: .bottom
                            ),
                            lineWidth: 1
                        )
                )
        )
    }
}
// MARK: - Transaction History View
struct TransactionHistoryView: View {
    @ObservedObject var walletManager: OlasWalletManager
    @State private var searchText = ""
    @State private var selectedFilter: TransactionFilter = .all
    enum TransactionFilter: String, CaseIterable {
        case all = "All"
        case sent = "Sent"
        case received = "Received"
        var icon: String {
            switch self {
            case .all: return "arrow.up.arrow.down"
            case .sent: return "arrow.up.circle"
            case .received: return "arrow.down.circle"
            }
        }
    }
    var filteredTransactions: [OlasWalletManager.WalletTransaction] {
        walletManager.recentTransactions.filter { transaction in
            let matchesFilter = selectedFilter == .all || 
                (selectedFilter == .sent && transaction.type == .sent) ||
                (selectedFilter == .received && transaction.type == .received)
            let matchesSearch = searchText.isEmpty || 
                transaction.description.localizedCaseInsensitiveContains(searchText)
            return matchesFilter && matchesSearch
        }
    }
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            VStack(spacing: 0) {
                // Search and filters
                VStack(spacing: OlasDesign.Spacing.md) {
                    // Search bar
                    HStack {
                        Image(systemName: "magnifyingglass")
                            .foregroundColor(OlasDesign.Colors.textTertiary)
                        TextField("Search transactions", text: $searchText)
                            .textFieldStyle(PlainTextFieldStyle())
                    }
                    .padding(OlasDesign.Spacing.sm)
                    .background(
                        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
                            .fill(OlasDesign.Colors.surface)
                    )
                    // Filter pills
                    HStack(spacing: OlasDesign.Spacing.sm) {
                        ForEach(TransactionFilter.allCases, id: \.self) { filter in
                            FilterPill(
                                title: filter.rawValue,
                                icon: filter.icon,
                                isSelected: selectedFilter == filter
                            ) {
                                withAnimation(.spring(response: 0.3)) {
                                    selectedFilter = filter
                                }
                            }
                        }
                        Spacer()
                    }
                }
                .padding(OlasDesign.Spacing.md)
                // Transaction list
                if filteredTransactions.isEmpty {
                    Spacer()
                    EmptyStateView(
                        icon: "magnifyingglass",
                        title: "No transactions found",
                        subtitle: selectedFilter == .all ? 
                            "Try adjusting your search" : 
                            "No \(selectedFilter.rawValue.lowercased()) transactions"
                    )
                    Spacer()
                } else {
                    ScrollView {
                        LazyVStack(spacing: 0) {
                            ForEach(filteredTransactions) { transaction in
                                VStack(spacing: 0) {
                                    TransactionRow(transaction: transaction, walletManager: walletManager)
                                        .padding(.horizontal, OlasDesign.Spacing.md)
                                    if transaction.id != filteredTransactions.last?.id {
                                        Divider()
                                            .padding(.leading, 60)
                                    }
                                }
                            }
                        }
                        .background(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                                .fill(OlasDesign.Colors.surface)
                        )
                        .padding(.horizontal, OlasDesign.Spacing.md)
                    }
                }
            }
        }
        .navigationTitle("Transaction History")
        .navigationBarTitleDisplayMode(.large)
    }
}
// MARK: - Filter Pill
struct FilterPill: View {
    let title: String
    let icon: String
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.system(size: 12))
                Text(title)
                    .font(.system(size: 13, weight: .medium))
            }
            .foregroundColor(isSelected ? .white : OlasDesign.Colors.text)
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.xs)
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
                    .fill(isSelected ? OlasDesign.Colors.primary : OlasDesign.Colors.surface)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}
// MARK: - Empty State View
struct EmptyStateView: View {
    let icon: String
    let title: String
    let subtitle: String
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            Image(systemName: icon)
                .font(.system(size: 48))
                .foregroundColor(OlasDesign.Colors.textTertiary)
            VStack(spacing: OlasDesign.Spacing.xs) {
                Text(title)
                    .font(OlasDesign.Typography.bodyMedium)
                    .foregroundColor(OlasDesign.Colors.text)
                Text(subtitle)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textTertiary)
                    .multilineTextAlignment(.center)
            }
        }
        .padding(OlasDesign.Spacing.xl)
    }
}
</file>

<file path="Olas/Views/Wallet/Components/WalletContactsScrollView.swift">
import SwiftUI
import NDKSwift
struct WalletContactsScrollView: View {
    @Environment(NostrManager.self) private var nostrManager
    @State private var contacts: [(pubkey: String, profile: NDKUserProfile?)] = []
    @State private var isLoading = true
    @Binding var showNutZap: Bool
    @Binding var nutZapRecipient: String?
    var body: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            // Header
            HStack {
                HStack(spacing: OlasDesign.Spacing.sm) {
                    Image(systemName: "person.2.circle.fill")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundStyle(
                            LinearGradient(
                                colors: OlasDesign.Colors.primaryGradient,
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                    Text("Quick Send")
                        .font(OlasDesign.Typography.bodyMedium)
                        .foregroundStyle(OlasDesign.Colors.text)
                }
                Spacer()
                Button {
                    // Navigate to full contacts
                    OlasDesign.Haptic.selection()
                } label: {
                    HStack(spacing: 4) {
                        Text("View All")
                            .font(OlasDesign.Typography.caption)
                        Image(systemName: "chevron.right")
                            .font(.system(size: 10, weight: .semibold))
                    }
                    .foregroundStyle(OlasDesign.Colors.primary)
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            // Contacts scroll
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: OlasDesign.Spacing.md) {
                    // Add contact button
                    Button {
                        OlasDesign.Haptic.selection()
                        // Show add contact sheet
                    } label: {
                        VStack(spacing: OlasDesign.Spacing.sm) {
                            ZStack {
                                Circle()
                                    .fill(.ultraThinMaterial)
                                    .frame(width: 60, height: 60)
                                    .overlay(
                                        Circle()
                                            .stroke(
                                                LinearGradient(
                                                    colors: OlasDesign.Colors.primaryGradient,
                                                    startPoint: .topLeading,
                                                    endPoint: .bottomTrailing
                                                ),
                                                style: StrokeStyle(lineWidth: 2, dash: [5, 5])
                                            )
                                    )
                                Image(systemName: "plus")
                                    .font(.system(size: 24, weight: .medium))
                                    .foregroundStyle(
                                        LinearGradient(
                                            colors: OlasDesign.Colors.primaryGradient,
                                            startPoint: .topLeading,
                                            endPoint: .bottomTrailing
                                        )
                                    )
                            }
                            Text("Add")
                                .font(.system(size: 12, weight: .medium))
                                .foregroundStyle(OlasDesign.Colors.textSecondary)
                                .lineLimit(1)
                        }
                    }
                    .buttonStyle(ContactButtonStyle())
                    // Contact items
                    if isLoading {
                        ForEach(0..<5) { _ in
                            ContactSkeletonView()
                        }
                    } else {
                        ForEach(contacts, id: \.pubkey) { contact in
                            ContactItemView(
                                pubkey: contact.pubkey,
                                profile: contact.profile
                            ) {
                                nutZapRecipient = contact.pubkey
                                showNutZap = true
                                OlasDesign.Haptic.selection()
                            }
                        }
                    }
                }
                .padding(.horizontal, OlasDesign.Spacing.md)
            }
        }
        .task {
            await loadContacts()
        }
    }
    private func loadContacts() async {
        guard let ndk = nostrManager.ndk,
              let userPubkey = try? await ndk.signer?.pubkey else { return }
        // Load contact list (kind 3)
        let filter = NDKFilter(
            authors: [userPubkey],
            kinds: [EventKind.contacts],
            limit: 1
        )
        let dataSource = ndk.observe(
            filter: filter,
            maxAge: 3600,
            cachePolicy: .cacheWithNetwork
        )
        for await event in dataSource.events {
            // Extract pubkeys from tags
            let pTags = event.tags.filter { $0.count >= 2 && $0[0] == "p" }
            let pubkeyList = pTags.map { $0[1] }
            let pubkeys = Array(pubkeyList.prefix(10)) // Limit to 10 for horizontal scroll
            // Load profiles
            var loadedContacts: [(pubkey: String, profile: NDKUserProfile?)] = []
            for pubkey in pubkeys {
                if let profileManager = ndk.profileManager {
                    var profile: NDKUserProfile?
                    for await p in await profileManager.observe(for: pubkey, maxAge: 3600) {
                        profile = p
                        break
                    }
                    loadedContacts.append((pubkey: pubkey, profile: profile))
                }
            }
            await MainActor.run {
                self.contacts = loadedContacts
                self.isLoading = false
            }
            break // Only need first contact list event
        }
    }
}
struct ContactItemView: View {
    let pubkey: String
    let profile: NDKUserProfile?
    let action: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: action) {
            VStack(spacing: OlasDesign.Spacing.sm) {
                OlasAvatar(
                    url: profile?.picture,
                    size: 60,
                    pubkey: pubkey
                )
                .overlay(
                    Circle()
                        .stroke(
                            LinearGradient(
                                colors: isPressed ? OlasDesign.Colors.primaryGradient : [Color.clear],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 2
                        )
                        .animation(.spring(), value: isPressed)
                )
                Text(displayName)
                    .font(.system(size: 12, weight: .medium))
                    .foregroundStyle(OlasDesign.Colors.text)
                    .lineLimit(1)
                    .frame(width: 60)
            }
        }
        .buttonStyle(ContactButtonStyle())
    }
    private var displayName: String {
        if let name = profile?.displayName ?? profile?.name {
            return name
        }
        return String(pubkey.prefix(8))
    }
}
struct ContactSkeletonView: View {
    @State private var shimmerAnimation = false
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.sm) {
            Circle()
                .fill(OlasDesign.Colors.surface)
                .overlay(shimmerGradient)
                .frame(width: 60, height: 60)
            RoundedRectangle(cornerRadius: 4)
                .fill(OlasDesign.Colors.surface)
                .overlay(shimmerGradient)
                .frame(width: 50, height: 12)
        }
        .onAppear {
            withAnimation(.linear(duration: 1.5).repeatForever(autoreverses: false)) {
                shimmerAnimation = true
            }
        }
    }
    private var shimmerGradient: some View {
        LinearGradient(
            colors: [
                Color.white.opacity(0),
                Color.white.opacity(0.1),
                Color.white.opacity(0)
            ],
            startPoint: .leading,
            endPoint: .trailing
        )
        .rotationEffect(.degrees(30))
        .offset(x: shimmerAnimation ? 300 : -300)
    }
}
struct ContactButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.9 : 1.0)
            .opacity(configuration.isPressed ? 0.8 : 1.0)
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: configuration.isPressed)
    }
}
</file>

<file path="Olas/Views/Wallet/Components/WalletUIHelpers.swift">
import SwiftUI
// MARK: - Pulsing Icon
struct PulsingIcon: View {
    let systemName: String
    let size: CGFloat
    let colors: [Color]
    @State private var pulseAnimation = false
    @State private var rotationAnimation = false
    var body: some View {
        ZStack {
            // Glow effect
            Image(systemName: systemName)
                .font(.system(size: size))
                .foregroundStyle(
                    LinearGradient(
                        colors: colors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .blur(radius: 20)
                .opacity(0.5)
                .scaleEffect(pulseAnimation ? 1.2 : 0.8)
            // Main icon
            Image(systemName: systemName)
                .font(.system(size: size))
                .foregroundStyle(
                    LinearGradient(
                        colors: colors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .shadow(color: colors.first?.opacity(0.3) ?? Color.clear, radius: 10, x: 0, y: 5)
                .rotationEffect(.degrees(rotationAnimation ? 5 : -5))
        }
        .onAppear {
            withAnimation(.easeInOut(duration: 3).repeatForever(autoreverses: true)) {
                pulseAnimation.toggle()
            }
            withAnimation(.easeInOut(duration: 4).repeatForever(autoreverses: true)) {
                rotationAnimation.toggle()
            }
        }
    }
}
// MARK: - Mint Distribution Preview
struct MintDistributionPreview: View {
    @ObservedObject var walletManager: OlasWalletManager
    private let mintColors: [Color] = [
        Color(hex: "FF6B6B"),
        Color(hex: "4ECDC4"),
        Color(hex: "45B7D1"),
        Color(hex: "F9CA24"),
        Color(hex: "6C5CE7")
    ]
    var body: some View {
        HStack(spacing: OlasDesign.Spacing.sm) {
            ForEach(Array(walletManager.mintURLs.prefix(4).enumerated()), id: \.offset) { index, mintURL in
                Circle()
                    .fill(mintColors[index % mintColors.count])
                    .frame(width: 10, height: 10)
                    .overlay(
                        Circle()
                            .stroke(Color.white.opacity(0.3), lineWidth: 1)
                    )
            }
            if walletManager.mintURLs.count > 4 {
                Text("+\(walletManager.mintURLs.count - 4)")
                    .font(.system(size: 11, weight: .medium))
                    .foregroundColor(OlasDesign.Colors.textTertiary)
            }
            Spacer()
                .frame(width: OlasDesign.Spacing.xs)
            Text("\(walletManager.mintURLs.count) mints active")
                .font(.system(size: 13, weight: .medium))
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .padding(.horizontal, OlasDesign.Spacing.md)
        .padding(.vertical, OlasDesign.Spacing.sm)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
                .fill(Color.white.opacity(0.05))
                .overlay(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
                        .stroke(Color.white.opacity(0.1), lineWidth: 1)
                )
        )
    }
}
// MARK: - Share Sheet
#if os(iOS)
struct ShareSheet: UIViewControllerRepresentable {
    let items: [Any]
    func makeUIViewController(context: Context) -> UIActivityViewController {
        UIActivityViewController(activityItems: items, applicationActivities: nil)
    }
    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}
#else
struct ShareSheet: View {
    let items: [Any]
    var body: some View {
        VStack {
            Text("Share")
                .font(.headline)
            if let text = items.first as? String {
                Text(text)
                    .font(.system(.body, design: .monospaced))
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(8)
            }
            Button("Copy to Clipboard") {
                if let text = items.first as? String {
                    #if os(macOS)
                    NSPasteboard.general.clearContents()
                    NSPasteboard.general.setString(text, forType: .string)
                    #endif
                }
            }
        }
        .padding()
        .frame(width: 400, height: 300)
    }
}
#endif
// MARK: - Modern Transaction Row
struct ModernTransactionRow: View {
    let transaction: OlasWalletManager.WalletTransaction
    @ObservedObject var walletManager: OlasWalletManager
    @State private var showDetail = false
    @State private var animateIn = false
    private var transactionIcon: String {
        switch transaction.type {
        case .sent: return "arrow.up.circle.fill"
        case .received: return "arrow.down.circle.fill"
        case .zapped, .nutzapped: return "bolt.circle.fill"
        case .minted: return "plus.circle.fill"
        case .melted: return "minus.circle.fill"
        case .swapped: return "arrow.2.circlepath.circle.fill"
        }
    }
    private var transactionColor: Color {
        switch transaction.type {
        case .sent, .melted: return Color(hex: "F56565")
        case .received, .minted: return Color(hex: "48BB78")
        case .zapped, .nutzapped: return Color(hex: "805AD5")
        case .swapped: return Color(hex: "4299E1")
        }
    }
    var body: some View {
        Button {
            showDetail = true
            OlasDesign.Haptic.impact(.light)
        } label: {
            HStack(spacing: OlasDesign.Spacing.md) {
                // Animated Icon
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [
                                    transactionColor.opacity(0.2),
                                    transactionColor.opacity(0.1)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 48, height: 48)
                    Image(systemName: transactionIcon)
                        .font(.system(size: 22))
                        .foregroundStyle(transactionColor)
                        .scaleEffect(animateIn ? 1 : 0)
                        .rotationEffect(.degrees(animateIn ? 0 : -90))
                }
                // Details
                VStack(alignment: .leading, spacing: 4) {
                    Text(transaction.description)
                        .font(.system(size: 15, weight: .medium))
                        .foregroundColor(OlasDesign.Colors.text)
                        .lineLimit(1)
                    HStack(spacing: 4) {
                        Text(formatRelativeTime(transaction.timestamp))
                            .font(.system(size: 12))
                            .foregroundColor(OlasDesign.Colors.textTertiary)
                        if let mint = transaction.mint {
                            Text("")
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                            Text(formatMintName(mint))
                                .font(.system(size: 12))
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                                .lineLimit(1)
                        }
                        if transaction.status == .pending {
                            Text("")
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                            HStack(spacing: 2) {
                                ProgressView()
                                    .scaleEffect(0.7)
                                Text("Pending")
                                    .font(.system(size: 11))
                                    .foregroundColor(Color.orange)
                            }
                        }
                    }
                }
                Spacer()
                // Amount with animation
                VStack(alignment: .trailing, spacing: 2) {
                    Text("\(transaction.type == .received || transaction.type == .minted ? "+" : "-")\(formatAmount(transaction.amount))")
                        .font(.system(size: 17, weight: .semibold, design: .rounded))
                        .foregroundColor(transactionColor)
                        .opacity(animateIn ? 1 : 0)
                        .offset(x: animateIn ? 0 : 20)
                    Text("sats")
                        .font(.system(size: 11))
                        .foregroundColor(OlasDesign.Colors.textTertiary)
                }
            }
            .padding(.vertical, OlasDesign.Spacing.sm)
        }
        .buttonStyle(PlainButtonStyle())
        .sheet(isPresented: $showDetail) {
            TransactionDetailView(transaction: transaction, walletManager: walletManager)
        }
        .onAppear {
            withAnimation(.spring(response: 0.5, dampingFraction: 0.8).delay(0.1)) {
                animateIn = true
            }
        }
    }
    private func formatAmount(_ amount: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: amount)) ?? "0"
    }
    private func formatRelativeTime(_ date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
    private func formatMintName(_ mint: String) -> String {
        if let url = URL(string: mint),
           let host = url.host {
            return host.replacingOccurrences(of: "www.", with: "")
        }
        return mint
    }
}
</file>

<file path="Olas/Views/Wallet/AddMintView.swift">
import SwiftUI
struct AddMintView: View {
    @ObservedObject var walletManager: OlasWalletManager
    @Environment(\.dismiss) private var dismiss
    @State private var mintURL = ""
    @State private var isLoading = false
    @State private var errorMessage: String?
    @State private var showingScanner = false
    @FocusState private var isTextFieldFocused: Bool
    // Popular mints
    private let popularMints = [
        ("Minibits", "https://mint.minibits.cash/Bitcoin"),
        ("Cashu Space", "https://testnut.cashu.space"),
        ("8333.space", "https://8333.space:3338"),
        ("LNbits Legend", "https://legend.lnbits.com/cashu/api/v1/AptDNABNBXv8gpuywhx6NV")
    ]
    var body: some View {
        NavigationStack {
            ZStack {
                // Background
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                ScrollView {
                    VStack(spacing: OlasDesign.Spacing.xl) {
                        // Header illustration
                        ZStack {
                            Circle()
                                .fill(
                                    RadialGradient(
                                        colors: [
                                            Color(hex: "667EEA").opacity(0.3),
                                            Color.clear
                                        ],
                                        center: .center,
                                        startRadius: 20,
                                        endRadius: 100
                                    )
                                )
                                .frame(width: 200, height: 200)
                                .blur(radius: 30)
                            Image(systemName: "plus.circle.fill")
                                .font(.system(size: 80))
                                .foregroundStyle(
                                    LinearGradient(
                                        colors: [Color(hex: "667EEA"), Color(hex: "764BA2")],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .shadow(color: Color(hex: "667EEA").opacity(0.5), radius: 20)
                        }
                        .padding(.top, OlasDesign.Spacing.xl)
                        // Instructions
                        VStack(spacing: OlasDesign.Spacing.sm) {
                            Text("Add a Cashu Mint")
                                .font(.system(size: 24, weight: .bold, design: .rounded))
                                .foregroundStyle(OlasDesign.Colors.text)
                            Text("Connect to a mint to store and manage your ecash")
                                .font(OlasDesign.Typography.body)
                                .foregroundStyle(OlasDesign.Colors.textSecondary)
                                .multilineTextAlignment(.center)
                        }
                        // URL Input
                        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                            Text("Mint URL")
                                .font(OlasDesign.Typography.caption)
                                .foregroundStyle(OlasDesign.Colors.textSecondary)
                            HStack {
                                TextField("https://mint.example.com", text: $mintURL)
                                    .textFieldStyle(PlainTextFieldStyle())
                                    .font(OlasDesign.Typography.body)
                                    .foregroundColor(OlasDesign.Colors.text)
                                    .autocapitalization(.none)
                                    .disableAutocorrection(true)
                                    .focused($isTextFieldFocused)
                                Button {
                                    showingScanner = true
                                    OlasDesign.Haptic.selection()
                                } label: {
                                    Image(systemName: "qrcode.viewfinder")
                                        .font(.title2)
                                        .foregroundStyle(OlasDesign.Colors.primary)
                                }
                            }
                            .padding(OlasDesign.Spacing.md)
                            .background(
                                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                    .fill(OlasDesign.Colors.surface)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                            .stroke(
                                                isTextFieldFocused ? OlasDesign.Colors.primary : Color.clear,
                                                lineWidth: 2
                                            )
                                    )
                            )
                            if let error = errorMessage {
                                Text(error)
                                    .font(OlasDesign.Typography.caption)
                                    .foregroundStyle(OlasDesign.Colors.error)
                            }
                        }
                        .padding(.horizontal, OlasDesign.Spacing.md)
                        // Popular Mints
                        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
                            Text("Popular Mints")
                                .font(OlasDesign.Typography.bodyBold)
                                .foregroundStyle(OlasDesign.Colors.text)
                                .padding(.horizontal, OlasDesign.Spacing.md)
                            VStack(spacing: OlasDesign.Spacing.sm) {
                                ForEach(popularMints, id: \.1) { name, url in
                                    PopularMintRow(
                                        name: name,
                                        url: url,
                                        isAdded: walletManager.mintURLs.contains(url)
                                    ) {
                                        mintURL = url
                                        Task {
                                            await addMint()
                                        }
                                    }
                                }
                            }
                            .padding(.horizontal, OlasDesign.Spacing.md)
                        }
                        Spacer(minLength: 100)
                    }
                }
                // Loading overlay
                if isLoading {
                    ZStack {
                        Color.black.opacity(0.5)
                            .ignoresSafeArea()
                        VStack(spacing: OlasDesign.Spacing.md) {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                .scaleEffect(1.5)
                            Text("Connecting to mint...")
                                .font(OlasDesign.Typography.body)
                                .foregroundStyle(.white)
                        }
                        .padding(OlasDesign.Spacing.xl)
                        .background(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                                .fill(OlasDesign.Colors.surface)
                        )
                        .shadow(radius: 20)
                    }
                }
            }
            .navigationTitle("Add Mint")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Add") {
                        Task {
                            await addMint()
                        }
                    }
                    .disabled(mintURL.isEmpty || isLoading)
                }
            }
            .sheet(isPresented: $showingScanner) {
                QRScannerView { result in
                    mintURL = result
                }
            }
        }
    }
    private func addMint() async {
        guard !mintURL.isEmpty else { return }
        isLoading = true
        errorMessage = nil
        isTextFieldFocused = false
        do {
            try await walletManager.addMint(mintURL)
            OlasDesign.Haptic.success()
            dismiss()
        } catch {
            errorMessage = error.localizedDescription
            OlasDesign.Haptic.error()
        }
        isLoading = false
    }
}
struct PopularMintRow: View {
    let name: String
    let url: String
    let isAdded: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: OlasDesign.Spacing.md) {
                // Icon
                Circle()
                    .fill(
                        LinearGradient(
                            colors: isAdded ? [Color.gray, Color.gray.opacity(0.8)] : [Color(hex: "667EEA"), Color(hex: "764BA2")],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 44, height: 44)
                    .overlay(
                        Text("")
                            .font(.system(size: 24, weight: .bold))
                            .foregroundColor(.white)
                    )
                // Details
                VStack(alignment: .leading, spacing: 2) {
                    Text(name)
                        .font(OlasDesign.Typography.bodyMedium)
                        .foregroundStyle(OlasDesign.Colors.text)
                    Text(url.replacingOccurrences(of: "https://", with: ""))
                        .font(OlasDesign.Typography.caption)
                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                        .lineLimit(1)
                }
                Spacer()
                // Status
                if isAdded {
                    HStack(spacing: 4) {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.caption)
                            .foregroundStyle(Color.green)
                        Text("Added")
                            .font(OlasDesign.Typography.caption)
                            .foregroundStyle(OlasDesign.Colors.textSecondary)
                    }
                } else {
                    Image(systemName: "plus.circle")
                        .font(.title3)
                        .foregroundStyle(OlasDesign.Colors.primary)
                }
            }
            .padding(OlasDesign.Spacing.md)
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .fill(OlasDesign.Colors.surface)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(isAdded)
    }
}
</file>

<file path="Olas/Views/Wallet/MintManagementView.swift">
import SwiftUI
import NDKSwift
struct MintManagementView: View {
    @ObservedObject var walletManager: OlasWalletManager
    @Environment(\.dismiss) private var dismiss
    @State private var selectedMint: String?
    @State private var showingAddMint = false
    @State private var showingMintDetails = false
    @State private var mintStats: [String: MintStats] = [:]
    @State private var animateCards = false
    struct MintStats {
        let balance: Int64
        let tokenCount: Int
        let status: MintStatus
        let lastActive: Date
        let fee: Double
        enum MintStatus {
            case active
            case syncing
            case offline
        }
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Animated background
                AnimatedMeshGradient()
                    .opacity(0.3)
                    .ignoresSafeArea()
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                ScrollView(showsIndicators: false) {
                    VStack(spacing: OlasDesign.Spacing.xl) {
                        // Header with stats
                        headerView
                            .padding(.top, OlasDesign.Spacing.md)
                        // Mint Cards
                        if walletManager.mintURLs.isEmpty {
                            emptyStateView
                        } else {
                            mintCardsSection
                        }
                        // Add Mint Button
                        addMintButton
                            .padding(.bottom, OlasDesign.Spacing.xxl)
                    }
                    .padding(.horizontal, OlasDesign.Spacing.md)
                }
            }
            .navigationTitle("Mint Management")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.large)
            #endif
            .toolbar {
                ToolbarItem(placement: {
                    #if os(iOS)
                    .navigationBarTrailing
                    #else
                    .automatic
                    #endif
                }()) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundStyle(OlasDesign.Colors.text)
                }
            }
            .sheet(isPresented: $showingAddMint) {
                AddMintView(walletManager: walletManager)
            }
            .sheet(isPresented: $showingMintDetails) {
                if let mint = selectedMint {
                    MintDetailView(mintURL: mint, walletManager: walletManager)
                }
            }
            .onAppear {
                loadMintStats()
                withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                    animateCards = true
                }
            }
        }
    }
    // MARK: - Header View
    private var headerView: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            // Total Balance Across All Mints
            VStack(spacing: OlasDesign.Spacing.sm) {
                Text("Total Balance Across Mints")
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                HStack(alignment: .firstTextBaseline, spacing: 4) {
                    Text(formatSats(walletManager.currentBalance))
                        .font(.system(size: 42, weight: .bold, design: .rounded))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [OlasDesign.Colors.text, OlasDesign.Colors.text.opacity(0.8)],
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .contentTransition(.numericText())
                        .animation(.spring(response: 0.3, dampingFraction: 0.8), value: walletManager.currentBalance)
                    Text("sats")
                        .font(OlasDesign.Typography.body)
                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                }
            }
            // Stats Row
            HStack(spacing: OlasDesign.Spacing.xl) {
                MintStatCard(
                    icon: "building.2.fill",
                    value: "\(walletManager.mintURLs.count)",
                    label: "Active Mints"
                )
                MintStatCard(
                    icon: "bitcoinsign.circle.fill",
                    value: "\(walletManager.activeTokens.count)",
                    label: "Total Tokens"
                )
                MintStatCard(
                    icon: "bolt.fill",
                    value: "\(calculateTransactionCount())",
                    label: "Transactions"
                )
            }
        }
        .padding(OlasDesign.Spacing.lg)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.xl)
                .fill(
                    LinearGradient(
                        colors: [
                            OlasDesign.Colors.surface.opacity(0.8),
                            OlasDesign.Colors.surface.opacity(0.6)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .overlay(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.xl)
                        .stroke(
                            LinearGradient(
                                colors: [Color.white.opacity(0.2), Color.white.opacity(0.05)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 1
                        )
                )
        )
        .shadow(color: Color.black.opacity(0.2), radius: 20, x: 0, y: 10)
    }
    // MARK: - Mint Cards Section
    private var mintCardsSection: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            ForEach(Array(walletManager.mintURLs.enumerated()), id: \.element) { index, mintURL in
                MintCard(
                    mintURL: mintURL,
                    balance: walletManager.mintBalances[mintURL] ?? 0,
                    stats: mintStats[mintURL],
                    onTap: {
                        selectedMint = mintURL
                        showingMintDetails = true
                        OlasDesign.Haptic.selection()
                    },
                    onRemove: {
                        Task {
                            await removeMint(mintURL)
                        }
                    }
                )
                .scaleEffect(animateCards ? 1 : 0.8)
                .opacity(animateCards ? 1 : 0)
                .animation(
                    .spring(response: 0.5, dampingFraction: 0.8)
                    .delay(Double(index) * 0.1),
                    value: animateCards
                )
            }
        }
    }
    // MARK: - Empty State
    private var emptyStateView: some View {
        VStack(spacing: OlasDesign.Spacing.xl) {
            // Animated illustration
            ZStack {
                ForEach(0..<3, id: \.self) { index in
                    Circle()
                        .stroke(
                            LinearGradient(
                                colors: [
                                    Color(hex: "667EEA").opacity(0.3 - Double(index) * 0.1),
                                    Color(hex: "764BA2").opacity(0.3 - Double(index) * 0.1)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 2
                        )
                        .frame(width: CGFloat(100 + index * 30), height: CGFloat(100 + index * 30))
                        .rotationEffect(.degrees(Double(index) * 60))
                        .scaleEffect(animateCards ? 1.1 : 0.9)
                        .animation(
                            .easeInOut(duration: 3)
                            .repeatForever(autoreverses: true)
                            .delay(Double(index) * 0.3),
                            value: animateCards
                        )
                }
                Image(systemName: "building.2.crop.circle")
                    .font(.system(size: 60))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [Color(hex: "667EEA"), Color(hex: "764BA2")],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
            }
            .frame(height: 200)
            VStack(spacing: OlasDesign.Spacing.sm) {
                Text("No Mints Added")
                    .font(OlasDesign.Typography.title)
                    .foregroundStyle(OlasDesign.Colors.text)
                Text("Add a Cashu mint to start using ecash")
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                    .multilineTextAlignment(.center)
            }
        }
        .padding(.vertical, OlasDesign.Spacing.xxl)
    }
    // MARK: - Add Mint Button
    private var addMintButton: some View {
        Button {
            showingAddMint = true
            OlasDesign.Haptic.selection()
        } label: {
            HStack(spacing: OlasDesign.Spacing.md) {
                Image(systemName: "plus.circle.fill")
                    .font(.title2)
                Text("Add New Mint")
                    .font(OlasDesign.Typography.bodyBold)
                Spacer()
                Image(systemName: "chevron.right")
                    .font(.caption)
                    .foregroundStyle(OlasDesign.Colors.textTertiary)
            }
            .foregroundStyle(.white)
            .padding(OlasDesign.Spacing.lg)
            .background(
                LinearGradient(
                    colors: OlasDesign.Colors.primaryGradient,
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg))
            .shadow(color: OlasDesign.Colors.primary.opacity(0.3), radius: 10, x: 0, y: 5)
        }
    }
    // MARK: - Helper Methods
    private func loadMintStats() {
        // Mock data - in production, fetch real stats
        for mint in walletManager.mintURLs {
            mintStats[mint] = MintStats(
                balance: walletManager.mintBalances[mint] ?? 0,
                tokenCount: walletManager.activeTokens.filter { $0.mint == mint }.count,
                status: .active,
                lastActive: Date(),
                fee: 0.5
            )
        }
    }
    private func calculateTransactionCount() -> Int {
        walletManager.recentTransactions.count
    }
    private func removeMint(_ mintURL: String) async {
        do {
            try await walletManager.removeMint(mintURL)
            OlasDesign.Haptic.success()
        } catch {
            OlasDesign.Haptic.error()
        }
    }
    private func formatSats(_ sats: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: sats)) ?? "0"
    }
}
// MARK: - Supporting Views
struct MintStatCard: View {
    let icon: String
    let value: String
    let label: String
    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundStyle(OlasDesign.Colors.primary)
            Text(value)
                .font(OlasDesign.Typography.bodyBold)
                .foregroundStyle(OlasDesign.Colors.text)
            Text(label)
                .font(.system(size: 11))
                .foregroundStyle(OlasDesign.Colors.textTertiary)
                .multilineTextAlignment(.center)
        }
        .frame(maxWidth: .infinity)
    }
}
struct MintCard: View {
    let mintURL: String
    let balance: Int64
    let stats: MintManagementView.MintStats?
    let onTap: () -> Void
    let onRemove: () -> Void
    @State private var isPressed = false
    @State private var showRemoveConfirmation = false
    var body: some View {
        Button(action: onTap) {
            VStack(spacing: 0) {
                // Header
                HStack(spacing: OlasDesign.Spacing.md) {
                    // Mint icon with status indicator
                    ZStack(alignment: .bottomTrailing) {
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: [Color(hex: "667EEA"), Color(hex: "764BA2")],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 50, height: 50)
                            .overlay(
                                Text("")
                                    .font(.system(size: 28, weight: .bold))
                                    .foregroundColor(.white)
                            )
                        // Status indicator
                        Circle()
                            .fill(statusColor)
                            .frame(width: 14, height: 14)
                            .overlay(
                                Circle()
                                    .stroke(OlasDesign.Colors.background, lineWidth: 2)
                            )
                    }
                    // Mint info
                    VStack(alignment: .leading, spacing: 4) {
                        Text(extractMintName(from: mintURL))
                            .font(OlasDesign.Typography.bodyBold)
                            .foregroundStyle(OlasDesign.Colors.text)
                        HStack(spacing: 4) {
                            Text(mintURL.replacingOccurrences(of: "https://", with: ""))
                                .font(OlasDesign.Typography.caption)
                                .foregroundStyle(OlasDesign.Colors.textSecondary)
                                .lineLimit(1)
                            if let stats = stats {
                                Text("")
                                    .foregroundStyle(OlasDesign.Colors.textTertiary)
                                Text("\(stats.fee)% fee")
                                    .font(OlasDesign.Typography.caption)
                                    .foregroundStyle(OlasDesign.Colors.textTertiary)
                            }
                        }
                    }
                    Spacer()
                    // Balance
                    VStack(alignment: .trailing, spacing: 2) {
                        Text(formatSats(balance))
                            .font(OlasDesign.Typography.bodyBold)
                            .foregroundStyle(OlasDesign.Colors.text)
                        Text("sats")
                            .font(.system(size: 11))
                            .foregroundStyle(OlasDesign.Colors.textSecondary)
                    }
                }
                .padding(OlasDesign.Spacing.lg)
                // Stats bar
                if let stats = stats {
                    HStack(spacing: OlasDesign.Spacing.xl) {
                        MintStatItem(
                            icon: "bitcoinsign.circle",
                            value: "\(stats.tokenCount)",
                            label: "Tokens"
                        )
                        MintStatItem(
                            icon: "clock",
                            value: formatLastActive(stats.lastActive),
                            label: "Last Active"
                        )
                        MintStatItem(
                            icon: "arrow.triangle.2.circlepath",
                            value: statusText,
                            label: "Status"
                        )
                    }
                    .padding(.horizontal, OlasDesign.Spacing.lg)
                    .padding(.bottom, OlasDesign.Spacing.md)
                    .background(
                        OlasDesign.Colors.background.opacity(0.5)
                    )
                }
            }
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                    .fill(
                        LinearGradient(
                            colors: [
                                OlasDesign.Colors.surface,
                                OlasDesign.Colors.surface.opacity(0.8)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
            )
            .overlay(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                    .stroke(
                        LinearGradient(
                            colors: [Color.white.opacity(0.15), Color.white.opacity(0.05)],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 1
                    )
            )
            .shadow(color: Color.black.opacity(0.1), radius: 10, x: 0, y: 5)
            .scaleEffect(isPressed ? 0.98 : 1)
        }
        .buttonStyle(PlainButtonStyle())
        .contextMenu {
            Button(role: .destructive) {
                showRemoveConfirmation = true
            } label: {
                Label("Remove Mint", systemImage: "trash")
            }
        }
        .confirmationDialog(
            "Remove Mint?",
            isPresented: $showRemoveConfirmation,
            titleVisibility: .visible
        ) {
            Button("Remove", role: .destructive) {
                onRemove()
            }
        } message: {
            Text("This mint has \(balance) sats. You cannot remove it until the balance is zero.")
        }
        .onLongPressGesture(minimumDuration: .infinity, maximumDistance: .infinity, pressing: { pressing in
            withAnimation(.easeInOut(duration: 0.1)) {
                isPressed = pressing
            }
        }, perform: {})
    }
    private var statusColor: Color {
        guard let stats = stats else { return Color.gray }
        switch stats.status {
        case .active:
            return Color.green
        case .syncing:
            return Color.orange
        case .offline:
            return Color.red
        }
    }
    private var statusText: String {
        guard let stats = stats else { return "Unknown" }
        switch stats.status {
        case .active:
            return "Active"
        case .syncing:
            return "Syncing"
        case .offline:
            return "Offline"
        }
    }
    private func extractMintName(from url: String) -> String {
        if url.contains("minibits") {
            return "Minibits"
        } else if url.contains("cashu.space") {
            return "Cashu Space"
        } else if url.contains("8333") {
            return "8333.space"
        } else if url.contains("lnbits") {
            return "LNbits"
        } else {
            // Extract domain name
            let cleanURL = url.replacingOccurrences(of: "https://", with: "")
                .replacingOccurrences(of: "http://", with: "")
            let components = cleanURL.split(separator: "/")
            if let domain = components.first {
                let domainParts = domain.split(separator: ".")
                if let name = domainParts.first {
                    return String(name).capitalized
                }
            }
            return "Mint"
        }
    }
    private func formatSats(_ sats: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: sats)) ?? "0"
    }
    private func formatLastActive(_ date: Date) -> String {
        let interval = Date().timeIntervalSince(date)
        if interval < 60 {
            return "Now"
        } else if interval < 3600 {
            return "\(Int(interval / 60))m"
        } else if interval < 86400 {
            return "\(Int(interval / 3600))h"
        } else {
            return "\(Int(interval / 86400))d"
        }
    }
}
struct MintStatItem: View {
    let icon: String
    let value: String
    let label: String
    var body: some View {
        VStack(spacing: 4) {
            HStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.caption)
                Text(value)
                    .font(OlasDesign.Typography.caption)
            }
            .foregroundStyle(OlasDesign.Colors.text)
            Text(label)
                .font(.system(size: 10))
                .foregroundStyle(OlasDesign.Colors.textTertiary)
        }
    }
}
// MARK: - Mint Detail View
struct MintDetailView: View {
    let mintURL: String
    @ObservedObject var walletManager: OlasWalletManager
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationView {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                // Content placeholder
                VStack {
                    Text("Mint Details")
                        .font(OlasDesign.Typography.title)
                    Text(mintURL)
                        .font(OlasDesign.Typography.body)
                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                }
            }
            .navigationTitle("Mint Details")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            .toolbar {
                ToolbarItem(placement: {
                    #if os(iOS)
                    .navigationBarTrailing
                    #else
                    .automatic
                    #endif
                }()) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}
// MARK: - Animated Mesh Gradient
struct AnimatedMeshGradient: View {
    @State private var animationTrigger = false
    var body: some View {
        TimeBasedGradient()
            .blur(radius: 30)
            .scaleEffect(1.5)
            .rotationEffect(.degrees(animationTrigger ? 360 : 0))
            .animation(
                .linear(duration: 60)
                .repeatForever(autoreverses: false),
                value: animationTrigger
            )
            .onAppear {
                animationTrigger = true
            }
    }
}
// End of MintManagementView.swift
</file>

<file path="Olas/Views/Wallet/NutZapView.swift">
import SwiftUI
import NDKSwift
struct NutZapView: View {
    @ObservedObject var walletManager: OlasWalletManager
    let nostrManager: NostrManager
    let recipientPubkey: String?
    @State private var selectedAmount: Int64 = 21
    @State private var customAmount: String = ""
    @State private var comment: String = ""
    @State private var isSearching = false
    @State private var searchQuery = ""
    @State private var selectedUser: NDKUserProfile?
    @State private var selectedUserPubkey: String?
    @State private var isSending = false
    @State private var showSuccess = false
    @State private var errorMessage: String?
    @Environment(\.dismiss) private var dismiss
    private let quickAmounts: [Int64] = [21, 100, 500, 1000, 5000, 10000]
    var body: some View {
        NavigationStack {
            ZStack {
                backgroundGradient
                mainContent
            }
            .navigationTitle("")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                toolbarContent
            }
            .task {
                if let pubkey = recipientPubkey {
                    await loadUserProfile(pubkey: pubkey)
                }
            }
            .alert("Success!", isPresented: $showSuccess) {
                Button("Done") {
                    dismiss()
                }
            } message: {
                Text("NutZap sent successfully!")
            }
            .alert("Error", isPresented: .constant(errorMessage != nil)) {
                Button("OK") {
                    errorMessage = nil
                }
            } message: {
                if let error = errorMessage {
                    Text(error)
                }
            }
        }
    }
    private var backgroundGradient: some View {
        LinearGradient(
            colors: [
                OlasDesign.Colors.background,
                OlasDesign.Colors.surface.opacity(0.5)
            ],
            startPoint: .top,
            endPoint: .bottom
        )
        .ignoresSafeArea()
    }
    private var mainContent: some View {
        ScrollView {
            VStack(spacing: OlasDesign.Spacing.xl) {
                headerSection
                recipientSection
                amountSection
                commentField
                sendButton
            }
            .padding(.horizontal, OlasDesign.Spacing.lg)
            .padding(.bottom, OlasDesign.Spacing.xl)
        }
    }
    @ToolbarContentBuilder
    private var toolbarContent: some ToolbarContent {
        ToolbarItem(placement: .navigationBarLeading) {
            Button("Cancel") {
                dismiss()
            }
            .foregroundStyle(OlasDesign.Colors.primary)
        }
    }
    private var headerSection: some View {
        VStack(spacing: OlasDesign.Spacing.sm) {
            Text(" NutZap")
                .font(OlasDesign.Typography.title)
                .foregroundStyle(OlasDesign.Colors.text)
            Text("Send ecash instantly")
                .font(OlasDesign.Typography.body)
                .foregroundStyle(OlasDesign.Colors.textSecondary)
            HStack(spacing: 4) {
                Text("Balance:")
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.textTertiary)
                Text("\(walletManager.currentBalance) sats")
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.primary)
            }
        }
        .padding(.top, OlasDesign.Spacing.md)
    }
    private var recipientSection: some View {
        Group {
            if recipientPubkey == nil {
                recipientSelector
            } else if let userProfile = selectedUser {
                selectedRecipientCard(profile: userProfile, pubkey: recipientPubkey!)
            }
        }
    }
    private var recipientSelector: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            Text("Recipient")
                .font(OlasDesign.Typography.bodyMedium)
                .foregroundStyle(OlasDesign.Colors.text)
            HStack(spacing: OlasDesign.Spacing.sm) {
                Image(systemName: "magnifyingglass")
                    .foregroundStyle(OlasDesign.Colors.textTertiary)
                TextField("Search by name or npub...", text: $searchQuery)
                    .textFieldStyle(.plain)
                    .onSubmit {
                        Task {
                            await searchUser()
                        }
                    }
            }
            .padding(OlasDesign.Spacing.md)
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .fill(OlasDesign.Colors.surface)
            )
            .overlay(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .stroke(OlasDesign.Colors.divider, lineWidth: 1)
            )
            if isSearching {
                HStack {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Searching...")
                        .font(OlasDesign.Typography.caption)
                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                }
                .padding(.top, OlasDesign.Spacing.xs)
            }
        }
    }
    private func selectedRecipientCard(profile: NDKUserProfile, pubkey: String) -> some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            // Avatar
            if let avatarURL = profile.picture {
                AsyncImage(url: URL(string: avatarURL)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Circle()
                        .fill(OlasDesign.Colors.surface)
                        .overlay(
                            Text((profile.displayName ?? profile.name ?? "?").prefix(1))
                                .font(OlasDesign.Typography.bodyMedium)
                                .foregroundStyle(OlasDesign.Colors.textSecondary)
                        )
                }
                .frame(width: 50, height: 50)
                .clipShape(Circle())
            }
            VStack(alignment: .leading, spacing: 4) {
                Text(profile.displayName ?? profile.name ?? "Anonymous")
                    .font(OlasDesign.Typography.bodyMedium)
                    .foregroundStyle(OlasDesign.Colors.text)
                Text("@\(profile.name ?? String(pubkey.prefix(8)))")
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
            }
            Spacer()
            if recipientPubkey == nil {
                Button {
                    selectedUser = nil
                    selectedUserPubkey = nil
                    searchQuery = ""
                } label: {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundStyle(OlasDesign.Colors.textTertiary)
                }
            }
        }
        .padding(OlasDesign.Spacing.md)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .fill(OlasDesign.Colors.surface)
        )
        .overlay(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .stroke(OlasDesign.Colors.primary.opacity(0.3), lineWidth: 1)
        )
    }
    private var amountSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Amount")
                .font(OlasDesign.Typography.bodyMedium)
                .foregroundStyle(OlasDesign.Colors.text)
            // Quick amount buttons
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 80))], spacing: OlasDesign.Spacing.sm) {
                ForEach(quickAmounts, id: \.self) { amount in
                    Button {
                        selectedAmount = amount
                        customAmount = ""
                        OlasDesign.Haptic.selection()
                    } label: {
                        Text("\(amount)")
                            .font(OlasDesign.Typography.bodyMedium)
                            .foregroundStyle(selectedAmount == amount ? .white : OlasDesign.Colors.text)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, OlasDesign.Spacing.sm)
                            .background(
                                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
                                    .fill(selectedAmount == amount ? OlasDesign.Colors.primary : OlasDesign.Colors.surface)
                            )
                            .overlay(
                                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
                                    .stroke(selectedAmount == amount ? Color.clear : OlasDesign.Colors.divider, lineWidth: 1)
                            )
                    }
                }
            }
            // Custom amount
            HStack {
                TextField("Custom amount", text: $customAmount)
                    .keyboardType(.numberPad)
                    .textFieldStyle(.plain)
                    .onChange(of: customAmount) { _, newValue in
                        if !newValue.isEmpty {
                            selectedAmount = Int64(newValue) ?? 0
                        }
                    }
                Text("sats")
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
            }
            .padding(OlasDesign.Spacing.md)
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .fill(OlasDesign.Colors.surface)
            )
            .overlay(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .stroke(customAmount.isEmpty ? OlasDesign.Colors.divider : OlasDesign.Colors.primary, lineWidth: 1)
            )
        }
    }
    private var commentField: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            Text("Comment (optional)")
                .font(OlasDesign.Typography.bodyMedium)
                .foregroundStyle(OlasDesign.Colors.text)
            TextField("Add a message...", text: $comment, axis: .vertical)
                .textFieldStyle(.plain)
                .lineLimit(3...5)
                .padding(OlasDesign.Spacing.md)
                .background(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                        .fill(OlasDesign.Colors.surface)
                )
                .overlay(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                        .stroke(OlasDesign.Colors.divider, lineWidth: 1)
                )
        }
    }
    private var sendButton: some View {
        Button {
            Task {
                await sendNutZap()
            }
        } label: {
            HStack(spacing: OlasDesign.Spacing.sm) {
                if isSending {
                    ProgressView()
                        .tint(.white)
                        .scaleEffect(0.8)
                } else {
                    Image(systemName: "bolt.heart.fill")
                }
                Text(isSending ? "Sending..." : "Send NutZap")
            }
            .font(OlasDesign.Typography.bodyMedium)
            .foregroundColor(.white)
            .frame(maxWidth: .infinity)
            .padding(.vertical, OlasDesign.Spacing.md)
            .background(
                LinearGradient(
                    colors: OlasDesign.Colors.primaryGradient,
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .cornerRadius(OlasDesign.CornerRadius.full)
            .shadow(color: OlasDesign.Colors.primary.opacity(0.3), radius: 10, x: 0, y: 5)
        }
        .disabled(isSending || selectedAmount == 0 || (recipientPubkey == nil && selectedUserPubkey == nil))
        .opacity((selectedAmount == 0 || (recipientPubkey == nil && selectedUserPubkey == nil)) ? 0.5 : 1)
    }
    private func loadUserProfile(pubkey: String) async {
        guard let ndk = nostrManager.ndk,
              let profileManager = ndk.profileManager else { return }
        var foundProfile: NDKUserProfile?
        for await profile in await profileManager.observe(for: pubkey, maxAge: 3600) {
            foundProfile = profile
            break // Just get the first one
        }
        if let profile = foundProfile {
            await MainActor.run {
                self.selectedUser = profile
                self.selectedUserPubkey = pubkey
            }
        }
    }
    private func searchUser() async {
        guard !searchQuery.isEmpty else { return }
        await MainActor.run {
            isSearching = true
        }
        defer {
            Task { @MainActor in
                isSearching = false
            }
        }
        // Try to decode npub
        if searchQuery.starts(with: "npub1") {
            // For now, show error for npub search
            await MainActor.run {
                errorMessage = "npub search coming soon. Please use hex pubkey for now."
            }
            return
        }
        // Search by name - for now just show error
        await MainActor.run {
            errorMessage = "Search by name coming soon. Please use npub for now."
        }
    }
    private func sendNutZap() async {
        let targetPubkey = recipientPubkey ?? selectedUserPubkey
        guard let pubkey = targetPubkey else { return }
        await MainActor.run {
            isSending = true
        }
        defer {
            Task { @MainActor in
                isSending = false
            }
        }
        // Find a recent event from the user to zap
        guard let ndk = nostrManager.ndk else { return }
            let filter = NDKFilter(
                authors: [pubkey],
                kinds: [EventKind.textNote],
                limit: 1
            )
            // Use observe to get an event
            let dataSource = ndk.observe(
                filter: filter,
                maxAge: 0,
                cachePolicy: .cacheOnly
            )
            var foundEvent: NDKEvent?
            for await event in dataSource.events {
                foundEvent = event
                break // Just get the first one
            }
        if let event = foundEvent {
            do {
                try await walletManager.zapEvent(event, amount: selectedAmount, comment: comment.isEmpty ? nil : comment)
                await MainActor.run {
                    showSuccess = true
                    OlasDesign.Haptic.success()
                }
            } catch {
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    OlasDesign.Haptic.error()
                }
            }
        } else {
            await MainActor.run {
                errorMessage = "Couldn't find a recent post from this user to zap"
            }
        }
    }
}
</file>

<file path="Olas/Views/Wallet/OlasWalletView.swift">
import SwiftUI
import NDKSwift
struct OlasWalletView: View {
    @ObservedObject var walletManager: OlasWalletManager
    let nostrManager: NostrManager
    @State private var selectedTab = 0
    @State private var showReceive = false
    @State private var showSend = false
    @State private var showAddMint = false
    @State private var showScanner = false
    @State private var showMintManagement = false
    @State private var refreshRotation: Double = 0
    @State private var isRefreshing = false
    @State private var showNutZap = false
    @State private var nutZapRecipient: String?
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationStack {
            ZStack {
                // Modern gradient background
                RadialGradient(
                    gradient: Gradient(colors: [
                        OlasDesign.Colors.background,
                        OlasDesign.Colors.surface.opacity(0.3)
                    ]),
                    center: .top,
                    startRadius: 0,
                    endRadius: 500
                )
                .ignoresSafeArea()
                if !walletManager.isWalletConfigured {
                    // Empty wallet state
                    emptyWalletView
                } else {
                    ScrollView {
                        VStack(spacing: OlasDesign.Spacing.lg) {
                            // Enhanced Balance Card with glassmorphism
                            OlasEnhancedBalanceCard(walletManager: walletManager)
                                .padding(.horizontal, OlasDesign.Spacing.md)
                                .padding(.top, OlasDesign.Spacing.sm)
                        // Quick Stats with glassmorphism
                        quickStats
                            .padding(.horizontal, OlasDesign.Spacing.md)
                        // Contacts for quick sending
                        WalletContactsScrollView(
                            showNutZap: $showNutZap,
                            nutZapRecipient: $nutZapRecipient
                        )
                        .padding(.top, OlasDesign.Spacing.sm)
                        // Modern Action Buttons
                        modernActionButtons
                            .padding(.horizontal, OlasDesign.Spacing.md)
                        // Recent Activity with enhanced UI
                        recentActivity
                        }
                        .padding(.bottom, 100)
                    }
                    .refreshable {
                        await refreshWallet()
                    }
                }
            }
            .navigationTitle("Lightning Wallet")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundStyle(OlasDesign.Colors.textSecondary)
                            .font(.title3)
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        Button {
                            showMintManagement = true
                        } label: {
                            Label("Manage Mints", systemImage: "server.rack")
                        }
                        Button {
                            showAddMint = true
                        } label: {
                            Label("Add Mint", systemImage: "plus.circle")
                        }
                        Button {
                            showNutZap = true
                        } label: {
                            Label("NutZap Someone", systemImage: "bolt.heart")
                        }
                        Divider()
                        Button {
                            // Export wallet backup
                        } label: {
                            Label("Backup Wallet", systemImage: "square.and.arrow.up")
                        }
                    } label: {
                        Image(systemName: "ellipsis.circle")
                            .foregroundStyle(OlasDesign.Colors.primary)
                    }
                }
            }
            .sheet(isPresented: $showReceive) {
                ReceiveView(walletManager: walletManager)
            }
            .sheet(isPresented: $showSend) {
                SendView(walletManager: walletManager)
            }
            .sheet(isPresented: $showAddMint) {
                AddMintView(walletManager: walletManager)
            }
            .sheet(isPresented: $showScanner) {
                QRScannerView { result in
                    handleScannedCode(result)
                }
            }
            .sheet(isPresented: $showMintManagement) {
                MintManagementView(walletManager: walletManager)
            }
            .sheet(isPresented: $showNutZap) {
                NutZapView(walletManager: walletManager, nostrManager: nostrManager, recipientPubkey: nutZapRecipient)
            }
            .task {
                if walletManager.activeWallet == nil {
                    do {
                        try await walletManager.loadWallet()
                    } catch {
                        print("Failed to load wallet: \(error)")
                    }
                }
            }
        }
    }
    private var emptyWalletView: some View {
        VStack(spacing: OlasDesign.Spacing.xl) {
            Spacer()
            // Lightning bolt icon
            Image(systemName: "bolt.circle.fill")
                .font(.system(size: 80))
                .foregroundStyle(
                    LinearGradient(
                        colors: [
                            OlasDesign.Colors.primary,
                            OlasDesign.Colors.primary.opacity(0.7)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .shadow(color: OlasDesign.Colors.primary.opacity(0.3), radius: 20, x: 0, y: 10)
            VStack(spacing: OlasDesign.Spacing.sm) {
                Text("Set Up Your Wallet")
                    .font(OlasDesign.Typography.title2)
                    .foregroundStyle(OlasDesign.Colors.text)
                Text("Add a mint to start using Lightning")
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                    .multilineTextAlignment(.center)
            }
            Button {
                showAddMint = true
                OlasDesign.Haptic.selection()
            } label: {
                HStack(spacing: OlasDesign.Spacing.sm) {
                    Image(systemName: "plus.circle.fill")
                    Text("Add Your First Mint")
                }
                .font(OlasDesign.Typography.bodyMedium)
                .foregroundColor(.white)
                .padding(.horizontal, OlasDesign.Spacing.lg)
                .padding(.vertical, OlasDesign.Spacing.md)
                .background(
                    LinearGradient(
                        colors: OlasDesign.Colors.primaryGradient,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .cornerRadius(OlasDesign.CornerRadius.full)
                .shadow(color: OlasDesign.Colors.primary.opacity(0.3), radius: 10, x: 0, y: 5)
            }
            Spacer()
            Spacer()
        }
        .padding(.horizontal, OlasDesign.Spacing.xl)
    }
    private var quickStats: some View {
        HStack(spacing: OlasDesign.Spacing.sm) {
            // Total Mints
            ModernStatCard(
                icon: "server.rack",
                value: "\(walletManager.mintURLs.count)",
                label: "Mints",
                gradient: [Color(hex: "3B82F6"), Color(hex: "1E40AF")]
            )
            // Active Balance
            ModernStatCard(
                icon: "bitcoinsign.circle.fill",
                value: formatCompactBalance(walletManager.currentBalance),
                label: "Balance",
                gradient: [Color(hex: "F97316"), Color(hex: "EA580C")]
            )
            // Today's Activity
            ModernStatCard(
                icon: "arrow.up.arrow.down",
                value: "\(walletManager.recentTransactions.filter { Calendar.current.isDateInToday($0.timestamp) }.count)",
                label: "Today",
                gradient: [Color(hex: "10B981"), Color(hex: "059669")]
            )
        }
    }
    private func formatCompactBalance(_ sats: Int64) -> String {
        if sats >= 1_000_000 {
            return String(format: "%.1fM", Double(sats) / 1_000_000)
        } else if sats >= 1_000 {
            return String(format: "%.1fk", Double(sats) / 1_000)
        } else {
            return "\(sats)"
        }
    }
    private var todaysTransactionCount: Int {
        return 0 // Handled inline now
    }
    private var actionButtons: some View {
        HStack(spacing: OlasDesign.Spacing.sm) {
            // Receive Button
            ActionButton(
                icon: "arrow.down.circle.fill",
                title: "Receive",
                gradient: [Color.green, Color.green.opacity(0.8)]
            ) {
                showReceive = true
            }
            // Send Button
            ActionButton(
                icon: "arrow.up.circle.fill",
                title: "Send",
                gradient: [Color.orange, Color.orange.opacity(0.8)]
            ) {
                showSend = true
            }
            // Scan Button
            ActionButton(
                icon: "qrcode.viewfinder",
                title: "Scan",
                gradient: [OlasDesign.Colors.primary, OlasDesign.Colors.primary.opacity(0.8)]
            ) {
                showScanner = true
            }
        }
    }
    private var recentActivity: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            // Section header
            HStack {
                HStack(spacing: OlasDesign.Spacing.sm) {
                    Image(systemName: "clock.arrow.circlepath")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundStyle(OlasDesign.Colors.primary)
                    Text("Recent Activity")
                        .font(OlasDesign.Typography.title3)
                        .foregroundStyle(OlasDesign.Colors.text)
                }
                Spacer()
                if !walletManager.recentTransactions.isEmpty {
                    NavigationLink(destination: Text("Transaction History")) {
                        HStack(spacing: 4) {
                            Text("See All")
                                .font(OlasDesign.Typography.caption)
                            Image(systemName: "chevron.right")
                                .font(.system(size: 10, weight: .semibold))
                        }
                        .foregroundStyle(OlasDesign.Colors.primary)
                    }
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            if walletManager.recentTransactions.isEmpty {
                EmptyActivityView()
                    .padding(.horizontal, OlasDesign.Spacing.md)
            } else {
                // Show last 5 transactions with modern design
                VStack(spacing: OlasDesign.Spacing.xs) {
                    ForEach(walletManager.recentTransactions.prefix(5)) { transaction in
                        ModernTransactionRow(transaction: transaction, walletManager: walletManager)
                            .transition(.asymmetric(
                                insertion: .push(from: .bottom).combined(with: .opacity),
                                removal: .push(from: .top).combined(with: .opacity)
                            ))
                    }
                }
                .padding(OlasDesign.Spacing.sm)
                .background(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                        .fill(OlasDesign.Colors.surface.opacity(0.5))
                        .overlay(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                                .stroke(
                                    LinearGradient(
                                        colors: [
                                            Color.white.opacity(0.1),
                                            Color.white.opacity(0.05)
                                        ],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ),
                                    lineWidth: 1
                                )
                        )
                )
                .padding(.horizontal, OlasDesign.Spacing.md)
            }
        }
    }
    private func refreshWallet() async {
        do {
            try await walletManager.loadWallet()
            OlasDesign.Haptic.selection()
        } catch {
            print("Failed to refresh wallet: \(error)")
        }
    }
    private func handleScannedCode(_ code: String) {
        showScanner = false
        // Handle different QR code types
        if code.lowercased().starts(with: "lightning:") || code.lowercased().starts(with: "lnurl") {
            // Lightning invoice or LNURL
            showSend = true
            // Pass the code to SendView
        } else if code.lowercased().starts(with: "cashu:") {
            // Cashu token
            Task {
                do {
                    try await walletManager.receiveEcash(code)
                } catch {
                    print("Failed to redeem token: \(error)")
                }
            }
        } else if code.lowercased().starts(with: "https://") {
            // Might be a mint URL
            showAddMint = true
        }
    }
    private var modernActionButtons: some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            FloatingActionButton(
                icon: "arrow.down.circle.fill",
                title: "Receive",
                gradient: [Color(hex: "4ECDC4"), Color(hex: "44A08D")],
                action: { showReceive = true }
            )
            FloatingActionButton(
                icon: "arrow.up.circle.fill",
                title: "Send",
                gradient: [Color(hex: "F56565"), Color(hex: "D53F8C")],
                action: { showSend = true }
            )
            FloatingActionButton(
                icon: "qrcode.viewfinder",
                title: "Scan",
                gradient: [Color(hex: "805AD5"), Color(hex: "6B46C1")],
                action: { showScanner = true }
            )
        }
    }
}
// MARK: - Mint Row
struct MintRow: View {
    let mintURL: String
    let balance: Int64
    var body: some View {
        HStack {
            Circle()
                .fill(Color.green)
                .frame(width: 8, height: 8)
            VStack(alignment: .leading, spacing: 2) {
                Text(mintURL.replacingOccurrences(of: "https://", with: ""))
                    .font(OlasDesign.Typography.bodyMedium)
                    .foregroundColor(OlasDesign.Colors.text)
                    .lineLimit(1)
                Text("Active mint")
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textTertiary)
                    .lineLimit(1)
            }
            Spacer()
            Text("\(balance) sats")
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .padding(OlasDesign.Spacing.md)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
                .fill(OlasDesign.Colors.surface)
        )
    }
}
// MARK: - Transaction Row
struct TransactionRow: View {
    let transaction: OlasWalletManager.WalletTransaction
    let walletManager: OlasWalletManager
    @State private var showDetail = false
    private var transactionIcon: String {
        switch transaction.type {
        case .sent, .melted: return "arrow.up.circle.fill"
        case .received, .minted: return "arrow.down.circle.fill"
        case .zapped, .nutzapped: return "bolt.heart.fill"
        case .swapped: return "arrow.triangle.swap"
        }
    }
    private var transactionColor: Color {
        switch transaction.type {
        case .sent, .melted: return Color.orange
        case .received, .minted: return Color.green
        case .zapped, .nutzapped: return Color.purple
        case .swapped: return Color.blue
        }
    }
    var body: some View {
        Button {
            showDetail = true
            OlasDesign.Haptic.selection()
        } label: {
            HStack(spacing: OlasDesign.Spacing.md) {
                // Icon with gradient background
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [
                                    transactionColor.opacity(0.2),
                                    transactionColor.opacity(0.1)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 44, height: 44)
                    Image(systemName: transactionIcon)
                        .font(.system(size: 20))
                        .foregroundStyle(transactionColor)
                }
                // Transaction details
                VStack(alignment: .leading, spacing: 4) {
                    Text(transaction.description)
                        .font(OlasDesign.Typography.bodyMedium)
                        .foregroundColor(OlasDesign.Colors.text)
                        .lineLimit(1)
                    HStack(spacing: 4) {
                        Text(formatRelativeTime(transaction.timestamp))
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textTertiary)
                        if let mint = transaction.mint {
                            Text("")
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                            Text(formatMintName(mint))
                                .font(OlasDesign.Typography.caption)
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                                .lineLimit(1)
                        }
                    }
                }
                Spacer()
                // Amount
                VStack(alignment: .trailing, spacing: 2) {
                    let isIncoming = transaction.direction == .incoming || 
                        transaction.type == .received || 
                        transaction.type == .minted
                    Text("\(isIncoming ? "+" : "-")\(formatAmount(transaction.amount))")
                        .font(.system(size: 16, weight: .semibold, design: .rounded))
                        .foregroundColor(transactionColor)
                    Text("sats")
                        .font(.system(size: 11))
                        .foregroundColor(OlasDesign.Colors.textTertiary)
                }
            }
            .padding(.vertical, OlasDesign.Spacing.sm)
        }
        .buttonStyle(PlainButtonStyle())
        .sheet(isPresented: $showDetail) {
            TransactionDetailView(transaction: transaction, walletManager: walletManager)
        }
    }
    private func formatAmount(_ amount: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: amount)) ?? "0"
    }
    private func formatRelativeTime(_ date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
    private func formatMintName(_ mint: String) -> String {
        if let url = URL(string: mint),
           let host = url.host {
            return host.replacingOccurrences(of: "www.", with: "")
        }
        return mint
    }
}
// MARK: - Supporting Types
struct CashuToken: Identifiable {
    let id: String
    let amount: Int
    let mint: String
}
enum TransactionType {
    case sent
    case received
}
</file>

<file path="Olas/Views/Wallet/QRScannerView.swift">
import SwiftUI
import AVFoundation
struct QRScannerView: UIViewControllerRepresentable {
    let completion: (String) -> Void
    @Environment(\.dismiss) private var dismiss
    func makeUIViewController(context: Context) -> QRScannerViewController {
        let controller = QRScannerViewController()
        controller.completion = { result in
            completion(result)
            dismiss()
        }
        return controller
    }
    func updateUIViewController(_ uiViewController: QRScannerViewController, context: Context) {}
}
class QRScannerViewController: UIViewController, AVCaptureMetadataOutputObjectsDelegate {
    var captureSession: AVCaptureSession!
    var previewLayer: AVCaptureVideoPreviewLayer!
    var completion: ((String) -> Void)?
    private let scannerOverlay = UIView()
    private let cornerLength: CGFloat = 30
    private let cornerWidth: CGFloat = 4
    private let scanAreaSize: CGFloat = 280
    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = UIColor.black
        // Setup camera
        setupCamera()
        // Add overlay
        setupOverlay()
        // Add close button
        setupCloseButton()
        // Add instructions
        setupInstructions()
    }
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        if captureSession?.isRunning == false {
            DispatchQueue.global(qos: .userInitiated).async { [weak self] in
                self?.captureSession.startRunning()
            }
        }
    }
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        if captureSession?.isRunning == true {
            captureSession.stopRunning()
        }
    }
    private func setupCamera() {
        captureSession = AVCaptureSession()
        guard let videoCaptureDevice = AVCaptureDevice.default(for: .video) else {
            showError("No camera available")
            return
        }
        let videoInput: AVCaptureDeviceInput
        do {
            videoInput = try AVCaptureDeviceInput(device: videoCaptureDevice)
        } catch {
            showError("Camera input error")
            return
        }
        if captureSession.canAddInput(videoInput) {
            captureSession.addInput(videoInput)
        } else {
            showError("Could not add video input")
            return
        }
        let metadataOutput = AVCaptureMetadataOutput()
        if captureSession.canAddOutput(metadataOutput) {
            captureSession.addOutput(metadataOutput)
            metadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)
            metadataOutput.metadataObjectTypes = [.qr]
        } else {
            showError("Could not add metadata output")
            return
        }
        previewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
        previewLayer.frame = view.layer.bounds
        previewLayer.videoGravity = .resizeAspectFill
        view.layer.addSublayer(previewLayer)
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            self?.captureSession.startRunning()
        }
    }
    private func setupOverlay() {
        // Semi-transparent overlay
        let overlayPath = UIBezierPath(rect: view.bounds)
        let scanPath = UIBezierPath(roundedRect: CGRect(
            x: (view.bounds.width - scanAreaSize) / 2,
            y: (view.bounds.height - scanAreaSize) / 2,
            width: scanAreaSize,
            height: scanAreaSize
        ), cornerRadius: 20)
        overlayPath.append(scanPath)
        overlayPath.usesEvenOddFillRule = true
        let fillLayer = CAShapeLayer()
        fillLayer.path = overlayPath.cgPath
        fillLayer.fillRule = .evenOdd
        fillLayer.fillColor = UIColor.black.withAlphaComponent(0.6).cgColor
        view.layer.addSublayer(fillLayer)
        // Corner guides
        let scanRect = CGRect(
            x: (view.bounds.width - scanAreaSize) / 2,
            y: (view.bounds.height - scanAreaSize) / 2,
            width: scanAreaSize,
            height: scanAreaSize
        )
        // Top-left corner
        addCorner(at: CGPoint(x: scanRect.minX, y: scanRect.minY), start: .right, end: .down)
        // Top-right corner
        addCorner(at: CGPoint(x: scanRect.maxX, y: scanRect.minY), start: .down, end: .left)
        // Bottom-left corner
        addCorner(at: CGPoint(x: scanRect.minX, y: scanRect.maxY), start: .up, end: .right)
        // Bottom-right corner
        addCorner(at: CGPoint(x: scanRect.maxX, y: scanRect.maxY), start: .left, end: .up)
        // Scanning animation
        addScanningAnimation(in: scanRect)
    }
    private func addCorner(at point: CGPoint, start: Direction, end: Direction) {
        let path = UIBezierPath()
        switch start {
        case .right:
            path.move(to: CGPoint(x: point.x, y: point.y))
            path.addLine(to: CGPoint(x: point.x + cornerLength, y: point.y))
        case .down:
            path.move(to: CGPoint(x: point.x, y: point.y))
            path.addLine(to: CGPoint(x: point.x, y: point.y + cornerLength))
        case .left:
            path.move(to: CGPoint(x: point.x, y: point.y))
            path.addLine(to: CGPoint(x: point.x - cornerLength, y: point.y))
        case .up:
            path.move(to: CGPoint(x: point.x, y: point.y))
            path.addLine(to: CGPoint(x: point.x, y: point.y - cornerLength))
        }
        path.move(to: point)
        switch end {
        case .right:
            path.addLine(to: CGPoint(x: point.x + cornerLength, y: point.y))
        case .down:
            path.addLine(to: CGPoint(x: point.x, y: point.y + cornerLength))
        case .left:
            path.addLine(to: CGPoint(x: point.x - cornerLength, y: point.y))
        case .up:
            path.addLine(to: CGPoint(x: point.x, y: point.y - cornerLength))
        }
        let cornerLayer = CAShapeLayer()
        cornerLayer.path = path.cgPath
        cornerLayer.strokeColor = UIColor.white.cgColor
        cornerLayer.fillColor = UIColor.clear.cgColor
        cornerLayer.lineWidth = cornerWidth
        cornerLayer.lineCap = .round
        view.layer.addSublayer(cornerLayer)
    }
    private func addScanningAnimation(in rect: CGRect) {
        let scanLine = UIView()
        scanLine.backgroundColor = UIColor.white.withAlphaComponent(0.8)
        scanLine.frame = CGRect(
            x: rect.minX + 10,
            y: rect.minY,
            width: rect.width - 20,
            height: 2
        )
        view.addSubview(scanLine)
        // Add gradient effect
        let gradient = CAGradientLayer()
        gradient.frame = scanLine.bounds
        gradient.colors = [
            UIColor.clear.cgColor,
            UIColor.white.cgColor,
            UIColor.clear.cgColor
        ]
        gradient.startPoint = CGPoint(x: 0, y: 0.5)
        gradient.endPoint = CGPoint(x: 1, y: 0.5)
        scanLine.layer.addSublayer(gradient)
        // Animate
        UIView.animate(withDuration: 2, delay: 0, options: [.repeat, .autoreverse], animations: {
            scanLine.frame.origin.y = rect.maxY - 2
        })
    }
    private func setupCloseButton() {
        let closeButton = UIButton(type: .system)
        closeButton.setImage(UIImage(systemName: "xmark.circle.fill"), for: .normal)
        closeButton.tintColor = .white
        closeButton.transform = CGAffineTransform(scaleX: 1.5, y: 1.5)
        closeButton.addTarget(self, action: #selector(closeTapped), for: .touchUpInside)
        closeButton.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(closeButton)
        NSLayoutConstraint.activate([
            closeButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20),
            closeButton.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20)
        ])
    }
    private func setupInstructions() {
        let instructionLabel = UILabel()
        instructionLabel.text = "Point camera at QR code"
        instructionLabel.textColor = .white
        instructionLabel.font = .systemFont(ofSize: 18, weight: .medium)
        instructionLabel.textAlignment = .center
        instructionLabel.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(instructionLabel)
        NSLayoutConstraint.activate([
            instructionLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            instructionLabel.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -50)
        ])
    }
    @objc private func closeTapped() {
        dismiss(animated: true)
    }
    private func showError(_ message: String) {
        let alert = UIAlertController(title: "Scanner Error", message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
            self.dismiss(animated: true)
        })
        present(alert, animated: true)
    }
    // MARK: - AVCaptureMetadataOutputObjectsDelegate
    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) {
        captureSession.stopRunning()
        if let metadataObject = metadataObjects.first {
            guard let readableObject = metadataObject as? AVMetadataMachineReadableCodeObject else { return }
            guard let stringValue = readableObject.stringValue else { return }
            // Haptic feedback
            let generator = UINotificationFeedbackGenerator()
            generator.notificationOccurred(.success)
            completion?(stringValue)
        }
    }
    enum Direction {
        case up, down, left, right
    }
}
</file>

<file path="Olas/Views/Wallet/ReceiveView.swift">
import SwiftUI
import CoreImage.CIFilterBuiltins
#if canImport(UIKit)
import UIKit
#elseif canImport(AppKit)
import AppKit
#endif
struct ReceiveView: View {
    @ObservedObject var walletManager: OlasWalletManager
    @Environment(\.dismiss) var dismiss
    @State private var amount = ""
    @State private var description = ""
    @State private var invoice = ""
    @State private var isGenerating = false
    @State private var showingCopiedAlert = false
    var body: some View {
        NavigationView {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                ScrollView {
                    VStack(spacing: OlasDesign.Spacing.xl) {
                        // Header
                        VStack(spacing: OlasDesign.Spacing.md) {
                            Circle()
                                .fill(
                                    LinearGradient(
                                        colors: [Color(hex: "4ECDC4"), Color(hex: "44A08D")],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 80, height: 80)
                                .overlay(
                                    Image(systemName: "qrcode")
                                        .font(.system(size: 40))
                                        .foregroundColor(.white)
                                )
                            Text("Receive Sats")
                                .font(OlasDesign.Typography.title)
                                .foregroundStyle(OlasDesign.Colors.text)
                        }
                        .padding(.top, OlasDesign.Spacing.lg)
                        // Input fields
                        VStack(spacing: OlasDesign.Spacing.md) {
                            // Amount input
                            VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                                Text("Amount (optional)")
                                    .font(OlasDesign.Typography.caption)
                                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                                HStack {
                                    Image(systemName: "bitcoinsign.circle")
                                        .font(.title2)
                                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                                    TextField("0", text: $amount)
                                        .font(OlasDesign.Typography.body)
                                        .foregroundStyle(OlasDesign.Colors.text)
                                        #if os(iOS)
                                        .keyboardType(.numberPad)
                                        #endif
                                    Text("sats")
                                        .font(OlasDesign.Typography.body)
                                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                                }
                                .padding(OlasDesign.Spacing.md)
                                .background(
                                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                        .fill(OlasDesign.Colors.surface)
                                )
                            }
                            // Description input
                            VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                                Text("Description (optional)")
                                    .font(OlasDesign.Typography.caption)
                                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                                HStack {
                                    Image(systemName: "text.alignleft")
                                        .font(.title2)
                                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                                    TextField("What's this for?", text: $description)
                                        .font(OlasDesign.Typography.body)
                                        .foregroundStyle(OlasDesign.Colors.text)
                                }
                                .padding(OlasDesign.Spacing.md)
                                .background(
                                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                        .fill(OlasDesign.Colors.surface)
                                )
                            }
                        }
                        .padding(.horizontal, OlasDesign.Spacing.md)
                        // Generate button
                        OlasButton(
                            title: "Generate Invoice",
                            action: {
                                Task {
                                    await generateInvoice()
                                }
                            },
                            style: .primary,
                            isLoading: isGenerating
                        )
                        .padding(.horizontal, OlasDesign.Spacing.md)
                        // Invoice display
                        if !invoice.isEmpty {
                            VStack(spacing: OlasDesign.Spacing.md) {
                                // QR Code
                                if let qrImage = generateQRCode(from: invoice) {
                                    #if canImport(UIKit)
                                    Image(uiImage: qrImage)
                                        .interpolation(.none)
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 250, height: 250)
                                        .padding()
                                        .background(Color.white)
                                        .cornerRadius(OlasDesign.CornerRadius.lg)
                                    #elseif canImport(AppKit)
                                    Image(nsImage: qrImage)
                                        .resizable()
                                        .scaledToFit()
                                        .frame(width: 250, height: 250)
                                        .padding()
                                        .background(Color.white)
                                        .cornerRadius(OlasDesign.CornerRadius.lg)
                                    #endif
                                }
                                // Invoice text
                                VStack(spacing: OlasDesign.Spacing.sm) {
                                    Text("Lightning Invoice")
                                        .font(OlasDesign.Typography.caption)
                                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                                    Text(invoice)
                                        .font(.system(.caption, design: .monospaced))
                                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                                        .lineLimit(3)
                                        .truncationMode(.middle)
                                        .padding()
                                        .background(OlasDesign.Colors.surface)
                                        .cornerRadius(OlasDesign.CornerRadius.md)
                                }
                                .padding(.horizontal, OlasDesign.Spacing.md)
                                // Copy button
                                OlasButton(
                                    title: showingCopiedAlert ? "Copied!" : "Copy Invoice",
                                    action: {
                                        copyInvoice()
                                    },
                                    style: .secondary
                                )
                                .padding(.horizontal, OlasDesign.Spacing.md)
                            }
                        }
                        Spacer(minLength: 100)
                    }
                }
            }
            .navigationTitle("Receive")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            .toolbar {
                ToolbarItem(placement: {
                    #if os(iOS)
                    .navigationBarTrailing
                    #else
                    .automatic
                    #endif
                }()) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundStyle(OlasDesign.Colors.text)
                }
            }
        }
    }
    private func generateInvoice() async {
        isGenerating = true
        defer { isGenerating = false }
        let satsAmount = Int64(amount) ?? 0
        do {
            invoice = try await walletManager.generateInvoice(
                amount: satsAmount,
                description: description.isEmpty ? nil : description
            )
            OlasDesign.Haptic.success()
        } catch {
            print("Error generating invoice: \(error)")
            OlasDesign.Haptic.error()
        }
    }
    private func copyInvoice() {
        #if os(iOS)
        UIPasteboard.general.string = invoice
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(invoice, forType: .string)
        #endif
        showingCopiedAlert = true
        OlasDesign.Haptic.success()
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            showingCopiedAlert = false
        }
    }
    #if canImport(UIKit)
    private func generateQRCode(from string: String) -> UIImage? {
        let context = CIContext()
        let filter = CIFilter.qrCodeGenerator()
        filter.setValue(Data(string.utf8), forKey: "inputMessage")
        if let outputImage = filter.outputImage {
            let scaledImage = outputImage.transformed(by: CGAffineTransform(scaleX: 10, y: 10))
            if let cgImage = context.createCGImage(scaledImage, from: scaledImage.extent) {
                return UIImage(cgImage: cgImage)
            }
        }
        return nil
    }
    #elseif canImport(AppKit)
    private func generateQRCode(from string: String) -> NSImage? {
        let context = CIContext()
        let filter = CIFilter.qrCodeGenerator()
        filter.setValue(Data(string.utf8), forKey: "inputMessage")
        if let outputImage = filter.outputImage {
            let scaledImage = outputImage.transformed(by: CGAffineTransform(scaleX: 10, y: 10))
            if let cgImage = context.createCGImage(scaledImage, from: scaledImage.extent) {
                return NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
            }
        }
        return nil
    }
    #endif
}
// End of ReceiveView.swift
</file>

<file path="Olas/Views/Wallet/SendView.swift">
import SwiftUI
import NDKSwift
import CoreImage.CIFilterBuiltins
struct SendView: View {
    @ObservedObject var walletManager: OlasWalletManager
    @Environment(NostrManager.self) private var nostrManager
    @Environment(\.dismiss) var dismiss
    @State private var sendMode: SendMode = .lightning
    @State private var invoice = ""
    @State private var amount = ""
    @State private var comment = ""
    @State private var isSending = false
    @State private var errorMessage: String?
    @State private var showingSuccess = false
    @State private var showingScanner = false
    @State private var ecashToken: String?
    @State private var showingShareSheet = false
    @State private var selectedPresetAmount: Int64?
    @FocusState private var isAmountFocused: Bool
    @FocusState private var isInvoiceFocused: Bool
    enum SendMode {
        case lightning
        case ecash
    }
    let presetAmounts: [Int64] = [100, 500, 1000, 5000, 10000, 50000]
    var body: some View {
        NavigationView {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                ScrollView {
                    VStack(spacing: OlasDesign.Spacing.xl) {
                        // Mode selector
                        modeSelectorView
                            .padding(.top, OlasDesign.Spacing.md)
                        // Balance display
                        balanceView
                        switch sendMode {
                        case .lightning:
                            lightningView
                        case .ecash:
                            ecashView
                        }
                        Spacer(minLength: 100)
                    }
                    .padding(.horizontal, OlasDesign.Spacing.md)
                }
                // Loading overlay
                if isSending {
                    loadingOverlay
                }
            }
            .navigationTitle("Send")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundStyle(OlasDesign.Colors.text)
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Send") {
                        Task {
                            await sendPayment()
                        }
                    }
                    .disabled(!canSend || isSending)
                    .font(OlasDesign.Typography.bodyBold)
                }
            }
            .alert("Success", isPresented: $showingSuccess) {
                Button("OK") {
                    dismiss()
                }
            } message: {
                Text("Payment sent successfully!")
            }
            .sheet(isPresented: $showingScanner) {
                QRScannerView { result in
                    handleScannedQR(result)
                }
            }
            .sheet(isPresented: $showingShareSheet) {
                if let token = ecashToken {
                    ShareSheet(items: [token])
                }
            }
        }
    }
    // MARK: - Views
    private var modeSelectorView: some View {
        HStack(spacing: 0) {
            ForEach([SendMode.lightning, SendMode.ecash], id: \.self) { mode in
                Button {
                    withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                        sendMode = mode
                    }
                    OlasDesign.Haptic.selection()
                } label: {
                    VStack(spacing: OlasDesign.Spacing.xs) {
                        Image(systemName: mode == .lightning ? "bolt.fill" : "banknote")
                            .font(.title2)
                            .foregroundStyle(sendMode == mode ? OlasDesign.Colors.primary : OlasDesign.Colors.textSecondary)
                        Text(mode == .lightning ? "Lightning" : "Ecash")
                            .font(OlasDesign.Typography.bodyMedium)
                            .foregroundStyle(sendMode == mode ? OlasDesign.Colors.text : OlasDesign.Colors.textSecondary)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, OlasDesign.Spacing.md)
                    .background(
                        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                            .fill(sendMode == mode ? OlasDesign.Colors.primary.opacity(0.1) : Color.clear)
                    )
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(4)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .fill(OlasDesign.Colors.surface)
        )
    }
    private var balanceView: some View {
        VStack(spacing: OlasDesign.Spacing.xs) {
            Text("Available Balance")
                .font(OlasDesign.Typography.caption)
                .foregroundStyle(OlasDesign.Colors.textSecondary)
            HStack(alignment: .firstTextBaseline, spacing: 4) {
                Text(formatSats(walletManager.currentBalance))
                    .font(.system(size: 28, weight: .bold, design: .rounded))
                    .foregroundStyle(OlasDesign.Colors.text)
                    .contentTransition(.numericText())
                Text("sats")
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
            }
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, OlasDesign.Spacing.md)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .fill(OlasDesign.Colors.surface)
        )
    }
    private var lightningView: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            // Invoice input
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                Label("Lightning Invoice", systemImage: "doc.text")
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                HStack {
                    TextField("Paste invoice or scan QR", text: $invoice)
                        .textFieldStyle(PlainTextFieldStyle())
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                        .focused($isInvoiceFocused)
                    Button {
                        showingScanner = true
                        OlasDesign.Haptic.selection()
                    } label: {
                        Image(systemName: "qrcode.viewfinder")
                            .font(.title2)
                            .foregroundStyle(OlasDesign.Colors.primary)
                    }
                }
                .padding(OlasDesign.Spacing.md)
                .background(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                        .fill(OlasDesign.Colors.surface)
                        .overlay(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                .stroke(
                                    isInvoiceFocused ? OlasDesign.Colors.primary : Color.clear,
                                    lineWidth: 2
                                )
                        )
                )
            }
            // Comment input
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                Label("Note (optional)", systemImage: "text.bubble")
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                TextField("Add a note", text: $comment)
                    .textFieldStyle(PlainTextFieldStyle())
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                    .padding(OlasDesign.Spacing.md)
                    .background(
                        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                            .fill(OlasDesign.Colors.surface)
                    )
            }
            if let error = errorMessage {
                errorView(error)
            }
        }
    }
    private var ecashView: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            // Amount input
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                Label("Amount", systemImage: "bitcoinsign.circle")
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                HStack {
                    TextField("0", text: $amount)
                        .textFieldStyle(PlainTextFieldStyle())
                        .font(.system(size: 28, weight: .bold, design: .rounded))
                        .foregroundColor(OlasDesign.Colors.text)
                        .keyboardType(.numberPad)
                        .focused($isAmountFocused)
                        .onChange(of: amount) { _ in
                            selectedPresetAmount = nil
                        }
                    Text("sats")
                        .font(OlasDesign.Typography.body)
                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                }
                .padding(OlasDesign.Spacing.md)
                .background(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                        .fill(OlasDesign.Colors.surface)
                        .overlay(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                .stroke(
                                    isAmountFocused ? OlasDesign.Colors.primary : Color.clear,
                                    lineWidth: 2
                                )
                        )
                )
                // Preset amounts
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: OlasDesign.Spacing.sm) {
                        ForEach(presetAmounts, id: \.self) { preset in
                            PresetAmountButton(
                                amount: preset,
                                isSelected: selectedPresetAmount == preset
                            ) {
                                selectedPresetAmount = preset
                                amount = String(preset)
                                isAmountFocused = false
                                OlasDesign.Haptic.selection()
                            }
                        }
                    }
                }
            }
            // Comment input
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                Label("Note (optional)", systemImage: "text.bubble")
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                TextField("Add a note", text: $comment)
                    .textFieldStyle(PlainTextFieldStyle())
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                    .padding(OlasDesign.Spacing.md)
                    .background(
                        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                            .fill(OlasDesign.Colors.surface)
                    )
            }
            if let token = ecashToken {
                // Show generated token
                VStack(spacing: OlasDesign.Spacing.md) {
                    Text("Ecash token generated!")
                        .font(OlasDesign.Typography.bodyBold)
                        .foregroundStyle(OlasDesign.Colors.success)
                    Text(token)
                        .font(.system(.caption, design: .monospaced))
                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                        .lineLimit(3)
                        .padding(OlasDesign.Spacing.md)
                        .background(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                                .fill(OlasDesign.Colors.surface)
                        )
                    Button {
                        showingShareSheet = true
                        OlasDesign.Haptic.selection()
                    } label: {
                        HStack {
                            Image(systemName: "square.and.arrow.up")
                            Text("Share Token")
                        }
                        .font(OlasDesign.Typography.bodyMedium)
                        .foregroundStyle(.white)
                        .padding(.horizontal, OlasDesign.Spacing.xl)
                        .padding(.vertical, OlasDesign.Spacing.md)
                        .background(
                            LinearGradient(
                                colors: OlasDesign.Colors.primaryGradient,
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full))
                    }
                }
            }
            if let error = errorMessage {
                errorView(error)
            }
        }
    }
    private func errorView(_ error: String) -> some View {
        HStack {
            Image(systemName: "exclamationmark.triangle.fill")
                .foregroundStyle(OlasDesign.Colors.error)
            Text(error)
                .font(OlasDesign.Typography.caption)
                .foregroundStyle(OlasDesign.Colors.error)
        }
        .padding(OlasDesign.Spacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .fill(OlasDesign.Colors.error.opacity(0.1))
        )
    }
    private var loadingOverlay: some View {
        ZStack {
            Color.black.opacity(0.5)
                .ignoresSafeArea()
            VStack(spacing: OlasDesign.Spacing.md) {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                    .scaleEffect(1.5)
                Text(sendMode == .lightning ? "Processing payment..." : "Creating ecash token...")
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(.white)
            }
            .padding(OlasDesign.Spacing.xl)
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                    .fill(OlasDesign.Colors.surface)
            )
            .shadow(radius: 20)
        }
    }
    // MARK: - Computed Properties
    private var canSend: Bool {
        switch sendMode {
        case .lightning:
            return !invoice.isEmpty
        case .ecash:
            return !amount.isEmpty && Int64(amount) != nil
        }
    }
    // MARK: - Methods
    private func sendPayment() async {
        isSending = true
        errorMessage = nil
        ecashToken = nil
        do {
            switch sendMode {
            case .lightning:
                try await walletManager.payInvoice(invoice, comment: comment.isEmpty ? nil : comment)
                OlasDesign.Haptic.success()
                showingSuccess = true
            case .ecash:
                guard let amountSats = Int64(amount) else {
                    errorMessage = "Invalid amount"
                    isSending = false
                    return
                }
                let token = try await walletManager.sendEcash(
                    amount: amountSats,
                    comment: comment.isEmpty ? nil : comment
                )
                ecashToken = token
                OlasDesign.Haptic.success()
            }
        } catch {
            errorMessage = error.localizedDescription
            OlasDesign.Haptic.error()
        }
        isSending = false
    }
    private func handleScannedQR(_ result: String) {
        if result.lowercased().starts(with: "lightning:") {
            invoice = result.replacingOccurrences(of: "lightning:", with: "")
        } else if result.lowercased().starts(with: "lnbc") {
            invoice = result
        } else {
            errorMessage = "Invalid QR code"
        }
    }
    private func formatSats(_ sats: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: sats)) ?? "0"
    }
    private func formatAmount(_ sats: Int64) -> String {
        if sats >= 1000 {
            return "\(sats / 1000)k"
        }
        return "\(sats)"
    }
}
// MARK: - Supporting Views
struct PresetAmountButton: View {
    let amount: Int64
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: 2) {
                Text(formatAmount(amount))
                    .font(OlasDesign.Typography.bodyMedium)
                    .foregroundStyle(isSelected ? .white : OlasDesign.Colors.text)
                Text("sats")
                    .font(.system(size: 10))
                    .foregroundStyle(isSelected ? .white.opacity(0.8) : OlasDesign.Colors.textSecondary)
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.sm)
            .background(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .fill(
                        isSelected ?
                        LinearGradient(
                            colors: OlasDesign.Colors.primaryGradient,
                            startPoint: .leading,
                            endPoint: .trailing
                        ) :
                        LinearGradient(
                            colors: [OlasDesign.Colors.surface, OlasDesign.Colors.surface],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
            )
            .overlay(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                    .stroke(
                        isSelected ? Color.clear : OlasDesign.Colors.divider,
                        lineWidth: 1
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
    private func formatAmount(_ amount: Int64) -> String {
        if amount >= 1000 {
            return "\(amount / 1000)k"
        }
        return "\(amount)"
    }
}
</file>

<file path="Olas/Views/Wallet/TransactionDetailView.swift">
import SwiftUI
// MARK: - Particle System
class ParticleSystem: ObservableObject {
    @Published var particles: [Particle] = []
    func emit(count: Int, from origin: CGPoint) {
        for _ in 0..<count {
            let particle = Particle(
                position: origin,
                velocity: CGPoint(
                    x: CGFloat.random(in: -150...150),
                    y: CGFloat.random(in: -300...(-100))
                ),
                color: Color(hex: ["FFA726", "FFD54F", "4ECDC4", "667EEA"].randomElement()!),
                size: CGFloat.random(in: 4...8)
            )
            particles.append(particle)
        }
        // Remove particles after animation
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            self.particles.removeAll()
        }
    }
}
struct Particle: Identifiable {
    let id = UUID()
    var position: CGPoint
    var velocity: CGPoint
    let color: Color
    let size: CGFloat
    var opacity: Double = 1
}
struct ParticleEffectView: View {
    @ObservedObject var particleSystem: ParticleSystem
    @State private var animationTrigger = false
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                ForEach(particleSystem.particles) { particle in
                    Circle()
                        .fill(particle.color)
                        .frame(width: particle.size, height: particle.size)
                        .position(particle.position)
                        .opacity(particle.opacity)
                        .modifier(ParticleModifier(particle: particle))
                }
            }
        }
        .onChange(of: particleSystem.particles.count) { _, _ in
            animationTrigger.toggle()
        }
    }
}
struct ParticleModifier: ViewModifier {
    let particle: Particle
    @State private var offset = CGSize.zero
    @State private var opacity: Double = 1
    func body(content: Content) -> some View {
        content
            .offset(offset)
            .opacity(opacity)
            .onAppear {
                withAnimation(.easeOut(duration: 2)) {
                    offset = CGSize(
                        width: particle.velocity.x,
                        height: particle.velocity.y
                    )
                    opacity = 0
                }
            }
    }
}
// MARK: - Ripple Button
struct RippleButton: View {
    let icon: String
    let title: String
    let gradient: [Color]
    let action: () -> Void
    @State private var rippleScale: CGFloat = 0
    @State private var rippleOpacity: Double = 0
    var body: some View {
        Button(action: {
            // Trigger ripple
            withAnimation(.easeOut(duration: 0.6)) {
                rippleScale = 3
                rippleOpacity = 0
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                rippleScale = 0
                rippleOpacity = 0.4
            }
            OlasDesign.Haptic.selection()
            action()
        }) {
            ZStack {
                // Ripple effect
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [Color.white.opacity(rippleOpacity), Color.clear],
                            center: .center,
                            startRadius: 0,
                            endRadius: 50
                        )
                    )
                    .scaleEffect(rippleScale)
                HStack {
                    Image(systemName: icon)
                    Text(title)
                }
                .font(OlasDesign.Typography.bodyMedium)
                .foregroundStyle(.white)
                .padding(.horizontal, OlasDesign.Spacing.lg)
                .padding(.vertical, OlasDesign.Spacing.md)
            }
            .background(
                LinearGradient(
                    colors: gradient,
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md))
            .shadow(color: gradient[0].opacity(0.3), radius: 8, x: 0, y: 4)
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct TransactionDetailView: View {
    let transaction: OlasWalletManager.WalletTransaction
    @ObservedObject var walletManager: OlasWalletManager
    @Environment(\.dismiss) private var dismiss
    @State private var showingShareSheet = false
    @State private var copiedToClipboard = false
    @State private var animateContent = false
    @State private var showingQRCode = false
    @State private var particleSystem = ParticleSystem()
    var body: some View {
        NavigationStack {
            mainContent
                .navigationTitle("Transaction Details")
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("Done") {
                            dismiss()
                        }
                    }
                }
                .sheet(isPresented: $showingShareSheet) {
                    if let invoice = transaction.invoice {
                        ShareSheet(items: [invoice])
                    }
                }
                .sheet(isPresented: $showingQRCode) {
                    TransactionQRCodeView(content: transaction.invoice ?? transaction.id.uuidString)
                }
        }
    }
    private var mainContent: some View {
        ZStack {
            // Background
            OlasDesign.Colors.background
                .ignoresSafeArea()
            ScrollView(showsIndicators: false) {
                VStack(spacing: OlasDesign.Spacing.xl) {
                    // Transaction Icon with particle effects
                    iconSection
                    // Amount with counter animation
                    amountSection
                        .offset(y: animateContent ? 0 : 50)
                        .opacity(animateContent ? 1 : 0)
                        .animation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.2), value: animateContent)
                    // Status with pulse animation
                    statusSection
                        .offset(y: animateContent ? 0 : 50)
                        .opacity(animateContent ? 1 : 0)
                        .animation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.3), value: animateContent)
                    // Details with glass morphism
                    detailsSection
                        .offset(y: animateContent ? 0 : 50)
                        .opacity(animateContent ? 1 : 0)
                        .animation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.4), value: animateContent)
                    // Actions with ripple effects
                    if transaction.invoice != nil || transaction.status == .pending {
                        actionsSection
                            .offset(y: animateContent ? 0 : 50)
                            .opacity(animateContent ? 1 : 0)
                            .animation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.5), value: animateContent)
                    }
                    Spacer(minLength: 50)
                }
                .padding(.horizontal, OlasDesign.Spacing.md)
            }
            .onAppear {
                withAnimation {
                    animateContent = true
                }
                // Trigger particle effect based on transaction type
                if transaction.status == .completed {
                    #if os(iOS)
                    particleSystem.emit(count: 20, from: CGPoint(x: UIScreen.main.bounds.width / 2, y: 200))
                    #else
                    particleSystem.emit(count: 20, from: CGPoint(x: 400, y: 200))
                    #endif
                }
            }
        }
    }
    private var iconSection: some View {
        ZStack {
            ParticleEffectView(particleSystem: particleSystem)
                .allowsHitTesting(false)
            transactionIcon
                .padding(.top, OlasDesign.Spacing.xl)
                .scaleEffect(animateContent ? 1 : 0.8)
                .opacity(animateContent ? 1 : 0)
                .animation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.1), value: animateContent)
        }
    }
    private var transactionIcon: some View {
        ZStack {
            animatedBackgroundCircles
            centralIcon
        }
        .frame(height: 200)
    }
    private var animatedBackgroundCircles: some View {
        ForEach(0..<4) { index in
            backgroundCircle(for: index)
        }
    }
    private func backgroundCircle(for index: Int) -> some View {
        Circle()
            .stroke(
                LinearGradient(
                    colors: [OlasDesign.Colors.primary.opacity(0.3 - Double(index) * 0.08), OlasDesign.Colors.primary.opacity(0.2 - Double(index) * 0.05)],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                ),
                lineWidth: 2
            )
            .frame(width: CGFloat(100 + index * 25), height: CGFloat(100 + index * 25))
            .scaleEffect(transaction.status == .pending ? 1.1 : 1.0)
            .rotationEffect(.degrees(Double(index) * 45))
            .animation(
                transaction.status == .pending ?
                Animation.linear(duration: Double(3 + index)).repeatForever(autoreverses: false) :
                    .default,
                value: transaction.status
            )
    }
    private var centralIcon: some View {
        ZStack {
            Circle()
                .fill(iconBackground)
                .frame(width: 80, height: 80)
            Image(systemName: iconName)
                .font(.system(size: 35, weight: .semibold))
                .foregroundColor(.white)
                .scaleEffect(transaction.status == .pending ? 1.0 : 1.2)
                .animation(
                    transaction.status == .pending ?
                    Animation.easeInOut(duration: 1).repeatForever(autoreverses: true) :
                        .default,
                    value: transaction.status
                )
        }
        .shadow(color: OlasDesign.Colors.primary.opacity(0.5), radius: 20, x: 0, y: 10)
    }
    private var amountSection: some View {
        VStack(spacing: OlasDesign.Spacing.xs) {
            AnimatedCounterView(
                value: transaction.amount,
                fontSize: 42,
                fontWeight: .bold,
                color: amountColor,
                prefix: transaction.type == .sent || transaction.type == .zapped || transaction.type == .nutzapped ? "-" : "+",
                suffix: " sats"
            )
            if let fiatValue = calculateFiatValue(sats: transaction.amount) {
                Text(fiatValue)
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
            }
        }
        .padding(.top, OlasDesign.Spacing.md)
    }
    private var statusSection: some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            // Status indicator with pulse
            ZStack {
                Circle()
                    .fill(statusColor.opacity(0.2))
                    .frame(width: 40, height: 40)
                if transaction.status == .pending {
                    Circle()
                        .stroke(statusColor, lineWidth: 2)
                        .frame(width: 40, height: 40)
                        .scaleEffect(1.2)
                        .opacity(0)
                        .animation(
                            Animation.easeOut(duration: 1.5)
                                .repeatForever(autoreverses: false),
                            value: transaction.status
                        )
                }
                Image(systemName: statusIcon)
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(statusColor)
            }
            VStack(alignment: .leading, spacing: 2) {
                Text(statusText)
                    .font(OlasDesign.Typography.bodyMedium)
                    .foregroundStyle(OlasDesign.Colors.text)
                Text(transaction.timestamp.formatted())
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
            }
            Spacer()
        }
        .padding(OlasDesign.Spacing.md)
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .fill(OlasDesign.Colors.surface)
                .shadow(color: Color.black.opacity(0.05), radius: 10, x: 0, y: 5)
        )
    }
    private var detailsSection: some View {
        VStack(spacing: 0) {
            DetailRow(
                icon: "rectangle.portrait.and.arrow.right",
                label: "Type",
                value: typeText
            )
            if let mintURL = transaction.mint {
                Divider()
                    .foregroundStyle(OlasDesign.Colors.divider)
                DetailRow(
                    icon: "building.columns",
                    label: "Mint",
                    value: mintURL.replacingOccurrences(of: "https://", with: "")
                )
            }
            if !transaction.description.isEmpty {
                Divider()
                    .foregroundStyle(OlasDesign.Colors.divider)
                DetailRow(
                    icon: "text.quote",
                    label: "Note",
                    value: transaction.description
                )
            }
            if let id = transaction.invoice {
                Divider()
                    .foregroundStyle(OlasDesign.Colors.divider)
                DetailRow(
                    icon: "doc.text",
                    label: "Invoice",
                    value: String(id.prefix(20)) + "...",
                    showCopyButton: true,
                    onCopy: {
                        copyToClipboard(id)
                    }
                )
            }
        }
        .background(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .fill(OlasDesign.Colors.surface)
                .shadow(color: Color.black.opacity(0.05), radius: 10, x: 0, y: 5)
        )
    }
    private var actionsSection: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            if transaction.invoice != nil {
                // View QR Code
                RippleButton(
                    icon: "qrcode",
                    title: "View QR Code",
                    gradient: [Color(hex: "667EEA"), Color(hex: "764BA2")],
                    action: {
                        showingQRCode = true
                    }
                )
                // Share invoice
                RippleButton(
                    icon: "square.and.arrow.up",
                    title: "Share Invoice",
                    gradient: [Color(hex: "4FACFE"), Color(hex: "00F2FE")],
                    action: {
                        showingShareSheet = true
                    }
                )
            }
            if transaction.status == .pending {
                // Cancel transaction (if applicable)
                Button {
                    // TODO: Implement cancel
                    OlasDesign.Haptic.impact(.medium)
                } label: {
                    HStack {
                        Image(systemName: "xmark.circle")
                        Text("Cancel Transaction")
                    }
                    .font(OlasDesign.Typography.bodyMedium)
                    .foregroundStyle(OlasDesign.Colors.error)
                    .frame(maxWidth: .infinity)
                    .padding(OlasDesign.Spacing.md)
                    .background(
                        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                            .stroke(OlasDesign.Colors.error, lineWidth: 1)
                    )
                }
            }
        }
    }
    // MARK: - Computed Properties
    private var iconName: String {
        switch transaction.type {
        case .sent:
            return "paperplane.fill"
        case .received:
            return "arrow.down.circle.fill"
        case .zapped, .nutzapped:
            return "bolt.fill"
        case .minted:
            return "plus.circle.fill"
        case .melted:
            return "flame.fill"
        case .swapped:
            return "arrow.triangle.2.circlepath"
        }
    }
    private var iconBackground: LinearGradient {
        switch transaction.type {
        case .sent:
            return LinearGradient(
                colors: [Color(hex: "FF6B6B"), Color(hex: "FF8E53")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        case .received:
            return LinearGradient(
                colors: [Color(hex: "48BB78"), Color(hex: "68D391")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        case .zapped, .nutzapped:
            return LinearGradient(
                colors: [Color(hex: "805AD5"), Color(hex: "9F7AEA")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        case .minted:
            return LinearGradient(
                colors: [Color(hex: "3182CE"), Color(hex: "4299E1")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        case .melted:
            return LinearGradient(
                colors: [Color(hex: "ED8936"), Color(hex: "F6AD55")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        case .swapped:
            return LinearGradient(
                colors: [Color(hex: "319795"), Color(hex: "38B2AC")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        }
    }
    private var amountColor: Color {
        switch transaction.type {
        case .received, .minted:
            return OlasDesign.Colors.success
        case .sent, .zapped, .nutzapped, .melted:
            return OlasDesign.Colors.text
        case .swapped:
            return OlasDesign.Colors.warning
        }
    }
    private var statusIcon: String {
        switch transaction.status {
        case .completed:
            return "checkmark.circle.fill"
        case .failed:
            return "xmark.circle.fill"
        case .pending:
            return "clock.fill"
        }
    }
    private var statusColor: Color {
        switch transaction.status {
        case .completed:
            return OlasDesign.Colors.success
        case .failed:
            return OlasDesign.Colors.error
        case .pending:
            return OlasDesign.Colors.warning
        }
    }
    private var statusText: String {
        switch transaction.status {
        case .completed:
            return "Completed"
        case .failed:
            return "Failed"
        case .pending:
            return "Pending"
        }
    }
    private var typeText: String {
        switch transaction.type {
        case .sent:
            return "Sent"
        case .received:
            return "Received"
        case .zapped:
            return "Zapped"
        case .nutzapped:
            return "NutZapped"
        case .minted:
            return "Minted"
        case .melted:
            return "Melted"
        case .swapped:
            return "Swapped"
        }
    }
    // MARK: - Helper Methods
    private func formatSats(_ sats: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: sats)) ?? "\(sats)"
    }
    private func copyToClipboard(_ text: String) {
        #if os(iOS)
        UIPasteboard.general.string = text
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(text, forType: .string)
        #endif
        OlasDesign.Haptic.success()
        copiedToClipboard = true
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            copiedToClipboard = false
        }
    }
    private func calculateFiatValue(sats: Int64) -> String? {
        // TODO: Implement real BTC price fetching
        let btcPriceUSD = 45000.0 // Placeholder
        let btcValue = Double(sats) / 100_000_000
        let usdValue = btcValue * btcPriceUSD
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencyCode = "USD"
        formatter.maximumFractionDigits = 2
        return formatter.string(from: NSNumber(value: usdValue))
    }
}
// MARK: - Supporting Views
struct AnimatedCounterView: View {
    let value: Int64
    let fontSize: CGFloat
    let fontWeight: Font.Weight
    let color: Color
    let prefix: String
    let suffix: String
    @State private var displayValue: Int64 = 0
    var body: some View {
        HStack(spacing: 2) {
            Text(prefix)
                .font(.system(size: fontSize, weight: fontWeight))
                .foregroundColor(color)
            Text(formatSats(displayValue))
                .font(.system(size: fontSize, weight: fontWeight, design: .rounded))
                .foregroundColor(color)
            Text(suffix)
                .font(.system(size: fontSize * 0.7, weight: .medium))
                .foregroundColor(color.opacity(0.8))
        }
        .onAppear {
            withAnimation(.easeOut(duration: 0.8)) {
                displayValue = value
            }
        }
    }
    private func formatSats(_ sats: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: sats)) ?? "\(sats)"
    }
}
struct DetailRow: View {
    let icon: String
    let label: String
    let value: String
    var showCopyButton: Bool = false
    var onCopy: (() -> Void)? = nil
    @State private var showCopied = false
    var body: some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            Image(systemName: icon)
                .font(.system(size: 16))
                .foregroundStyle(OlasDesign.Colors.textSecondary)
                .frame(width: 24)
            VStack(alignment: .leading, spacing: 2) {
                Text(label)
                    .font(OlasDesign.Typography.caption)
                    .foregroundStyle(OlasDesign.Colors.textSecondary)
                Text(value)
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(OlasDesign.Colors.text)
            }
            Spacer()
            if showCopyButton, let onCopy = onCopy {
                Button {
                    onCopy()
                    withAnimation {
                        showCopied = true
                    }
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                        withAnimation {
                            showCopied = false
                        }
                    }
                } label: {
                    Image(systemName: showCopied ? "checkmark" : "doc.on.doc")
                        .font(.system(size: 14))
                        .foregroundStyle(showCopied ? OlasDesign.Colors.success : OlasDesign.Colors.primary)
                }
            }
        }
        .padding(.vertical, OlasDesign.Spacing.xs)
    }
}
// MARK: - QR Code View
struct TransactionQRCodeView: View {
    let content: String
    @Environment(\.dismiss) private var dismiss
    #if os(iOS)
    @State private var qrImage: UIImage?
    #else
    @State private var qrImage: NSImage?
    #endif
    @State private var showCopied = false
    var body: some View {
        NavigationView {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: OlasDesign.Spacing.xl) {
                    if let qrImage = qrImage {
                        #if os(iOS)
                        Image(uiImage: qrImage)
                            .interpolation(.none)
                            .resizable()
                            .scaledToFit()
                            .frame(width: 280, height: 280)
                            .padding(OlasDesign.Spacing.lg)
                            .background(Color.white)
                            .cornerRadius(OlasDesign.CornerRadius.lg)
                            .shadow(color: Color.black.opacity(0.1), radius: 20, x: 0, y: 10)
                            .scaleEffect(showCopied ? 0.95 : 1)
                            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: showCopied)
                        #else
                        Image(nsImage: qrImage)
                            .resizable()
                            .scaledToFit()
                            .frame(width: 280, height: 280)
                            .padding(OlasDesign.Spacing.lg)
                            .background(Color.white)
                            .cornerRadius(OlasDesign.CornerRadius.lg)
                            .shadow(color: Color.black.opacity(0.1), radius: 20, x: 0, y: 10)
                            .scaleEffect(showCopied ? 0.95 : 1)
                            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: showCopied)
                        #endif
                    } else {
                        ProgressView()
                            .frame(width: 280, height: 280)
                    }
                    Text("Scan to view details")
                        .font(OlasDesign.Typography.body)
                        .foregroundStyle(OlasDesign.Colors.textSecondary)
                    // Copy button
                    Button {
                        copyContent()
                    } label: {
                        HStack {
                            Image(systemName: showCopied ? "checkmark" : "doc.on.doc")
                            Text(showCopied ? "Copied!" : "Copy")
                        }
                        .font(OlasDesign.Typography.bodyMedium)
                        .foregroundStyle(showCopied ? OlasDesign.Colors.success : OlasDesign.Colors.primary)
                        .padding(.horizontal, OlasDesign.Spacing.xl)
                        .padding(.vertical, OlasDesign.Spacing.md)
                        .background(
                            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full)
                                .stroke(showCopied ? OlasDesign.Colors.success : OlasDesign.Colors.primary, lineWidth: 2)
                        )
                    }
                    .disabled(showCopied)
                }
                .padding()
            }
            .navigationTitle("QR Code")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            .onAppear {
                generateQRCode()
            }
        }
    }
    private func generateQRCode() {
        let context = CIContext()
        let filter = CIFilter.qrCodeGenerator()
        filter.message = Data(content.utf8)
        if let outputImage = filter.outputImage {
            let transform = CGAffineTransform(scaleX: 10, y: 10)
            let scaledImage = outputImage.transformed(by: transform)
            if let cgImage = context.createCGImage(scaledImage, from: scaledImage.extent) {
                #if os(iOS)
                qrImage = UIImage(cgImage: cgImage)
                #else
                qrImage = NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
                #endif
            }
        }
    }
    private func copyContent() {
        #if os(iOS)
        UIPasteboard.general.string = content
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(content, forType: .string)
        #endif
        OlasDesign.Haptic.success()
        withAnimation {
            showCopied = true
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                showCopied = false
            }
        }
    }
}
</file>

<file path="Olas/Views/Wallet/WalletView.swift">
import SwiftUI
import NDKSwift
// This file is kept for backward compatibility but redirects to OlasWalletView
struct WalletView: View {
    @ObservedObject var walletManager: OlasWalletManager
    let nostrManager: NostrManager
    var body: some View {
        OlasWalletView(walletManager: walletManager, nostrManager: nostrManager)
    }
}
</file>

<file path="Olas/Views/AuthenticationView.swift">
import SwiftUI
import NDKSwift
struct AuthenticationView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var showOnboarding = false
    @State private var privateKey = ""
    @State private var showLoginSheet = false
    @State private var keyboardHeight: CGFloat = 0
    @State private var animateGradient = false
    @State private var hasSeenOnboarding = UserDefaults.standard.bool(forKey: "hasSeenOnboarding")
    var body: some View {
        ZStack {
            // Animated gradient background
            TimeBasedGradient()
                .ignoresSafeArea()
            if !hasSeenOnboarding || showOnboarding {
                OnboardingView()
                    .onDisappear {
                        UserDefaults.standard.set(true, forKey: "hasSeenOnboarding")
                        hasSeenOnboarding = true
                    }
            } else {
                mainAuthView
            }
        }
    }
    var mainAuthView: some View {
        VStack {
            Spacer()
            // Animated Logo
            VStack(spacing: OlasDesign.Spacing.lg) {
                ZStack {
                    // Glow effect
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: OlasDesign.Colors.primaryGradient,
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 120, height: 120)
                        .blur(radius: 40)
                        .scaleEffect(animateGradient ? 1.2 : 0.8)
                        .animation(
                            .easeInOut(duration: 3).repeatForever(autoreverses: true),
                            value: animateGradient
                        )
                    Text("Olas")
                        .font(.system(size: 72, weight: .bold, design: .rounded))
                        .foregroundStyle(.white)
                }
                Text("Welcome back")
                    .font(.system(size: 24, weight: .medium, design: .rounded))
                    .foregroundStyle(.white.opacity(0.9))
            }
            Spacer()
            // Action buttons
            VStack(spacing: OlasDesign.Spacing.md) {
                Button {
                    showOnboarding = true
                    #if os(iOS)
                    OlasDesign.Haptic.impact(.medium)
                    #else
                    OlasDesign.Haptic.impact(0)
                    #endif
                } label: {
                    HStack {
                        Image(systemName: "sparkles")
                        Text("I'm New Here")
                    }
                    .font(OlasDesign.Typography.bodyBold)
                    .foregroundStyle(.white)
                    .frame(maxWidth: .infinity)
                    .frame(height: 56)
                    .background(
                        LinearGradient(
                            colors: OlasDesign.Colors.primaryGradient,
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .clipShape(RoundedRectangle(cornerRadius: 16))
                }
                Button {
                    showLoginSheet = true
                    OlasDesign.Haptic.selection()
                } label: {
                    Text("I Have an Account")
                    .font(OlasDesign.Typography.bodyBold)
                    .foregroundStyle(.white)
                    .frame(maxWidth: .infinity)
                    .frame(height: 56)
                    .background(
                        RoundedRectangle(cornerRadius: 16)
                            .fill(.white.opacity(0.1))
                            .overlay(
                                RoundedRectangle(cornerRadius: 16)
                                    .stroke(.white.opacity(0.2), lineWidth: 1)
                            )
                    )
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.xl)
            .padding(.bottom, OlasDesign.Spacing.xxxl)
        }
        .sheet(isPresented: $showLoginSheet) {
            LoginSheet()
        }
        .onAppear {
            animateGradient = true
        }
    }
}
// MARK: - Login Sheet
struct LoginSheet: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var privateKey = ""
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var isLoading = false
    @FocusState private var isKeyFieldFocused: Bool
    var body: some View {
        ZStack {
            // Gradient background
            LinearGradient(
                colors: [Color(hex: "1a1a2e"), Color(hex: "0f0f1e")],
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()
            VStack(spacing: 0) {
                // Handle bar
                Capsule()
                    .fill(.white.opacity(0.3))
                    .frame(width: 40, height: 4)
                    .padding(.top, OlasDesign.Spacing.sm)
                    .padding(.bottom, OlasDesign.Spacing.xl)
                ScrollView {
                    VStack(spacing: OlasDesign.Spacing.xl) {
                        // Header
                        VStack(spacing: OlasDesign.Spacing.md) {
                            Image(systemName: "key.fill")
                                .font(.system(size: 48))
                                .foregroundStyle(
                                    LinearGradient(
                                        colors: OlasDesign.Colors.primaryGradient,
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                            Text("Welcome Back")
                                .font(.system(size: 28, weight: .semibold, design: .rounded))
                                .foregroundStyle(.white)
                            Text("Enter your private key (nsec or hex format)")
                                .font(OlasDesign.Typography.body)
                                .foregroundStyle(.white.opacity(0.7))
                        }
                        .padding(.top, OlasDesign.Spacing.lg)
                        // Key input
                        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                            Text("Private Key")
                                .font(OlasDesign.Typography.caption)
                                .foregroundStyle(.white.opacity(0.6))
                            SecureField("nsec1... or hex format", text: $privateKey)
                                .font(OlasDesign.Typography.body)
                                .foregroundStyle(.white)
                                .padding()
                                .background(
                                    RoundedRectangle(cornerRadius: 12)
                                        .fill(.white.opacity(0.1))
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 12)
                                                .stroke(.white.opacity(0.2), lineWidth: 1)
                                        )
                                )
                                .focused($isKeyFieldFocused)
                                #if os(iOS)
                                .autocapitalization(.none)
                                #endif
                                .autocorrectionDisabled()
                                .accessibilityIdentifier("privateKeyField")
                        }
                        .padding(.horizontal, OlasDesign.Spacing.xl)
                        // Login button
                        Button(action: login) {
                            if isLoading {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                            } else {
                                Text("Login")
                                    .font(OlasDesign.Typography.bodyBold)
                            }
                        }
                        .foregroundStyle(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 56)
                        .background(
                            LinearGradient(
                                colors: privateKey.isEmpty ? [.gray] : OlasDesign.Colors.primaryGradient,
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .clipShape(RoundedRectangle(cornerRadius: 16))
                        .disabled(privateKey.isEmpty || isLoading)
                        .padding(.horizontal, OlasDesign.Spacing.xl)
                        // Additional options
                        VStack(spacing: OlasDesign.Spacing.md) {
                            Button {
                                // TODO: Implement NIP-07 login
                                OlasDesign.Haptic.selection()
                            } label: {
                                HStack {
                                    Image(systemName: "globe")
                                    Text("Login with Browser Extension")
                                }
                                .font(OlasDesign.Typography.body)
                                .foregroundStyle(.white.opacity(0.8))
                            }
                            Button {
                                // TODO: Implement key import
                                OlasDesign.Haptic.selection()
                            } label: {
                                HStack {
                                    Image(systemName: "qrcode")
                                    Text("Scan QR Code")
                                }
                                .font(OlasDesign.Typography.body)
                                .foregroundStyle(.white.opacity(0.8))
                            }
                        }
                        .padding(.top, OlasDesign.Spacing.lg)
                    }
                    .padding(.bottom, OlasDesign.Spacing.xxxl)
                }
            }
        }
        .alert("Login Failed", isPresented: $showError) {
            Button("OK") {
                errorMessage = ""
            }
        } message: {
            Text(errorMessage)
        }
        .onAppear {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                isKeyFieldFocused = true
            }
        }
    }
    private func login() {
        isLoading = true
        OlasDesign.Haptic.selection()
        Task {
            do {
                try await nostrManager.login(with: privateKey)
                OlasDesign.Haptic.success()
                dismiss()
            } catch {
                isLoading = false
                errorMessage = error.localizedDescription
                showError = true
                OlasDesign.Haptic.error()
            }
        }
    }
}
</file>

<file path="Olas/Views/ContentView.swift">
import SwiftUI
import NDKSwift
struct ContentView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @EnvironmentObject var blossomServerManager: BlossomServerManager
    var body: some View {
        Group {
            if let ndk = nostrManager.ndk {
                if nostrManager.isAuthenticated && appState.isAuthenticated {
                    // Authenticated content
                    MainTabView()
                } else {
                    // Authentication screen
                    AuthenticationView()
                }
            } else {
                // Show loading or splash screen while NDK initializes
                VStack(spacing: 20) {
                    Image(systemName: "camera.fill")
                        .font(.system(size: 60))
                        .foregroundColor(.white)
                    ProgressView()
                        .scaleEffect(1.2)
                        .tint(.white)
                    Text("Olas")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.black)
            }
        }
        .onAppear {
            // Link AppState to NostrManager
            appState.setNostrManager(nostrManager)
        }
    }
}
</file>

<file path="Olas/Views/CreateAccountView.swift">
import SwiftUI
import NDKSwift
struct CreateAccountView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var displayName = ""
    @State private var mnemonic: [String] = []
    @State private var privateKey = ""
    @State private var showConfirmation = false
    @State private var isCreatingAccount = false
    var body: some View {
        NavigationStack {
            VStack(spacing: 32) {
                Text("Create New Account")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                if mnemonic.isEmpty {
                    VStack(spacing: 20) {
                        TextField("Display Name", text: $displayName)
                            .textFieldStyle(.roundedBorder)
                            #if os(iOS)
                            .autocapitalization(.words)
                            #endif
                        Button("Generate Keys") {
                            generateKeys()
                        }
                        .font(.headline)
                        .foregroundColor(.white)
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(
                            LinearGradient(
                                colors: [Color(hex: "667eea"), Color(hex: "764ba2")],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .cornerRadius(12)
                        .disabled(displayName.isEmpty)
                    }
                    .padding(.horizontal)
                } else {
                    VStack(spacing: 24) {
                        Text("Your Recovery Phrase")
                            .font(.title2)
                            .fontWeight(.semibold)
                        LazyVGrid(columns: [GridItem(.adaptive(minimum: 100))], spacing: 12) {
                            ForEach(Array(mnemonic.enumerated()), id: \.offset) { index, word in
                                HStack {
                                    Text("\(index + 1).")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                    Text(word)
                                        .font(.system(.body, design: .monospaced))
                                }
                                .padding(.horizontal, 12)
                                .padding(.vertical, 8)
                                .background(Color.gray.opacity(0.1))
                                .cornerRadius(8)
                            }
                        }
                        Text(" Write down these words in order. This is the only way to recover your account.")
                            .font(.caption)
                            .foregroundColor(.orange)
                            .multilineTextAlignment(.center)
                        Button("I've Saved My Recovery Phrase") {
                            showConfirmation = true
                        }
                        .font(.headline)
                        .foregroundColor(.white)
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.green)
                        .cornerRadius(12)
                    }
                    .padding(.horizontal)
                }
            }
            .padding()
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
            .alert("Confirm Backup", isPresented: $showConfirmation) {
                Button("Yes, I've saved it") {
                    completeAccountCreation()
                }
                Button("No, let me save it", role: .cancel) {}
            } message: {
                Text("Have you securely saved your recovery phrase? You won't be able to see it again.")
            }
        }
    }
    private func generateKeys() {
        do {
            // Generate a new private key signer
            let signer = try NDKPrivateKeySigner.generate()
            privateKey = signer.privateKeyValue
            // In a real app, you would generate a proper BIP39 mnemonic
            // This is just a placeholder for demo purposes
            mnemonic = ["example", "words", "would", "be", "generated", "here", 
                       "using", "proper", "bip39", "implementation", "for", "security"]
        } catch {
            print("Key generation failed: \(error)")
        }
    }
    private func completeAccountCreation() {
        Task {
            do {
                isCreatingAccount = true
                _ = try await nostrManager.createNewAccount(displayName: displayName)
                dismiss()
            } catch {
                print("Account creation failed: \(error)")
                isCreatingAccount = false
                // TODO: Show error alert
            }
        }
    }
}
</file>

<file path="Olas/Views/CreatePostView.swift">
import SwiftUI
import PhotosUI
import NDKSwift
import CryptoKit
#if canImport(UIKit)
import UIKit
#elseif canImport(AppKit)
import AppKit
#endif
struct CreatePostView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @EnvironmentObject var blossomServerManager: BlossomServerManager
    @Environment(\.dismiss) var dismiss
    // Photo selection
    @State private var selectedItems: [PhotosPickerItem] = []
    #if canImport(UIKit)
    @State private var selectedImages: [UIImage] = []
    #elseif canImport(AppKit)
    @State private var selectedImages: [NSImage] = []
    #endif
    @State private var selectedImageData: [Data] = []
    // Caption
    @State private var caption = ""
    // UI States
    @State private var showCamera = false
    @State private var showImageEditor = false
    @State private var isPosting = false
    @State private var uploadProgress: Double = 0.0
    @State private var errorMessage: String?
    @State private var showError = false
    // Image editing
    @State private var editingImageIndex: Int = 0
    @State private var appliedFilters: [Int: String] = [:] // Image index to filter name
    var body: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: 0) {
                    if selectedImages.isEmpty {
                        emptyStateView
                    } else {
                        selectedImagesView
                    }
                }
            }
            .navigationTitle("Create Post")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            #if os(iOS)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    if !selectedImages.isEmpty {
                        Button("Clear") {
                            clearSelection()
                        }
                        .foregroundColor(OlasDesign.Colors.warning)
                    }
                }
            }
            #else
            .toolbar {
                ToolbarItem(placement: .navigation) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                ToolbarItem(placement: .automatic) {
                    if !selectedImages.isEmpty {
                        Button("Clear") {
                            clearSelection()
                        }
                        .foregroundColor(OlasDesign.Colors.warning)
                    }
                }
            }
            #endif
            .onChange(of: selectedItems) { _, newItems in
                Task {
                    await loadImages(from: newItems)
                }
            }
            .sheet(isPresented: $showCamera) {
                #if canImport(UIKit)
                OlasCameraView { image in
                    selectedImages.append(image)
                    if let data = image.jpegData(compressionQuality: 0.9) {
                        selectedImageData.append(data)
                    }
                }
                #else
                Text("Camera not available on this platform")
                #endif
            }
            .sheet(isPresented: $showImageEditor) {
                if selectedImages.indices.contains(editingImageIndex) {
                    #if canImport(UIKit)
                    OlasImageEditor(
                        originalImage: selectedImages[editingImageIndex],
                        currentFilter: appliedFilters[editingImageIndex] ?? "No Filter"
                    ) { editedImage, filterName in
                        selectedImages[editingImageIndex] = editedImage
                        if let data = editedImage.jpegData(compressionQuality: 0.9) {
                            selectedImageData[editingImageIndex] = data
                        }
                        appliedFilters[editingImageIndex] = filterName
                    }
                    #else
                    Text("Image editor not available on this platform")
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        .padding()
                    #endif
                }
            }
            .alert("Error", isPresented: $showError) {
                Button("OK") { }
            } message: {
                Text(errorMessage ?? "An error occurred")
            }
            .overlay {
                if isPosting {
                    postingOverlay
                }
            }
        }
    }
    // MARK: - Views
    @ViewBuilder
    private var emptyStateView: some View {
        VStack(spacing: OlasDesign.Spacing.xl) {
            Spacer()
            // Photo picker
            PhotosPicker(
                selection: $selectedItems,
                maxSelectionCount: 4,
                matching: .images
            ) {
                VStack(spacing: OlasDesign.Spacing.md) {
                    Image(systemName: "photo.stack")
                        .font(.system(size: 60))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [OlasDesign.Colors.primary, OlasDesign.Colors.secondary],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                    Text("Select Photos")
                        .font(OlasDesign.Typography.title)
                        .foregroundColor(OlasDesign.Colors.text)
                    Text("Up to 4 photos")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textTertiary)
                }
                .frame(maxWidth: .infinity, minHeight: 300)
                .background(OlasDesign.Colors.surface)
                .cornerRadius(16)
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(OlasDesign.Colors.border, lineWidth: 1)
                )
            }
            // Camera button
            OlasButton(
                title: "Take Photo",
                action: {
                    showCamera = true
                    #if os(iOS)
                    OlasDesign.Haptic.impact(.light)
                    #else
                    OlasDesign.Haptic.impact(0)
                    #endif
                },
                style: .secondary
            )
            Spacer()
        }
        .padding(OlasDesign.Spacing.lg)
    }
    @ViewBuilder
    private var selectedImagesView: some View {
        ScrollView {
            VStack(spacing: OlasDesign.Spacing.lg) {
                // Selected images
                imageCarousel
                // Caption input with built-in suggestions
                captionInput
                // Post button
                OlasButton(
                    title: isPosting ? "Posting..." : "Post",
                    action: createPost,
                    style: .primary,
                    isLoading: isPosting
                )
                .disabled(isPosting)
                .padding(.top, OlasDesign.Spacing.md)
            }
            .padding(OlasDesign.Spacing.lg)
        }
    }
    @ViewBuilder
    private var imageCarousel: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: OlasDesign.Spacing.md) {
                ForEach(Array(selectedImages.enumerated()), id: \.offset) { index, image in
                    ZStack(alignment: .topTrailing) {
                        #if canImport(UIKit)
                        Image(uiImage: image)
                            .resizable()
                            .scaledToFill()
                            .frame(width: 200, height: 200)
                            .clipped()
                            .cornerRadius(12)
                            .overlay(
                                RoundedRectangle(cornerRadius: 12)
                                    .stroke(OlasDesign.Colors.border, lineWidth: 1)
                            )
                            .onTapGesture {
                                editingImageIndex = index
                                showImageEditor = true
                                OlasDesign.Haptic.selection()
                            }
                        #elseif canImport(AppKit)
                        Image(nsImage: image)
                            .resizable()
                            .scaledToFill()
                            .frame(width: 200, height: 200)
                            .clipped()
                            .cornerRadius(12)
                            .overlay(
                                RoundedRectangle(cornerRadius: 12)
                                    .stroke(OlasDesign.Colors.border, lineWidth: 1)
                            )
                            .onTapGesture {
                                editingImageIndex = index
                                showImageEditor = true
                                OlasDesign.Haptic.selection()
                            }
                        #endif
                        // Filter indicator
                        if let filterName = appliedFilters[index], filterName != "No Filter" {
                            Text(filterName)
                                .font(OlasDesign.Typography.caption)
                                .padding(.horizontal, OlasDesign.Spacing.xs)
                                .padding(.vertical, 4)
                                .background(.ultraThinMaterial)
                                .cornerRadius(6)
                                .padding(OlasDesign.Spacing.xs)
                        }
                        // Remove button
                        Button(action: {
                            removeImage(at: index)
                            #if os(iOS)
                        OlasDesign.Haptic.impact(.light)
                        #else
                        OlasDesign.Haptic.impact(0)
                        #endif
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .font(.title2)
                                .foregroundStyle(.white, Color.black.opacity(0.6))
                        }
                        .padding(OlasDesign.Spacing.xs)
                    }
                }
                // Add more photos button (if under limit)
                if selectedImages.count < 4 {
                    PhotosPicker(
                        selection: $selectedItems,
                        maxSelectionCount: 4 - selectedImages.count,
                        matching: .images
                    ) {
                        VStack {
                            Image(systemName: "plus")
                                .font(.title)
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                        }
                        .frame(width: 200, height: 200)
                        .background(OlasDesign.Colors.surface)
                        .cornerRadius(12)
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(OlasDesign.Colors.border, style: StrokeStyle(lineWidth: 2, dash: [5]))
                        )
                    }
                }
            }
        }
        .frame(height: 220)
    }
    @ViewBuilder
    private var captionInput: some View {
        OlasCaptionComposer(caption: $caption)
            .environmentObject(appState)
    }
    @ViewBuilder
    private var postingOverlay: some View {
        ZStack {
            OlasDesign.Colors.background.opacity(0.9)
                .ignoresSafeArea()
            VStack(spacing: OlasDesign.Spacing.lg) {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle(tint: OlasDesign.Colors.primary))
                    .scaleEffect(1.5)
                Text("Uploading Images...")
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                ProgressView(value: uploadProgress)
                    .progressViewStyle(LinearProgressViewStyle(tint: OlasDesign.Colors.primary))
                    .frame(width: 200)
            }
            .padding(OlasDesign.Spacing.xl)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(16)
        }
    }
    // MARK: - Methods
    private func loadImages(from items: [PhotosPickerItem]) async {
        selectedImages = []
        selectedImageData = []
        for item in items {
            if let data = try? await item.loadTransferable(type: Data.self) {
                #if canImport(UIKit)
                if let image = UIImage(data: data) {
                    await MainActor.run {
                        selectedImages.append(image)
                        selectedImageData.append(data)
                    }
                }
                #elseif canImport(AppKit)
                if let image = NSImage(data: data) {
                    await MainActor.run {
                        selectedImages.append(image)
                        selectedImageData.append(data)
                    }
                }
                #endif
            }
        }
    }
    private func removeImage(at index: Int) {
        selectedImages.remove(at: index)
        selectedImageData.remove(at: index)
        appliedFilters.removeValue(forKey: index)
        // Reindex filters
        let oldFilters = appliedFilters
        appliedFilters = [:]
        for (oldIndex, filter) in oldFilters {
            if oldIndex > index {
                appliedFilters[oldIndex - 1] = filter
            } else if oldIndex < index {
                appliedFilters[oldIndex] = filter
            }
        }
    }
    private func clearSelection() {
        selectedItems = []
        selectedImages = []
        selectedImageData = []
        appliedFilters = [:]
        caption = ""
        #if os(iOS)
        OlasDesign.Haptic.impact(.light)
        #else
        OlasDesign.Haptic.impact(0)
        #endif
    }
    private func createPost() {
        Task {
            await performCreatePost()
        }
    }
    @MainActor
    private func performCreatePost() async {
        guard let ndk = nostrManager.ndk else { return }
        isPosting = true
        uploadProgress = 0.0
        do {
            // Get signer
            let authManager = NDKAuthManager.shared
            guard let signer = authManager.activeSigner else {
                throw OlasError.invalidKey
            }
            // 1. Upload images to Blossom
            var imetaTags: [[String]] = []
            let progressPerImage = 0.8 / Double(selectedImageData.count)
            // Default Blossom servers
            let blossomServers = [
                "https://blossom.primal.net",
                "https://blossom.nostr.wine", 
                "https://blossom.damus.io"
            ]
            // Create Blossom client
            let blossomClient = BlossomClient()
            for (index, imageData) in selectedImageData.enumerated() {
                // Calculate hash
                let sha256 = SHA256.hash(data: imageData).compactMap { String(format: "%02x", $0) }.joined()
                let size = Int64(imageData.count)
                let mimeType = "image/jpeg"
                // Try uploading to multiple servers
                var uploadSuccess = false
                var uploadedUrl: String?
                var uploadError: Error?
                for server in blossomServers {
                    do {
                        // Create auth event
                        let auth = try await BlossomAuth.createUploadAuth(
                            sha256: sha256,
                            size: size,
                            mimeType: mimeType,
                            signer: signer,
                            ndk: nostrManager.ndk!,
                            expiration: Date().addingTimeInterval(60) // 1 minute expiration
                        )
                        // Upload
                        let blob = try await blossomClient.upload(
                            data: imageData,
                            mimeType: mimeType,
                            to: server,
                            auth: auth
                        )
                        uploadedUrl = blob.url
                        uploadSuccess = true
                        // Create imeta tag
                        var imetaTag = ["imeta"]
                        imetaTag.append("url \(blob.url)")
                        imetaTag.append("m \(mimeType)")
                        imetaTag.append("alt Image \(index + 1)")
                        imetaTag.append("x \(sha256)")
                        imetaTag.append("size \(size)")
                        // Add dimensions if available
                        if let image = selectedImages[safe: index] {
                            if let dimensions = getImageDimensions(image) {
                                imetaTag.append("dim \(dimensions.width)x\(dimensions.height)")
                            }
                        }
                        imetaTags.append(imetaTag)
                        break // Success, no need to try other servers
                    } catch {
                        uploadError = error
                        print("Blossom upload to \(server) failed: \(error)")
                        // Continue to next server
                    }
                }
                if !uploadSuccess {
                    // Fall back to placeholder if all servers fail
                    uploadedUrl = "https://image.nostr.build/placeholder\(index).jpg"
                    print("All Blossom uploads failed: \(uploadError?.localizedDescription ?? "Unknown error")")
                    // Create basic imeta tag for placeholder
                    let imetaTag = [
                        "imeta",
                        "url \(uploadedUrl!)",
                        "m image/jpeg",
                        "alt Image \(index + 1)"
                    ]
                    imetaTags.append(imetaTag)
                }
                uploadProgress += progressPerImage
            }
            // 2. Create and publish event
            // Use kind 20 for picture posts as per Olas spec
            let event = try await NDKEventBuilder(ndk: ndk)
                .content(caption) // Only caption in content for kind 20
                .kind(20) // kind 20 - picture post
                .tags(imetaTags) // Image metadata in tags
                .build(signer: signer)
            uploadProgress = 0.9
            _ = try await ndk.publish(event)
            uploadProgress = 1.0
            // Success!
            OlasDesign.Haptic.success()
            // Wait a moment to show completion
            try await Task.sleep(nanoseconds: 500_000_000)
            // Dismiss the view
            dismiss()
        } catch {
            errorMessage = error.localizedDescription
            showError = true
            OlasDesign.Haptic.error()
        }
        isPosting = false
    }
    #if canImport(UIKit)
    private func getImageDimensions(_ image: UIImage) -> (width: Int, height: Int)? {
        let width = Int(image.size.width * image.scale)
        let height = Int(image.size.height * image.scale)
        return (width: width, height: height)
    }
    #elseif canImport(AppKit)
    private func getImageDimensions(_ image: NSImage) -> (width: Int, height: Int)? {
        guard let representations = image.representations.first else { return nil }
        let width = representations.pixelsWide
        let height = representations.pixelsHigh
        return (width: width, height: height)
    }
    #endif
}
// MARK: - Preview
struct CreatePostView_Previews: PreviewProvider {
    static var previews: some View {
        CreatePostView()
            .environmentObject(AppState())
    }
}
</file>

<file path="Olas/Views/FeedView.swift">
import SwiftUI
import NDKSwift
struct FeedView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @StateObject private var viewModel = FeedViewModel()
    @State private var hasAppeared = false
    @State private var showLiveIndicator = false
    @State private var newPostsCount = 0
    @State private var pulseAnimation = false
    @Namespace private var animation
    var body: some View {
        NavigationStack {
            ZStack {
                // Subtle animated gradient background
                TimeBasedGradient()
                    .ignoresSafeArea()
                    .opacity(0.1)
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                if viewModel.items.isEmpty && viewModel.isLoading {
                    // Loading state
                    loadingView
                } else if viewModel.items.isEmpty {
                    // Empty state
                    emptyStateView
                } else {
                    // Feed content
                    ScrollView {
                        LazyVStack(spacing: 0, pinnedViews: [.sectionHeaders]) {
                            // Stories section
                            Section {
                                // Empty section content
                            } header: {
                                VStack(spacing: 0) {
                                    StoriesView()
                                        .background(OlasDesign.Colors.background)
                                    // Live updates indicator
                                    if showLiveIndicator {
                                        LiveUpdatesIndicator(newPostsCount: $newPostsCount)
                                            .transition(.asymmetric(
                                                insertion: .push(from: .top).combined(with: .opacity),
                                                removal: .push(from: .top).combined(with: .opacity)
                                            ))
                                            .onTapGesture {
                                                loadPendingItems()
                                            }
                                    }
                                }
                            }
                            // Feed items
                            ForEach(Array(viewModel.items.enumerated()), id: \.element.id) { index, item in
                                FeedItemView(item: item)
                                    .id(item.id)
                                    .transition(.asymmetric(
                                        insertion: .move(edge: .bottom).combined(with: .opacity),
                                        removal: .move(edge: .top).combined(with: .opacity)
                                    ))
                                    .scaleEffect(hasAppeared ? 1 : 0.95)
                                    .opacity(hasAppeared ? 1 : 0)
                                    .animation(
                                        .spring(response: 0.5, dampingFraction: 0.8)
                                        .delay(Double(min(index, 10)) * 0.05),
                                        value: hasAppeared
                                    )
                                if index < viewModel.items.count - 1 {
                                    Rectangle()
                                        .fill(OlasDesign.Colors.divider)
                                        .frame(height: 1)
                                }
                            }
                        }
                        .padding(.top, 0)
                    }
                }
            }
            .navigationTitle("Olas")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.large)
            #endif
            .toolbar {
                #if os(iOS)
                ToolbarItem(placement: .navigationBarLeading) {
                    // Live indicator in toolbar
                    if viewModel.isLive {
                        HStack(spacing: 6) {
                            Circle()
                                .fill(Color.green)
                                .frame(width: 8, height: 8)
                                .overlay(
                                    Circle()
                                        .stroke(Color.green.opacity(0.3), lineWidth: 8)
                                        .scaleEffect(pulseAnimation ? 2 : 1)
                                        .opacity(pulseAnimation ? 0 : 1)
                                        .animation(.easeOut(duration: 1.5).repeatForever(autoreverses: false), value: pulseAnimation)
                                )
                            Text("LIVE")
                                .font(.system(size: 12, weight: .bold, design: .rounded))
                                .foregroundColor(.green)
                        }
                        .onAppear { pulseAnimation = true }
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    NavigationLink(destination: CreatePostView()) {
                        Image(systemName: "camera.fill")
                            .onTapGesture {
                                OlasDesign.Haptic.selection()
                            }
                            .foregroundStyle(
                                LinearGradient(
                                    colors: OlasDesign.Colors.primaryGradient,
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                    }
                }
                #endif
            }
            .refreshable {
                await handleRefresh()
            }
            .onAppear {
                if let ndk = nostrManager.ndk {
                    viewModel.startFeed(with: ndk)
                }
                // Trigger staggered animations
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    withAnimation {
                        hasAppeared = true
                    }
                }
            }
            .onChange(of: viewModel.pendingItemsCount) { _, newValue in
                if newValue > 0 {
                    withAnimation(.spring()) {
                        showLiveIndicator = true
                        newPostsCount = newValue
                    }
                } else {
                    withAnimation(.spring()) {
                        showLiveIndicator = false
                    }
                }
            }
        }
    }
    private var loadingView: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            ForEach(0..<5) { index in
                FeedItemSkeletonView()
                    .opacity(0.7)
                    .scaleEffect(hasAppeared ? 1 : 0.95)
                    .animation(
                        .easeInOut(duration: 0.5)
                        .delay(Double(index) * 0.1),
                        value: hasAppeared
                    )
            }
        }
        .padding(.horizontal, OlasDesign.Spacing.md)
    }
    private var emptyStateView: some View {
        EmptyFeedView(hasAppeared: hasAppeared)
    }
    private func handleRefresh() async {
        #if os(iOS)
        OlasDesign.Haptic.impact(.medium)
        #endif
        hasAppeared = false
        await viewModel.refresh()
        // Re-trigger animations
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            withAnimation {
                hasAppeared = true
            }
        }
    }
    private func loadPendingItems() {
        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
            viewModel.loadPendingItems()
            showLiveIndicator = false
            newPostsCount = 0
        }
        // Haptic feedback
        #if os(iOS)
        OlasDesign.Haptic.impact(.medium)
        #endif
    }
}
struct FeedItemView: View {
    let item: FeedItem
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var isLiked = false
    @State private var scale: CGFloat = 1.0
    @State private var isZoomed = false
    @State private var showProfile = false
    @State private var showingReplies = false
    @State private var showingLikeAnimation = false
    @State private var showingZap = false
    @State private var doubleTapLocation: CGPoint = .zero
    @State private var navigateToProfile = false
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header
            HStack(spacing: OlasDesign.Spacing.md) {
                Button(action: { navigateToProfile = true }) {
                    HStack(spacing: OlasDesign.Spacing.md) {
                        OlasAvatar(
                            url: item.profile?.picture,
                            size: 40,
                            pubkey: item.event.pubkey
                        )
                        VStack(alignment: .leading, spacing: 2) {
                            HStack(spacing: 4) {
                                Text(item.profile?.displayName ?? item.profile?.name ?? "Loading...")
                                    .font(OlasDesign.Typography.bodyMedium)
                                    .foregroundColor(OlasDesign.Colors.text)
                                    .olasTextShadow()
                                if let clientInfo = item.event.clientTag {
                                    Text("via \(clientInfo.name)")
                                        .font(OlasDesign.Typography.caption)
                                        .foregroundColor(OlasDesign.Colors.textTertiary)
                                        .olasTextShadow()
                                }
                            }
                            Text("@\(item.profile?.name ?? String(item.event.pubkey.prefix(8)))")
                                .font(OlasDesign.Typography.caption)
                                .foregroundColor(OlasDesign.Colors.textSecondary)
                        }
                    }
                }
                .buttonStyle(PlainButtonStyle())
                Spacer()
                Button(action: { OlasDesign.Haptic.selection() }) {
                    Image(systemName: "ellipsis")
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        .font(.system(size: 18))
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.md)
            // Image display with multi-image support
            if !item.imageURLs.isEmpty {
                OlasMultiImageView(imageURLs: item.imageURLs, blurhashes: item.blurhashes)
                    .onTapGesture(count: 2) { location in
                        // Double tap to like
                        doubleTapLocation = location
                        showingLikeAnimation = true
                        if !isLiked {
                            toggleLike()
                        }
                    }
                    .onTapGesture {
                        OlasDesign.Haptic.selection()
                        // Single tap - show full screen (handled in OlasMultiImageView)
                    }
                    .gesture(
                        DragGesture(minimumDistance: 50)
                            .onEnded { value in
                                if value.translation.height < -50 {
                                    // Swipe up - View user profile
                                    OlasDesign.Haptic.selection()
                                    showProfile = true
                                }
                                // TODO: Add other swipe gestures
                                // Left: Quick share sheet
                                // Right: Save to collection
                                // Down: Dismiss if in preview
                            }
                    )
            } else {
                // No image found
                Rectangle()
                    .fill(OlasDesign.Colors.surface)
                    .aspectRatio(4/5, contentMode: .fit)
                    .overlay(
                        VStack(spacing: OlasDesign.Spacing.sm) {
                            Image(systemName: "photo")
                                .font(.system(size: 60))
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                            Text("No Image")
                                .font(OlasDesign.Typography.caption)
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                        }
                    )
            }
            // Actions
            HStack(spacing: OlasDesign.Spacing.lg) {
                // Like button with count
                Button(action: { toggleLike() }) {
                    HStack(spacing: 4) {
                        Image(systemName: isLiked ? "heart.fill" : "heart")
                            .font(.title2)
                            .foregroundColor(isLiked ? OlasDesign.Colors.error : OlasDesign.Colors.text)
                            .scaleEffect(isLiked ? 1.1 : 1.0)
                            .olasTextShadow()
                        if item.likeCount > 0 {
                            Text("\(item.likeCount)")
                                .font(OlasDesign.Typography.caption)
                                .foregroundColor(OlasDesign.Colors.textSecondary)
                                .olasTextShadow()
                        }
                    }
                }
                // Reply button with count
                Button(action: { 
                    OlasDesign.Haptic.selection()
                    showingReplies.toggle()
                }) {
                    HStack(spacing: 4) {
                        Image(systemName: "bubble.left")
                            .font(.title2)
                            .foregroundColor(OlasDesign.Colors.text)
                            .olasTextShadow()
                        if item.replyCount > 0 {
                            Text("\(item.replyCount)")
                                .font(OlasDesign.Typography.caption)
                                .foregroundColor(OlasDesign.Colors.textSecondary)
                                .olasTextShadow()
                        }
                    }
                }
                // Zap button with amount
                Button(action: { sendZap() }) {
                    HStack(spacing: 4) {
                        Image(systemName: "bolt")
                            .font(.title2)
                            .foregroundColor(item.zapAmount > 0 ? OlasDesign.Colors.warning : OlasDesign.Colors.text)
                            .olasTextShadow()
                        if item.zapAmount > 0 {
                            Text("\(item.zapAmount)")
                                .font(OlasDesign.Typography.caption)
                                .foregroundColor(OlasDesign.Colors.textSecondary)
                                .olasTextShadow()
                        }
                    }
                }
                Spacer()
                // Share button
                Button(action: { sharePost() }) {
                    Image(systemName: "square.and.arrow.up")
                        .font(.title2)
                        .foregroundColor(OlasDesign.Colors.text)
                        .olasTextShadow()
                }
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.md)
            // Content with rich text
            if !item.event.content.isEmpty {
                OlasRichText(
                    content: item.event.content,
                    tags: item.event.tags
                )
                .padding(.horizontal, OlasDesign.Spacing.md)
                .padding(.bottom, OlasDesign.Spacing.md)
            }
        }
        .background(OlasDesign.Colors.background)
        .overlay(
            // Like animation overlay
            Group {
                if showingLikeAnimation {
                    LikeAnimationView(location: doubleTapLocation)
                        .onAppear {
                            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                                showingLikeAnimation = false
                            }
                        }
                }
            }
        )
        .sheet(isPresented: $showingReplies) {
            ReplyView(parentEvent: item.event)
                .environmentObject(appState)
        }
        .sheet(isPresented: $showingZap) {
            ZapView(event: item.event, nostrManager: nostrManager)
                .environmentObject(appState)
        }
        .navigationDestination(isPresented: $navigateToProfile) {
            ProfileView(pubkey: item.event.pubkey)
        }
        .navigationDestination(isPresented: $showProfile) {
            ProfileView(pubkey: item.event.pubkey)
        }
        .task {
            await loadEngagementCounts()
        }
    }
    // MARK: - Engagement Actions
    private func toggleLike() {
        guard let ndk = nostrManager.ndk,
              let signer = NDKAuthManager.shared.activeSigner else { return }
        #if os(iOS)
        OlasDesign.Haptic.impact(.light)
        #else
        OlasDesign.Haptic.impact(0)
        #endif
        withAnimation(OlasDesign.Animation.spring) {
            isLiked.toggle()
        }
        Task {
            do {
                if isLiked {
                    // Create like reaction (kind 7)
                    let reaction = try await NDKEventBuilder(ndk: ndk)
                        .kind(7)
                        .content("+")
                        .tags([
                            ["e", item.event.id],
                            ["p", item.event.pubkey]
                        ])
                        .build(signer: signer)
                    _ = try await ndk.publish(reaction)
                } else {
                    // TODO: Delete reaction event
                }
            } catch {
                print("Error toggling like: \(error)")
                // Revert on error
                withAnimation {
                    isLiked.toggle()
                }
            }
        }
    }
    private func sendZap() {
        OlasDesign.Haptic.selection()
        showingZap = true
    }
    private func sharePost() {
        OlasDesign.Haptic.selection()
        #if os(iOS)
        let noteLink = "nostr:\(item.event.id)"
        let activityVC = UIActivityViewController(
            activityItems: [noteLink],
            applicationActivities: nil
        )
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.windows.first,
           let rootVC = window.rootViewController {
            rootVC.present(activityVC, animated: true)
        }
        #else
        // macOS sharing
        let noteLink = "nostr:\(item.event.id)"
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(noteLink, forType: .string)
        #endif
    }
    private func loadEngagementCounts() async {
        guard let ndk = nostrManager.ndk else { return }
        // Check if we already liked this - reactive pattern
        let authManager = NDKAuthManager.shared
        if let signer = authManager.activeSigner,
           let myPubkey = try? await signer.pubkey {
            let likeFilter = NDKFilter(
                authors: [myPubkey],
                kinds: [7],
                events: [item.event.id]
            )
            // Use reactive observe pattern - check cache first
            let likeDataSource = ndk.observe(
                filter: likeFilter,
                maxAge: 3600, // 1 hour cache
                cachePolicy: .cacheOnly // Only check cache, don't fetch from network
            )
            // Check first event to see if we liked it
            for await reaction in likeDataSource.events {
                if reaction.content == "+" || reaction.content == "" {
                    await MainActor.run {
                        isLiked = true
                    }
                }
                break // Only need to check if any exist
            }
        }
        // Engagement counts are already being loaded reactively by FeedViewModel
        // No need to duplicate that logic here
    }
}
@MainActor
class FeedViewModel: ObservableObject {
    @Published var items: [FeedItem] = []
    @Published var pendingItems: [FeedItem] = []
    @Published var isLoading = true
    @Published var isLive = false
    @Published var pendingItemsCount = 0
    private var profileTasks: [String: Task<Void, Never>] = [:]
    private var feedTask: Task<Void, Never>?
    private var engagementTasks: [String: Task<Void, Never>] = [:]
    private var lastEventTime: Timestamp?
    func startFeed(with ndk: NDK) {
        // Cancel any existing feed task
        feedTask?.cancel()
        isLoading = true
        feedTask = Task {
            // Simulate loading for smooth animation
            try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
            await MainActor.run {
                self.isLoading = false
                self.isLive = true
            }
            // Subscribe to kind 20 picture posts (NIP-68)
            let filter = NDKFilter(kinds: [20], limit: 100)
            // Create data source using observe with reactive pattern
            let dataSource = ndk.observe(
                filter: filter,
                maxAge: 0,  // Real-time updates
                cachePolicy: .cacheWithNetwork
            )
            for await event in dataSource.events {
                // Process kind 20 events which use imeta tags
                if event.kind == 20 {
                    let feedItem = FeedItem(from: event)
                    await MainActor.run {
                        // Check if this is a new post (arrived after initial load)
                        let isNewPost = lastEventTime != nil && event.createdAt > lastEventTime!
                        if isNewPost {
                            // Add to pending items
                            if let insertIndex = pendingItems.firstIndex(where: { $0.event.createdAt < event.createdAt }) {
                                pendingItems.insert(feedItem, at: insertIndex)
                            } else {
                                pendingItems.append(feedItem)
                            }
                            pendingItemsCount = pendingItems.count
                            // Haptic feedback for new posts
                            #if os(iOS)
                            OlasDesign.Haptic.impact(.light)
                            #endif
                        } else {
                            // Insert sorted by timestamp
                            if let insertIndex = items.firstIndex(where: { $0.event.createdAt < event.createdAt }) {
                                items.insert(feedItem, at: insertIndex)
                            } else {
                                items.append(feedItem)
                            }
                            // Update last event time
                            if lastEventTime == nil || event.createdAt > lastEventTime! {
                                lastEventTime = event.createdAt
                            }
                        }
                        // Limit feed size for performance
                        if items.count > 200 {
                            items.removeLast(items.count - 200)
                        }
                    }
                    // Load profile reactively
                    loadProfileReactively(for: event.pubkey, ndk: ndk)
                    // Load engagement counts reactively
                    loadEngagementReactively(for: event.id, ndk: ndk)
                }
            }
        }
    }
    private func loadProfileReactively(for pubkey: String, ndk: NDK) {
        // Cancel existing task if any
        profileTasks[pubkey]?.cancel()
        // Start new profile observation
        profileTasks[pubkey] = Task {
            guard let profileManager = ndk.profileManager else { return }
            for await profile in await profileManager.observe(for: pubkey, maxAge: 3600) {
                if let profile = profile {
                    await MainActor.run {
                        updateItemsWithProfile(pubkey: pubkey, profile: profile)
                    }
                }
            }
        }
    }
    private func updateItemsWithProfile(pubkey: String, profile: NDKUserProfile) {
        for index in items.indices {
            if items[index].event.pubkey == pubkey {
                items[index].profile = profile
            }
        }
    }
    func refresh() async {
        // Clear items and restart subscription
        await MainActor.run {
            items.removeAll()
            pendingItems.removeAll()
            pendingItemsCount = 0
            lastEventTime = nil
        }
        // Cancel all tasks
        feedTask?.cancel()
        profileTasks.values.forEach { $0.cancel() }
        profileTasks.removeAll()
        engagementTasks.values.forEach { $0.cancel() }
        engagementTasks.removeAll()
        // Restart feed will happen when view calls startFeed again
    }
    func loadPendingItems() {
        // Move pending items to main feed
        let itemsToAdd = pendingItems
        pendingItems.removeAll()
        pendingItemsCount = 0
        // Insert all pending items with animation
        for item in itemsToAdd {
            if let insertIndex = items.firstIndex(where: { $0.event.createdAt < item.event.createdAt }) {
                items.insert(item, at: insertIndex)
            } else {
                items.append(item)
            }
        }
        // Update last event time
        if let latestItem = items.first {
            lastEventTime = latestItem.event.createdAt
        }
    }
    private func loadEngagementReactively(for eventId: String, ndk: NDK) {
        // Cancel existing task if any
        engagementTasks[eventId]?.cancel()
        engagementTasks[eventId] = Task {
            // Observe reactions (kind 7)
            let reactionsFilter = NDKFilter(
                kinds: [7],
                events: [eventId]
            )
            let reactionsDataSource = ndk.observe(
                filter: reactionsFilter,
                maxAge: 0,
                cachePolicy: .cacheWithNetwork
            )
            // Observe comments (NIP-22)
            let repliesFilter = NDKFilter(
                kinds: [EventKind.genericReply],
                tags: [
                    "E": Set([eventId]),  // Comments on this as root
                    "e": Set([eventId])   // Or as parent
                ]
            )
            let repliesDataSource = ndk.observe(
                filter: repliesFilter,
                maxAge: 0,
                cachePolicy: .cacheWithNetwork
            )
            // Observe zaps (kind 9735)
            let zapsFilter = NDKFilter(
                kinds: [9735],  // NIP-57 zap receipts
                tags: [
                    "e": Set([eventId])  // Zaps for this event
                ]
            )
            let zapsDataSource = ndk.observe(
                filter: zapsFilter,
                maxAge: 0,
                cachePolicy: .cacheWithNetwork
            )
            // Update engagement counts reactively
            await withTaskGroup(of: Void.self) { group in
                group.addTask {
                    for await reaction in reactionsDataSource.events {
                        if reaction.content == "+" || reaction.content == "" {
                            await MainActor.run {
                                self.updateEngagement(for: eventId, type: .like, increment: true)
                            }
                        }
                    }
                }
                group.addTask {
                    for await _ in repliesDataSource.events {
                        await MainActor.run {
                            self.updateEngagement(for: eventId, type: .reply, increment: true)
                        }
                    }
                }
                group.addTask {
                    for await zapReceipt in zapsDataSource.events {
                        // Extract zap amount from bolt11 tag
                        let zapAmount = await self.extractZapAmount(from: zapReceipt)
                        if zapAmount > 0 {
                            await MainActor.run {
                                self.updateEngagement(for: eventId, type: .zap, amount: zapAmount)
                            }
                        }
                    }
                }
            }
        }
    }
    private func updateEngagement(for eventId: String, type: EngagementType, increment: Bool = true, amount: Int = 0) {
        guard let index = items.firstIndex(where: { $0.event.id == eventId }) else { return }
        switch type {
        case .like:
            items[index].likeCount += increment ? 1 : -1
        case .reply:
            items[index].replyCount += increment ? 1 : -1
        case .zap:
            items[index].zapAmount += amount
        }
    }
    enum EngagementType {
        case like, reply, zap
    }
    private func extractZapAmount(from zapReceiptEvent: NDKEvent) async -> Int {
        // Use NDKSwift's built-in NDKZapReceipt for proper NIP-57 parsing
        let zapReceipt = NDKZapReceipt(event: zapReceiptEvent)
        // Get amount in sats (NDKZapReceipt handles bolt11 parsing)
        if let amountSats = zapReceipt.amountSats {
            return Int(amountSats)
        }
        return 0
    }
}
struct FeedItem: Identifiable {
    let id: String
    let event: NDKEvent
    var profile: NDKUserProfile?
    let imageURLs: [String]
    let blurhashes: [String]
    var likeCount: Int = 0
    var replyCount: Int = 0
    var zapAmount: Int = 0
    init(from event: NDKEvent) {
        self.id = event.id
        self.event = event
        // Extract images and blurhashes from imeta tags (NIP-68 requires imeta tags)
        self.imageURLs = event.imageURLs
        // Extract blurhashes from imeta tags
        var hashes: [String] = []
        for tag in event.tags where tag.count >= 1 && tag[0] == "imeta" {
            var blurhash: String?
            // Parse imeta tag values
            for i in stride(from: 1, to: tag.count, by: 2) {
                if i + 1 < tag.count {
                    let key = tag[i]
                    let value = tag[i + 1]
                    if key == "blurhash" {
                        blurhash = value
                    }
                }
            }
            if let hash = blurhash {
                hashes.append(hash)
            } else {
                hashes.append("") // Empty string for missing blurhash
            }
        }
        self.blurhashes = hashes
    }
    static func extractImagesFromEvent(_ event: NDKEvent) -> [String] {
        // Use NDKSwift's built-in imeta support
        return event.imageURLs
    }
}
// MARK: - Feed Item Skeleton
struct FeedItemSkeletonView: View {
    @State private var shimmerAnimation = false
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header skeleton
            HStack(spacing: OlasDesign.Spacing.md) {
                Circle()
                    .fill(OlasDesign.Colors.surface)
                    .overlay(shimmerGradient)
                    .frame(width: 40, height: 40)
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.xs)
                        .fill(OlasDesign.Colors.surface)
                        .overlay(shimmerGradient)
                        .frame(width: 120, height: 14)
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.xs)
                        .fill(OlasDesign.Colors.surface)
                        .overlay(shimmerGradient)
                        .frame(width: 80, height: 12)
                }
                Spacer()
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.md)
            // Image skeleton
            Rectangle()
                .fill(OlasDesign.Colors.surface)
                .overlay(shimmerGradient)
                .aspectRatio(4/5, contentMode: .fit)
            // Actions skeleton
            HStack(spacing: OlasDesign.Spacing.xl) {
                ForEach(0..<4) { _ in
                    Circle()
                        .fill(OlasDesign.Colors.surface)
                        .overlay(shimmerGradient)
                        .frame(width: 24, height: 24)
                }
                Spacer()
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.vertical, OlasDesign.Spacing.md)
            // Content skeleton
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.xs)
                    .fill(OlasDesign.Colors.surface)
                    .overlay(shimmerGradient)
                    .frame(height: 14)
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.xs)
                    .fill(OlasDesign.Colors.surface)
                    .overlay(shimmerGradient)
                    .frame(width: 200, height: 14)
            }
            .padding(.horizontal, OlasDesign.Spacing.md)
            .padding(.bottom, OlasDesign.Spacing.md)
        }
        .background(OlasDesign.Colors.background)
        .onAppear {
            withAnimation(.linear(duration: 1.5).repeatForever(autoreverses: false)) {
                shimmerAnimation = true
            }
        }
    }
    private var shimmerGradient: some View {
        LinearGradient(
            colors: [
                Color.white.opacity(0),
                Color.white.opacity(0.1),
                Color.white.opacity(0)
            ],
            startPoint: .leading,
            endPoint: .trailing
        )
        .rotationEffect(.degrees(30))
        .offset(x: shimmerAnimation ? 300 : -300)
        .transition(.move(edge: .leading))
    }
}
// MARK: - Empty Feed View
struct EmptyFeedView: View {
    let hasAppeared: Bool
    @State private var pulseAnimation = false
    var body: some View {
        VStack(spacing: OlasDesign.Spacing.xxxl) {
            Spacer()
            // Animated illustration
            ZStack {
                // Glowing background
                Circle()
                    .fill(
                        LinearGradient(
                            colors: OlasDesign.Colors.primaryGradient.map { $0.opacity(0.2) },
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 200, height: 200)
                    .blur(radius: 50)
                    .scaleEffect(pulseAnimation ? 1.3 : 0.9)
                    .animation(
                        .easeInOut(duration: 3).repeatForever(autoreverses: true),
                        value: pulseAnimation
                    )
                // Camera icon
                Image(systemName: "camera.fill")
                    .font(.system(size: 80))
                    .foregroundStyle(
                        LinearGradient(
                            colors: OlasDesign.Colors.primaryGradient,
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .rotationEffect(.degrees(pulseAnimation ? 10 : -10))
                    .animation(
                        .easeInOut(duration: 2).repeatForever(autoreverses: true),
                        value: pulseAnimation
                    )
            }
            .scaleEffect(hasAppeared ? 1 : 0.5)
            .opacity(hasAppeared ? 1 : 0)
            .animation(.spring(response: 0.6, dampingFraction: 0.8), value: hasAppeared)
            VStack(spacing: OlasDesign.Spacing.md) {
                Text("Your Feed is Empty")
                    .font(.system(size: 28, weight: .semibold, design: .rounded))
                    .foregroundStyle(.white)
                Text("Be the first to share a beautiful moment")
                    .font(OlasDesign.Typography.body)
                    .foregroundStyle(.white.opacity(0.7))
                    .multilineTextAlignment(.center)
            }
            .opacity(hasAppeared ? 1 : 0)
            .offset(y: hasAppeared ? 0 : 20)
            .animation(.easeOut(duration: 0.6).delay(0.2), value: hasAppeared)
            VStack(spacing: OlasDesign.Spacing.md) {
                Button {
                    #if os(iOS)
        OlasDesign.Haptic.impact(.medium)
        #else
        OlasDesign.Haptic.impact(0)
        #endif
                    // TODO: Navigate to create post
                } label: {
                    HStack {
                        Image(systemName: "plus.circle.fill")
                        Text("Create Your First Post")
                    }
                    .font(OlasDesign.Typography.bodyBold)
                    .foregroundStyle(.white)
                    .padding(.horizontal, OlasDesign.Spacing.xl)
                    .padding(.vertical, OlasDesign.Spacing.md)
                    .background(
                        LinearGradient(
                            colors: OlasDesign.Colors.primaryGradient,
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.full))
                    .shadow(color: OlasDesign.Colors.primaryGradient[0].opacity(0.3), radius: 20, y: 10)
                }
                Button {
                    #if os(iOS)
                    OlasDesign.Haptic.impact(.light)
                    #else
                    OlasDesign.Haptic.impact(0)
                    #endif
                    // TODO: Navigate to discover
                } label: {
                    Text("Discover People to Follow")
                        .font(OlasDesign.Typography.body)
                        .foregroundStyle(.white.opacity(0.8))
                }
            }
            .scaleEffect(hasAppeared ? 1 : 0.8)
            .opacity(hasAppeared ? 1 : 0)
            .animation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.4), value: hasAppeared)
            Spacer()
            Spacer()
        }
        .padding(.horizontal, OlasDesign.Spacing.xl)
        .onAppear {
            pulseAnimation = true
        }
    }
}
// MARK: - Like Animation View
struct LikeAnimationView: View {
    let location: CGPoint
    @State private var hearts: [HeartParticle] = []
    @State private var mainHeartScale: CGFloat = 0
    @State private var mainHeartOpacity: Double = 1
    struct HeartParticle: Identifiable {
        let id = UUID()
        var startPosition: CGPoint
        let endPosition: CGPoint
        let rotation: Double
        let scale: CGFloat
        let color: Color
    }
    var body: some View {
        ZStack {
            // Main heart
            Image(systemName: "heart.fill")
                .font(.system(size: 100))
                .foregroundStyle(
                    LinearGradient(
                        colors: [OlasDesign.Colors.like, Color.pink],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .scaleEffect(mainHeartScale)
                .opacity(mainHeartOpacity)
                .position(location)
            // Particle hearts
            ForEach(hearts) { heart in
                Image(systemName: "heart.fill")
                    .font(.system(size: 20))
                    .foregroundStyle(heart.color)
                    .scaleEffect(heart.scale)
                    .rotationEffect(.degrees(heart.rotation))
                    .position(heart.startPosition)
                    .animation(.easeOut(duration: 1.5), value: heart.startPosition)
            }
        }
        .onAppear {
            // Animate main heart
            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                mainHeartScale = 1.2
            }
            withAnimation(.easeOut(duration: 0.8).delay(0.2)) {
                mainHeartOpacity = 0
            }
            // Generate particles
            generateParticles()
            // Animate particles after a delay
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                for i in hearts.indices {
                    withAnimation(.easeOut(duration: 1.5)) {
                        hearts[i].startPosition = hearts[i].endPosition
                    }
                }
            }
            // Haptic feedback
            OlasDesign.Haptic.success()
        }
    }
    private func generateParticles() {
        for _ in 0..<12 {
            let angle = Double.random(in: 0...(2 * .pi))
            let distance = CGFloat.random(in: 100...200)
            let endX = location.x + cos(angle) * distance
            let endY = location.y + sin(angle) * distance - 50 // Bias upward
            let heart = HeartParticle(
                startPosition: location,
                endPosition: CGPoint(x: endX, y: endY),
                rotation: Double.random(in: -45...45),
                scale: CGFloat.random(in: 0.5...1.2),
                color: [OlasDesign.Colors.like, .pink, .red].randomElement()!
            )
            hearts.append(heart)
        }
    }
}
</file>

<file path="Olas/Views/MainTabView.swift">
import SwiftUI
import NDKSwift
struct MainTabView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var selectedTab = 0
    @State private var previousTab = 0
    @State private var showCreatePost = false
    @State private var tabBarOpacity = 1.0
    @State private var tabBarOffset: CGFloat = 0
    var body: some View {
        TabView(selection: $selectedTab) {
            // Home Feed
            NavigationStack {
                FeedView()
            }
            .tabItem {
                Label("Home", systemImage: selectedTab == 0 ? "house.fill" : "house")
            }
            .tag(0)
            .accessibilityIdentifier("feedTab")
            // Explore/Search
            NavigationStack {
                ExploreView()
            }
            .tabItem {
                Label("Explore", systemImage: selectedTab == 1 ? "magnifyingglass.circle.fill" : "magnifyingglass")
            }
            .tag(1)
            .accessibilityIdentifier("exploreTab")
            // Create Post - presented as sheet
            Color.clear
                .tabItem {
                    Label("Create", systemImage: "plus.square")
                }
                .tag(2)
                .accessibilityIdentifier("createTab")
                .onAppear {
                    if selectedTab == 2 {
                        showCreatePost = true
                        // Reset to previous tab
                        selectedTab = previousTab
                    }
                }
            // Profile Tab with Wallet & Analytics Access
            Group {
                if let session = nostrManager.authManager.activeSession {
                    NavigationStack {
                        ProfileView(pubkey: session.pubkey)
                            .toolbar {
                                ToolbarItem(placement: .navigationBarTrailing) {
                                    HStack(spacing: 16) {
                                        // Analytics
                                        NavigationLink(destination: AnalyticsDashboardView().environment(nostrManager)) {
                                            Image(systemName: "chart.line.uptrend.xyaxis")
                                                .foregroundStyle(OlasDesign.Colors.primary)
                                        }
                                        // Wallet
                                        NavigationLink(destination: OlasWalletView(walletManager: OlasWalletManager(nostrManager: nostrManager), nostrManager: nostrManager)) {
                                            Image(systemName: "bolt.circle")
                                                .foregroundStyle(OlasDesign.Colors.primary)
                                        }
                                    }
                                }
                            }
                    }
                } else {
                    Text("Profile")
                }
            }
            .tabItem {
                Label("Profile", systemImage: selectedTab == 3 ? "person.circle.fill" : "person.circle")
            }
            .tag(3)
            .accessibilityIdentifier("profileTab")
        }
        .accessibilityIdentifier("mainTabBar")
        .tint(OlasDesign.Colors.primary)
        .onChange(of: selectedTab) { oldValue, newValue in
            if newValue != 2 {
                previousTab = oldValue
            }
        }
        .sheet(isPresented: $showCreatePost) {
            CreatePostView()
                .environmentObject(appState)
                .environment(nostrManager)
        }
        .onAppear {
            setupTabBarAppearance()
        }
    }
    private func setupTabBarAppearance() {
        let appearance = UITabBarAppearance()
        appearance.configureWithOpaqueBackground()
        appearance.backgroundColor = UIColor(OlasDesign.Colors.background)
        appearance.shadowColor = UIColor(OlasDesign.Colors.divider)
        UITabBar.appearance().standardAppearance = appearance
        UITabBar.appearance().scrollEdgeAppearance = appearance
    }
}
</file>

<file path="Olas/Views/PostDetailView.swift">
import SwiftUI
import NDKSwift
struct PostDetailView: View {
    let event: NDKEvent
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var profile: NDKUserProfile?
    @State private var imageUrls: [String] = []
    @State private var likeCount = 0
    @State private var replyCount = 0
    @State private var hasLiked = false
    @State private var showingReplies = false
    @State private var showingZap = false
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            ScrollView {
                VStack(spacing: 0) {
                    // Images
                    if !imageUrls.isEmpty {
                        OlasMultiImageView(imageURLs: imageUrls)
                            .padding(.bottom, OlasDesign.Spacing.lg)
                    }
                    VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
                        // Author info
                        HStack(spacing: OlasDesign.Spacing.sm) {
                            NavigationLink(destination: ProfileView(pubkey: event.pubkey)) {
                                HStack(spacing: OlasDesign.Spacing.sm) {
                                    OlasAvatar(
                                        url: profile?.picture,
                                        size: 40,
                                        pubkey: event.pubkey
                                    )
                                    VStack(alignment: .leading, spacing: 2) {
                                        Text(profile?.displayName ?? profile?.name ?? "...")
                                            .font(OlasDesign.Typography.bodyMedium)
                                            .foregroundColor(OlasDesign.Colors.text)
                                        Text(formatDate(Date(timeIntervalSince1970: TimeInterval(event.createdAt))))
                                            .font(OlasDesign.Typography.caption)
                                            .foregroundColor(OlasDesign.Colors.textSecondary)
                                    }
                                }
                            }
                            Spacer()
                        }
                        // Content
                        OlasRichText(
                            content: event.content,
                            tags: event.tags
                        )
                        .padding(.vertical, OlasDesign.Spacing.sm)
                        Divider()
                            .padding(.vertical, OlasDesign.Spacing.md)
                        // Engagement buttons
                        HStack(spacing: OlasDesign.Spacing.xl) {
                            // Like
                            Button(action: toggleLike) {
                                HStack(spacing: OlasDesign.Spacing.xs) {
                                    Image(systemName: hasLiked ? "heart.fill" : "heart")
                                        .foregroundColor(hasLiked ? OlasDesign.Colors.like : OlasDesign.Colors.textSecondary)
                                    if likeCount > 0 {
                                        Text("\(likeCount)")
                                            .font(OlasDesign.Typography.caption)
                                            .foregroundColor(OlasDesign.Colors.textSecondary)
                                    }
                                }
                            }
                            // Reply
                            Button(action: { showingReplies = true }) {
                                HStack(spacing: OlasDesign.Spacing.xs) {
                                    Image(systemName: "bubble.left")
                                        .foregroundColor(OlasDesign.Colors.textSecondary)
                                    if replyCount > 0 {
                                        Text("\(replyCount)")
                                            .font(OlasDesign.Typography.caption)
                                            .foregroundColor(OlasDesign.Colors.textSecondary)
                                    }
                                }
                            }
                            // Zap
                            Button(action: { showingZap = true }) {
                                Image(systemName: "bolt")
                                    .foregroundColor(OlasDesign.Colors.textSecondary)
                            }
                            // Share
                            Button(action: sharePost) {
                                Image(systemName: "square.and.arrow.up")
                                    .foregroundColor(OlasDesign.Colors.textSecondary)
                            }
                            Spacer()
                        }
                        .font(.system(size: 20))
                    }
                    .padding(.horizontal, OlasDesign.Spacing.lg)
                }
            }
        }
        .navigationTitle("Post")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.inline)
        #endif
        .task {
            await loadProfile()
            await loadEngagementCounts()
            imageUrls = extractImageUrls(from: event.content)
        }
        .sheet(isPresented: $showingReplies) {
            ReplyView(parentEvent: event)
                .environmentObject(appState)
        }
        .sheet(isPresented: $showingZap) {
            ZapView(event: event, nostrManager: nostrManager)
                .environmentObject(appState)
        }
    }
    private func loadProfile() async {
        guard let profileManager = nostrManager.ndk?.profileManager else { return }
        for await profile in await profileManager.observe(for: event.pubkey, maxAge: 3600) {
            await MainActor.run {
                self.profile = profile
            }
            break
        }
    }
    private func loadEngagementCounts() async {
        guard let ndk = nostrManager.ndk else { return }
        // Load reactions
        let reactionFilter = NDKFilter(
            kinds: [EventKind.reaction],
            events: [event.id]
        )
        // Load replies
        let replyFilter = NDKFilter(
            kinds: [EventKind.textNote],
            tags: ["e": Set([event.id])]
        )
        Task {
            // Count reactions
            let reactionDataSource = ndk.observe(filter: reactionFilter)
            let reactions = await reactionDataSource.collect(timeout: 2.0)
            var likes = 0
            var userLiked = false
            let currentUserPubkey = appState.currentUser?.pubkey
            for reaction in reactions.prefix(100) {
                if reaction.content == "+" || reaction.content == "" {
                    likes += 1
                    if reaction.pubkey == currentUserPubkey {
                        userLiked = true
                    }
                }
            }
            await MainActor.run {
                self.likeCount = likes
                self.hasLiked = userLiked
            }
        }
        Task {
            // Count replies
            let replyDataSource = ndk.observe(filter: replyFilter)
            let replies = await replyDataSource.collect(timeout: 2.0)
            await MainActor.run {
                self.replyCount = replies.count
            }
        }
    }
    private func toggleLike() {
        guard let ndk = nostrManager.ndk,
              let signer = NDKAuthManager.shared.activeSigner else { return }
        hasLiked.toggle()
        likeCount += hasLiked ? 1 : -1
        #if os(iOS)
        OlasDesign.Haptic.impact(.light)
        #else
        OlasDesign.Haptic.impact(0)
        #endif
        Task {
            do {
                let reaction = try await NDKEventBuilder(ndk: ndk)
                    .content("+")
                    .kind(EventKind.reaction)
                    .tag(["e", event.id])
                    .tag(["p", event.pubkey])
                    .build(signer: signer)
                _ = try await ndk.publish(reaction)
            } catch {
                // Revert on error
                await MainActor.run {
                    hasLiked.toggle()
                    likeCount += hasLiked ? 1 : -1
                }
                OlasDesign.Haptic.error()
            }
        }
    }
    private func sharePost() {
        let nostrLink = "nostr:\(event.id)"
        #if canImport(UIKit)
        let activityViewController = UIActivityViewController(
            activityItems: [nostrLink],
            applicationActivities: nil
        )
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.windows.first,
           let rootViewController = window.rootViewController {
            rootViewController.present(activityViewController, animated: true)
        }
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(nostrLink, forType: .string)
        #endif
        OlasDesign.Haptic.success()
    }
    private func formatDate(_ date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
    private func extractImageUrls(from content: String) -> [String] {
        let pattern = "(https?://[^\\s]+\\.(jpg|jpeg|png|gif|webp)[^\\s]*)"
        let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)
        let matches = regex?.matches(in: content, options: [], range: NSRange(content.startIndex..., in: content)) ?? []
        return matches.compactMap { match in
            guard let range = Range(match.range, in: content) else { return nil }
            return String(content[range])
        }
    }
}
</file>

<file path="Olas/Views/ProfileView.swift">
import SwiftUI
import NDKSwift
struct ProfileView: View {
    let pubkey: String
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @StateObject private var viewModel = ProfileViewModel()
    @State private var selectedTab = 0
    @State private var headerHeight: CGFloat = 300
    @State private var scrollOffset: CGFloat = 0
    @State private var showFollowers = false
    @State private var showFollowing = false
    @State private var selectedFollowMode: FollowersListView.FollowMode = .followers
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            ScrollView {
                VStack(spacing: 0) {
                    // Profile Header with Parallax
                    ProfileHeaderView(
                        profile: viewModel.profile,
                        pubkey: pubkey,
                        scrollOffset: scrollOffset,
                        isFollowing: viewModel.isFollowing,
                        followersCount: viewModel.followersCount,
                        followingCount: viewModel.followingCount,
                        postsCount: viewModel.postsCount,
                        onFollowToggle: { viewModel.toggleFollow() }
                    )
                    .frame(height: headerHeight)
                    // Content Tabs
                    ProfileTabBar(selectedTab: $selectedTab)
                        .padding(.top, OlasDesign.Spacing.md)
                    // Content Grid
                    switch selectedTab {
                    case 0:
                        ProfileImageGrid(posts: viewModel.imagePosts)
                            .padding(.top, OlasDesign.Spacing.md)
                    case 1:
                        ProfileRepliesView(replies: viewModel.replies)
                            .padding(.top, OlasDesign.Spacing.md)
                    case 2:
                        ProfileZapsView(zaps: viewModel.zaps)
                            .padding(.top, OlasDesign.Spacing.md)
                    default:
                        EmptyView()
                    }
                }
                .background(
                    GeometryReader { geo in
                        Color.clear
                            .preference(key: ScrollOffsetPreferenceKey.self, value: geo.frame(in: .named("scroll")).minY)
                    }
                )
            }
            .coordinateSpace(name: "scroll")
            .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
                scrollOffset = value
            }
        }
        #if os(iOS)
        .navigationBarTitleDisplayMode(.inline)
        #endif
        .onAppear {
            if let ndk = nostrManager.ndk {
                viewModel.startObserving(pubkey: pubkey, ndk: ndk)
            }
        }
        .sheet(isPresented: $showFollowers) {
            FollowersListView(pubkey: pubkey, mode: .followers)
                .environment(nostrManager)
        }
        .sheet(isPresented: $showFollowing) {
            FollowersListView(pubkey: pubkey, mode: .following)
                .environment(nostrManager)
        }
    }
}
// MARK: - Profile Header
struct ProfileHeaderView: View {
    let profile: NDKUserProfile?
    let pubkey: String
    let scrollOffset: CGFloat
    let isFollowing: Bool
    let followersCount: Int
    let followingCount: Int
    let postsCount: Int
    let onFollowToggle: () -> Void
    private var parallaxOffset: CGFloat {
        scrollOffset > 0 ? -scrollOffset / 2 : 0
    }
    private var scale: CGFloat {
        scrollOffset > 0 ? 1 + (scrollOffset / 500) : 1
    }
    var body: some View {
        ZStack(alignment: .bottom) {
            // Banner Image with Parallax
            if let banner = profile?.banner, let bannerURL = URL(string: banner) {
                AsyncImage(url: bannerURL) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(height: 200)
                        .scaleEffect(scale)
                        .offset(y: parallaxOffset)
                        .clipped()
                } placeholder: {
                    OlasLoadingView()
                        .frame(height: 200)
                }
            } else {
                OlasDesign.currentGradient
                .frame(height: 200)
                .scaleEffect(scale)
                .offset(y: parallaxOffset)
            }
            // Profile Info
            VStack(spacing: OlasDesign.Spacing.md) {
                // Avatar with 3D rotation
                OlasAvatar(
                    url: profile?.picture,
                    size: 120,
                    pubkey: pubkey
                )
                .overlay(
                    Circle()
                        .stroke(OlasDesign.Colors.background, lineWidth: 4)
                )
                .rotation3DEffect(
                    .degrees(Double(scrollOffset / 10)),
                    axis: (x: 0, y: 1, z: 0)
                )
                .shadow(color: .black.opacity(0.3), radius: 10, x: 0, y: 5)
                .offset(y: 60) // Overlap with banner
                // Name and username
                VStack(spacing: 4) {
                    Text(profile?.displayName ?? profile?.name ?? "Loading...")
                        .font(OlasDesign.Typography.title)
                        .foregroundColor(OlasDesign.Colors.text)
                        .olasTextShadow()
                    Text("@\(profile?.name ?? String(pubkey.prefix(8)))")
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                .padding(.top, 70)
                // Bio
                if let about = profile?.about {
                    Text(about)
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal, OlasDesign.Spacing.lg)
                }
                // Stats with animated counting
                HStack(spacing: OlasDesign.Spacing.xl) {
                    ProfileStatView(value: postsCount, label: "Posts")
                    ProfileStatView(value: followersCount, label: "Followers")
                    ProfileStatView(value: followingCount, label: "Following")
                }
                // Follow/Edit Button
                OlasButton(
                    title: isFollowing ? "Following" : "Follow",
                    action: {
                        #if os(iOS)
                        OlasDesign.Haptic.impact(.medium)
                        #else
                        OlasDesign.Haptic.impact(0)
                        #endif
                        onFollowToggle()
                    },
                    style: isFollowing ? .secondary : .primary
                )
                .padding(.horizontal, OlasDesign.Spacing.lg)
                .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isFollowing)
            }
            .padding(.bottom, OlasDesign.Spacing.lg)
            .background(
                OlasDesign.Colors.background
                    .opacity(0.95)
                    .blur(radius: 20)
                    .padding(.top, -50) // Extend behind avatar
            )
        }
    }
}
// MARK: - Profile Stats
struct ProfileStatView: View {
    let value: Int
    let label: String
    @State private var displayValue = 0
    var body: some View {
        VStack(spacing: 4) {
            Text(displayValue < 0 ? "N/A" : "\(displayValue)")
                .font(OlasDesign.Typography.title)
                .foregroundColor(OlasDesign.Colors.text)
                .contentTransition(.numericText())
                .olasTextShadow()
            Text(label)
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .onAppear {
            withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                displayValue = value
            }
        }
        .onChange(of: value) { _, newValue in
            withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                displayValue = newValue
            }
        }
    }
}
// MARK: - Tab Bar
struct ProfileTabBar: View {
    @Binding var selectedTab: Int
    var body: some View {
        HStack(spacing: 0) {
            ProfileTabButton(
                icon: "square.grid.3x3",
                isSelected: selectedTab == 0,
                action: { selectedTab = 0 }
            )
            ProfileTabButton(
                icon: "bubble.left",
                isSelected: selectedTab == 1,
                action: { selectedTab = 1 }
            )
            ProfileTabButton(
                icon: "bolt",
                isSelected: selectedTab == 2,
                action: { selectedTab = 2 }
            )
        }
        .background(OlasDesign.Colors.surface)
        .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md))
        .padding(.horizontal, OlasDesign.Spacing.lg)
    }
}
struct ProfileTabButton: View {
    let icon: String
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: {
            OlasDesign.Haptic.selection()
            action()
        }) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(isSelected ? OlasDesign.Colors.primary : OlasDesign.Colors.textSecondary)
                .frame(maxWidth: .infinity, maxHeight: 44)
                .background(
                    isSelected ? OlasDesign.Colors.primary.opacity(0.1) : Color.clear
                )
                .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
        }
    }
}
// MARK: - Image Grid
struct ProfileImageGrid: View {
    let posts: [ProfilePost]
    let columns = Array(repeating: GridItem(.flexible(), spacing: 1), count: 3)
    @State private var selectedPost: ProfilePost?
    var body: some View {
        LazyVGrid(columns: columns, spacing: 1) {
            ForEach(posts) { post in
                ProfileImageCell(post: post) {
                    selectedPost = post
                }
            }
        }
        .padding(.horizontal, 1)
        #if os(iOS)
        .fullScreenCover(item: $selectedPost) { post in
            FullScreenPostViewer(post: post)
        }
        #else
        .sheet(item: $selectedPost) { post in
            FullScreenPostViewer(post: post)
        }
        #endif
    }
}
struct ProfileImageCell: View {
    let post: ProfilePost
    let onTap: () -> Void
    @State private var isLoaded = false
    @State private var scale: CGFloat = 0.8
    var body: some View {
        GeometryReader { geometry in
            if let firstImage = post.imageURLs.first, let url = URL(string: firstImage) {
                AsyncImage(url: url) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: geometry.size.width, height: geometry.size.width)
                        .clipped()
                        .scaleEffect(scale)
                        .onAppear {
                            withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {
                                isLoaded = true
                                scale = 1.0
                            }
                        }
                } placeholder: {
                    OlasLoadingView()
                        .frame(height: 200)
                }
                .onTapGesture {
                    OlasDesign.Haptic.selection()
                    onTap()
                }
                // Multiple images indicator
                if post.imageURLs.count > 1 {
                    VStack {
                        HStack {
                            Spacer()
                            Image(systemName: "square.stack")
                                .font(.caption)
                                .foregroundColor(.white)
                                .padding(4)
                                .background(Color.black.opacity(0.6))
                                .clipShape(RoundedRectangle(cornerRadius: 4))
                                .padding(4)
                        }
                        Spacer()
                    }
                }
            }
        }
        .aspectRatio(1, contentMode: .fit)
    }
}
// MARK: - Other Views
struct ProfileRepliesView: View {
    let replies: [NDKEvent]
    var body: some View {
        LazyVStack(spacing: 1) {
            ForEach(replies, id: \.id) { reply in
                ReplyCell(event: reply)
            }
        }
        .padding(.horizontal, OlasDesign.Spacing.md)
    }
}
struct ProfileZapsView: View {
    let zaps: [ZapInfo]
    var body: some View {
        LazyVStack(spacing: OlasDesign.Spacing.md) {
            ForEach(zaps) { zap in
                ZapCell(zap: zap)
            }
        }
        .padding(.horizontal, OlasDesign.Spacing.md)
    }
}
// MARK: - View Model
@MainActor
class ProfileViewModel: ObservableObject {
    @Published var profile: NDKUserProfile?
    @Published var imagePosts: [ProfilePost] = []
    @Published var replies: [NDKEvent] = []
    @Published var zaps: [ZapInfo] = []
    @Published var isFollowing = false
    @Published var followersCount = 0
    @Published var followingCount = 0
    @Published var postsCount = 0
    private var pubkey: String = ""
    private var ndk: NDK?
    func startObserving(pubkey: String, ndk: NDK) {
        self.pubkey = pubkey
        self.ndk = ndk
        // Observe profile updates
        Task {
            guard let profileManager = ndk.profileManager else { return }
            for await profile in await profileManager.observe(for: pubkey, maxAge: 3600) {
                if let profile = profile {
                    await MainActor.run {
                        self.profile = profile
                    }
                }
            }
        }
        // Observe picture posts (NIP-68)
        Task {
            let filter = NDKFilter(
                authors: [pubkey],
                kinds: [EventKind.image]
            )
            let dataSource = ndk.observe(filter: filter, cachePolicy: .cacheWithNetwork)
            for await event in dataSource.events {
                // Extract image URLs using NDKEvent's built-in imeta support
                let imageURLs = event.imageURLs
                if !imageURLs.isEmpty {
                    let post = ProfilePost(event: event, imageURLs: imageURLs)
                    await MainActor.run {
                        imagePosts.insert(post, at: 0)
                        postsCount = imagePosts.count
                    }
                }
            }
        }
        // Check following status
        checkFollowingStatus()
        // Load follower counts
        loadFollowerCounts()
        // Load replies (NIP-22 comments)
        loadReplies()
    }
    func toggleFollow() {
        guard let ndk = ndk else { return }
        Task {
            do {
                if isFollowing {
                    // Unfollow
                    let user = NDKUser(pubkey: pubkey)
                    try await ndk.unfollow(user)
                } else {
                    // Follow
                    let user = NDKUser(pubkey: pubkey)
                    try await ndk.follow(user)
                }
                await MainActor.run {
                    isFollowing.toggle()
                    if isFollowing {
                        followersCount += 1
                    } else {
                        followersCount = max(0, followersCount - 1)
                    }
                }
            } catch {
                print("Failed to toggle follow: \(error)")
            }
        }
    }
    private func checkFollowingStatus() {
        guard let ndk = ndk else { return }
        Task {
            do {
                let contactList = try await ndk.fetchContactList()
                await MainActor.run {
                    isFollowing = contactList?.tags.contains(where: { tag in
                        tag.count >= 2 && tag[0] == "p" && tag[1] == pubkey
                    }) ?? false
                }
            } catch {
                print("Failed to fetch contact list: \(error)")
            }
        }
    }
    private func loadFollowerCounts() {
        guard let ndk = ndk else { return }
        Task {
            // Load following count from contact list (kind 3)
            let contactFilter = NDKFilter(
                authors: [pubkey],
                kinds: [3],  // Contact list
                limit: 1
            )
            let dataSource = ndk.observe(filter: contactFilter, cachePolicy: .cacheWithNetwork)
            let events = await dataSource.collect(timeout: 3.0)
            if let contactList = events.first {
                // Count 'p' tags in contact list
                let followingCount = contactList.tags.filter { $0.count >= 2 && $0[0] == "p" }.count
                await MainActor.run {
                    self.followingCount = followingCount
                }
            } else {
                await MainActor.run {
                    self.followingCount = 0
                }
            }
            // Follower count is complex and resource-intensive to calculate
            // Set to -1 to indicate N/A in the UI
            await MainActor.run {
                followersCount = -1  // Will display as N/A
            }
        }
    }
    private func loadReplies() {
        guard let ndk = ndk else { return }
        // This section would need proper implementation:
        // - First load all posts by this user
        // - Then for each post, load comments with proper NIP-22 tags
        // - The current implementation that loads ALL comments by the user is conceptually wrong
        // For now, we'll just clear the replies to avoid the incorrect behavior
        Task {
            await MainActor.run {
                replies.removeAll()
            }
        }
    }
}
// MARK: - Models
struct ProfilePost: Identifiable {
    let id: String
    let event: NDKEvent
    let imageURLs: [String]
    init(event: NDKEvent, imageURLs: [String]) {
        self.id = event.id
        self.event = event
        self.imageURLs = imageURLs
    }
}
struct ZapInfo: Identifiable {
    let id = UUID()
    let amount: Int
    let from: String
    let message: String?
    let timestamp: Date
}
struct ReplyCell: View {
    let event: NDKEvent
    var body: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            OlasRichText(content: event.content, tags: event.tags)
            Text(Date(timeIntervalSince1970: Double(event.createdAt)).formatted(.relative(presentation: .named)))
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
        .padding(OlasDesign.Spacing.md)
        .background(OlasDesign.Colors.surface)
        .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md))
    }
}
struct ZapCell: View {
    let zap: ZapInfo
    var body: some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            Image(systemName: "bolt.fill")
                .font(.title2)
                .foregroundColor(.orange)
            VStack(alignment: .leading, spacing: 4) {
                Text("\(zap.amount) sats")
                    .font(OlasDesign.Typography.bodyMedium)
                    .foregroundColor(OlasDesign.Colors.text)
                if let message = zap.message {
                    Text(message)
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        .lineLimit(2)
                }
            }
            Spacer()
            Text(zap.timestamp.formatted(.relative(presentation: .named)))
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
        .padding(OlasDesign.Spacing.md)
        .background(OlasDesign.Colors.surface)
        .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md))
    }
}
struct FullScreenPostViewer: View {
    let post: ProfilePost
    @Environment(\.dismiss) var dismiss
    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()
            OlasMultiImageView(imageURLs: post.imageURLs)
            VStack {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.white)
                            .padding()
                            .background(Color.black.opacity(0.5))
                            .clipShape(Circle())
                    }
                    Spacer()
                }
                .padding()
                Spacer()
            }
        }
    }
}
// MARK: - Preference Key
struct ScrollOffsetPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}
</file>

<file path="Olas/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>NSCameraUsageDescription</key>
	<string>Olas needs access to your camera to capture photos</string>
	<key>NSPhotoLibraryAddUsageDescription</key>
	<string>Olas needs permission to save photos to your library</string>
	<key>NSPhotoLibraryUsageDescription</key>
	<string>Olas needs access to your photo library to select images</string>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
	</dict>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>arm64</string>
	</array>
</dict>
</plist>
</file>

<file path="Olas/LaunchScreen.storyboard">
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="21507" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <device id="retina6_1" orientation="portrait" appearance="light"/>
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="21505"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="414" height="896"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <label opaque="NO" clipsSubviews="YES" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="Olas" textAlignment="center" lineBreakMode="middleTruncation" baselineAdjustment="alignBaselines" minimumFontSize="9" translatesAutoresizingMaskIntoConstraints="NO" id="GJd-Yh-RWb">
                                <rect key="frame" x="0.0" y="278" width="414" height="43"/>
                                <fontDescription key="fontDescription" type="boldSystem" pointSize="36"/>
                                <color key="textColor" white="1" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
                                <nil key="highlightedColor"/>
                            </label>
                        </subviews>
                        <viewLayoutGuide key="safeArea" id="Bcu-3y-fUS"/>
                        <color key="backgroundColor" white="0.0" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
                        <constraints>
                            <constraint firstItem="Bcu-3y-fUS" firstAttribute="centerX" secondItem="GJd-Yh-RWb" secondAttribute="centerX" id="Q3B-4B-g5h"/>
                            <constraint firstItem="GJd-Yh-RWb" firstAttribute="leading" secondItem="Bcu-3y-fUS" secondAttribute="leading" symbolic="YES" id="SfN-ll-jLj"/>
                            <constraint firstAttribute="bottom" secondItem="GJd-Yh-RWb" secondAttribute="bottom" constant="575" id="Y44-ml-fuU"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
</document>
</file>

<file path="Olas.xcodeproj/project.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
</file>

<file path="Sources/Olas/App/OlasApp.swift">
import SwiftUI
import NDKSwift
@main
struct OlasApp: App {
    @StateObject private var appState = AppState()
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(appState)
                .preferredColorScheme(.dark)
        }
    }
}
@MainActor
class AppState: ObservableObject {
    @Published var ndk: NDK?
    @Published var currentUser: NDKUser?
    @Published var isAuthenticated = false
    init() {
        setupNDK()
    }
    private func setupNDK() {
        Task {
            do {
                ndk = NDK()
                // Add default relays
                try await ndk?.addRelay("wss://relay.damus.io")
                try await ndk?.addRelay("wss://relay.nostr.band")
                try await ndk?.addRelay("wss://nos.lol")
                try await ndk?.connect()
            } catch {
                print("Failed to setup NDK: \(error)")
            }
        }
    }
}
</file>

<file path="Sources/Olas/Models/DesignSystem.swift">
import SwiftUI
import Foundation
// MARK: - Design System
enum OlasDesign {
    // MARK: - Time-Based Gradient System
    static var currentGradient: LinearGradient {
        let hour = Calendar.current.component(.hour, from: Date())
        switch hour {
        case 5...7: // Dawn
            return LinearGradient(
                colors: [Color(hex: "FF6B6B"), Color(hex: "4ECDC4")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        case 8...16: // Day
            return LinearGradient(
                colors: [Color(hex: "667eea"), Color(hex: "764ba2")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        case 17...19: // Dusk
            return LinearGradient(
                colors: [Color(hex: "f093fb"), Color(hex: "f5576c")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        default: // Night
            return LinearGradient(
                colors: [Color(hex: "4facfe"), Color(hex: "00f2fe")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        }
    }
    static var accentGradient: LinearGradient {
        currentGradient
    }
    // MARK: - Colors
    enum Colors {
        static let background = Color.black
        static let surface = Color.white.opacity(0.08) // Glass morphism
        static let text = Color.white
        static let textSecondary = Color.white.opacity(0.7)
        static let textTertiary = Color.white.opacity(0.5)
        static let divider = Color.white.opacity(0.1)
        static let error = Color(hex: "FF6B6B")
        static let success = Color(hex: "4ECDC4")
    }
    // MARK: - Typography
    enum Typography {
        static let largeTitle = Font.system(.largeTitle, design: .rounded, weight: .bold)
        static let title = Font.system(.title, design: .rounded, weight: .semibold)
        static let title2 = Font.system(.title2, design: .rounded, weight: .semibold)
        static let title3 = Font.system(.title3, design: .rounded, weight: .medium)
        static let headline = Font.system(.headline, design: .default, weight: .semibold)
        static let body = Font.custom("Inter", size: 16).weight(.regular)
        static let bodyMedium = Font.custom("Inter", size: 16).weight(.medium)
        static let caption = Font.custom("Inter", size: 14).weight(.regular)
        static let footnote = Font.custom("Inter", size: 13).weight(.regular)
        static let mono = Font.custom("JetBrains Mono", size: 14).weight(.regular)
    }
    // MARK: - Spacing (8pt Grid System)
    enum Spacing {
        static let xxs: CGFloat = 2   // 0.25x
        static let xs: CGFloat = 4    // 0.5x
        static let sm: CGFloat = 8    // 1x (base)
        static let md: CGFloat = 16   // 2x
        static let lg: CGFloat = 24   // 3x
        static let xl: CGFloat = 32   // 4x
        static let xxl: CGFloat = 48  // 6x
        static let xxxl: CGFloat = 64 // 8x
    }
    // MARK: - Animations
    enum Animation {
        static let springResponse: Double = 0.55
        static let springDamping: Double = 0.825
        static let spring = SwiftUI.Animation.spring(response: springResponse, dampingFraction: springDamping)
        static let microDuration: Double = 0.2
        static let macroDuration: Double = 0.35
        static let easeOutBack = SwiftUI.Animation.timingCurve(0.34, 1.56, 0.64, 1, duration: macroDuration)
    }
    // MARK: - Corner Radius
    enum CornerRadius {
        static let xs: CGFloat = 4
        static let sm: CGFloat = 8
        static let md: CGFloat = 12
        static let lg: CGFloat = 16
        static let xl: CGFloat = 20
        static let xxl: CGFloat = 24
        static let full: CGFloat = 9999
    }
    // MARK: - Shadows
    enum Shadow {
        static func small(color: Color = .black) -> SwiftShadow {
            SwiftShadow(color: color.opacity(0.15), radius: 4, x: 0, y: 2)
        }
        static func medium(color: Color = .black) -> SwiftShadow {
            SwiftShadow(color: color.opacity(0.2), radius: 8, x: 0, y: 4)
        }
        static func large(color: Color = .black) -> SwiftShadow {
            SwiftShadow(color: color.opacity(0.25), radius: 16, x: 0, y: 8)
        }
        static func glow(color: Color) -> SwiftShadow {
            SwiftShadow(color: color.opacity(0.6), radius: 20, x: 0, y: 0)
        }
    }
    // MARK: - Haptic Feedback
    enum Haptic {
        #if os(iOS)
        static func impact(_ style: UIImpactFeedbackGenerator.FeedbackStyle) {
            let impactFeedback = UIImpactFeedbackGenerator(style: style)
            impactFeedback.prepare()
            impactFeedback.impactOccurred()
        }
        #else
        static func impact(_ style: Int) {
            // No haptic feedback on macOS
        }
        #endif
        static func selection() {
            #if os(iOS)
            let selectionFeedback = UISelectionFeedbackGenerator()
            selectionFeedback.prepare()
            selectionFeedback.selectionChanged()
            #endif
        }
        #if os(iOS)
        static func notification(_ type: UINotificationFeedbackGenerator.FeedbackType) {
            let notificationFeedback = UINotificationFeedbackGenerator()
            notificationFeedback.prepare()
            notificationFeedback.notificationOccurred(type)
        }
        #else
        static func notification(_ type: Int) {
            // No haptic feedback on macOS
        }
        #endif
    }
}
// MARK: - Shadow Helper
struct SwiftShadow {
    let color: Color
    let radius: CGFloat
    let x: CGFloat
    let y: CGFloat
}
// MARK: - View Extensions
extension View {
    func olasGradient() -> some View {
        self.foregroundStyle(OlasDesign.currentGradient)
    }
    func olasSurface() -> some View {
        self
            .background(OlasDesign.Colors.surface)
            .background(.ultraThinMaterial)
            .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg))
    }
    func olasGlassMorphism() -> some View {
        self
            .background(
                ZStack {
                    OlasDesign.Colors.surface
                    Color.white.opacity(0.05)
                }
            )
            .background(.ultraThinMaterial)
            .overlay(
                RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg)
                    .stroke(OlasDesign.Colors.divider, lineWidth: 1)
            )
            .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.lg))
    }
    func olasShadow(_ shadow: SwiftShadow) -> some View {
        self.shadow(color: shadow.color, radius: shadow.radius, x: shadow.x, y: shadow.y)
    }
    func olasTextShadow() -> some View {
        self.shadow(color: .black.opacity(0.3), radius: 1, x: 0, y: 1)
    }
    func olasSpringAnimation() -> some View {
        self.animation(OlasDesign.Animation.spring, value: UUID())
    }
}
// MARK: - Custom Components
struct OlasButton: View {
    let title: String
    let action: () -> Void
    var style: ButtonStyle = .primary
    var isLoading: Bool = false
    enum ButtonStyle {
        case primary, secondary, ghost
    }
    var body: some View {
        Button(action: {
            #if os(iOS)
            OlasDesign.Haptic.impact(.light)
            #else
            OlasDesign.Haptic.impact(0)
            #endif
            action()
        }) {
            HStack(spacing: OlasDesign.Spacing.sm) {
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .scaleEffect(0.8)
                } else {
                    Text(title)
                        .font(OlasDesign.Typography.bodyMedium)
                }
            }
            .foregroundColor(.white)
            .frame(maxWidth: .infinity)
            .padding(.vertical, OlasDesign.Spacing.md)
            .background(backgroundView)
            .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md))
            .olasShadow(OlasDesign.Shadow.medium())
        }
        .disabled(isLoading)
        .scaleEffect(isLoading ? 0.95 : 1.0)
        .animation(OlasDesign.Animation.spring, value: isLoading)
    }
    @ViewBuilder
    private var backgroundView: some View {
        switch style {
        case .primary:
            OlasDesign.currentGradient
        case .secondary:
            OlasDesign.Colors.surface
                .background(.ultraThinMaterial)
        case .ghost:
            Color.clear
                .overlay(
                    RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                        .stroke(OlasDesign.Colors.divider, lineWidth: 1)
                )
        }
    }
}
struct OlasTextField: View {
    @Binding var text: String
    let placeholder: String
    var isSecure: Bool = false
    var icon: String? = nil
    @FocusState private var isFocused: Bool
    var body: some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            if let icon = icon {
                Image(systemName: icon)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
                    .font(.system(size: 18))
            }
            Group {
                if isSecure {
                    SecureField(placeholder, text: $text)
                } else {
                    TextField(placeholder, text: $text)
                }
            }
            .font(OlasDesign.Typography.body)
            .foregroundColor(OlasDesign.Colors.text)
            .focused($isFocused)
        }
        .padding(OlasDesign.Spacing.md)
        .background(OlasDesign.Colors.surface)
        .background(.ultraThinMaterial)
        .overlay(
            RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md)
                .stroke(
                    isFocused ? OlasDesign.Colors.text.opacity(0.5) : OlasDesign.Colors.divider,
                    lineWidth: isFocused ? 2 : 1
                )
        )
        .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.md))
        .animation(OlasDesign.Animation.spring, value: isFocused)
        .onChange(of: isFocused) { _, focused in
            if focused {
                OlasDesign.Haptic.selection()
            }
        }
    }
}
// MARK: - Loading States
struct OlasShimmer: View {
    @State private var isAnimating = false
    var body: some View {
        LinearGradient(
            colors: [
                OlasDesign.Colors.surface,
                OlasDesign.Colors.surface.opacity(0.6),
                OlasDesign.Colors.surface
            ],
            startPoint: .leading,
            endPoint: .trailing
        )
        .offset(x: isAnimating ? 200 : -200)
        .animation(
            .linear(duration: 1.5)
            .repeatForever(autoreverses: false),
            value: isAnimating
        )
        .onAppear {
            isAnimating = true
        }
    }
}
struct OlasSkeletonView: View {
    let height: CGFloat
    var body: some View {
        RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm)
            .fill(OlasDesign.Colors.surface)
            .overlay(OlasShimmer())
            .frame(height: height)
            .clipShape(RoundedRectangle(cornerRadius: OlasDesign.CornerRadius.sm))
    }
}
// MARK: - Avatar Component
struct OlasAvatar: View {
    let url: String?
    let size: CGFloat
    let pubkey: String?
    var body: some View {
        Group {
            if let url = url, let imageURL = URL(string: url) {
                AsyncImage(url: imageURL) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                    case .failure(_), .empty:
                        placeholderView
                    @unknown default:
                        placeholderView
                    }
                }
            } else {
                placeholderView
            }
        }
        .frame(width: size, height: size)
        .clipShape(Circle())
        .overlay(
            Circle()
                .stroke(OlasDesign.Colors.divider, lineWidth: 1)
        )
    }
    private var placeholderView: some View {
        ZStack {
            OlasDesign.currentGradient
            if let pubkey = pubkey {
                Text(String(pubkey.prefix(2)).uppercased())
                    .font(OlasDesign.Typography.headline)
                    .foregroundColor(.white)
            } else {
                Image(systemName: "person.fill")
                    .font(.system(size: size * 0.4))
                    .foregroundColor(.white.opacity(0.8))
            }
        }
    }
}
</file>

<file path="Sources/Olas/Models/ImageMetadata.swift">
import Foundation
struct ImageMetadata: Codable {
    let url: URL
    let width: Int?
    let height: Int?
    let blurhash: String?
    let alt: String?
    let mimeType: String?
    init(url: URL, width: Int? = nil, height: Int? = nil, blurhash: String? = nil, alt: String? = nil, mimeType: String? = nil) {
        self.url = url
        self.width = width
        self.height = height
        self.blurhash = blurhash
        self.alt = alt
        self.mimeType = mimeType
    }
}
</file>

<file path="Sources/Olas/Views/Authentication/AuthenticationView.swift">
import SwiftUI
import NDKSwift
struct AuthenticationView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var showCreateAccount = false
    @State private var privateKey = ""
    var body: some View {
        NavigationStack {
            VStack(spacing: 32) {
                // Logo/Header
                VStack(spacing: 8) {
                    Text("Olas")
                        .font(.system(size: 72, weight: .bold, design: .rounded))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [Color(hex: "667eea"), Color(hex: "764ba2")],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                    Text("Picture-First Nostr Experience")
                        .font(.title3)
                        .foregroundColor(.secondary)
                }
                .padding(.top, 60)
                Spacer()
                // Login Section
                VStack(spacing: 16) {
                    TextField("Enter your private key (nsec or hex)", text: $privateKey)
                        .textFieldStyle(.roundedBorder)
                        #if os(iOS)
                        .autocapitalization(.none)
                        #endif
                        .autocorrectionDisabled()
                    Button(action: login) {
                        Text("Login")
                            .font(.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(
                                LinearGradient(
                                    colors: [Color(hex: "667eea"), Color(hex: "764ba2")],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .cornerRadius(12)
                    }
                    .disabled(privateKey.isEmpty)
                }
                .padding(.horizontal, 32)
                // Create Account
                Button(action: { showCreateAccount = true }) {
                    Text("Create New Account")
                        .font(.headline)
                        .foregroundStyle(
                            LinearGradient(
                                colors: [Color(hex: "667eea"), Color(hex: "764ba2")],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                }
                .padding(.bottom, 60)
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .background(Color.black)
            .sheet(isPresented: $showCreateAccount) {
                CreateAccountView()
            }
        }
    }
    private func login() {
        Task {
            do {
                let signer = try NDKPrivateKeySigner(privateKey: privateKey)
                nostrManager.ndk?.signer = signer
                let user = try NDKUser(pubkey: signer.publicKey(format: .hex))
                appState.currentUser = user
                appState.isAuthenticated = true
            } catch {
                print("Login failed: \(error)")
            }
        }
    }
}
extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3:
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6:
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8:
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue:  Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}
</file>

<file path="Sources/Olas/Views/Authentication/CreateAccountView.swift">
import SwiftUI
import NDKSwift
struct CreateAccountView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var mnemonic: [String] = []
    @State private var privateKey = ""
    @State private var showConfirmation = false
    var body: some View {
        NavigationStack {
            VStack(spacing: 32) {
                Text("Create New Account")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                if mnemonic.isEmpty {
                    Button("Generate Keys") {
                        generateKeys()
                    }
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding()
                    .background(
                        LinearGradient(
                            colors: [Color(hex: "667eea"), Color(hex: "764ba2")],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .cornerRadius(12)
                } else {
                    VStack(spacing: 24) {
                        Text("Your Recovery Phrase")
                            .font(.title2)
                            .fontWeight(.semibold)
                        LazyVGrid(columns: [GridItem(.adaptive(minimum: 100))], spacing: 12) {
                            ForEach(Array(mnemonic.enumerated()), id: \.offset) { index, word in
                                HStack {
                                    Text("\(index + 1).")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                    Text(word)
                                        .font(.system(.body, design: .monospaced))
                                }
                                .padding(.horizontal, 12)
                                .padding(.vertical, 8)
                                .background(Color.gray.opacity(0.1))
                                .cornerRadius(8)
                            }
                        }
                        Text(" Write down these words in order. This is the only way to recover your account.")
                            .font(.caption)
                            .foregroundColor(.orange)
                            .multilineTextAlignment(.center)
                        Button("I've Saved My Recovery Phrase") {
                            showConfirmation = true
                        }
                        .font(.headline)
                        .foregroundColor(.white)
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.green)
                        .cornerRadius(12)
                    }
                    .padding(.horizontal)
                }
            }
            .padding()
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
            .alert("Confirm Backup", isPresented: $showConfirmation) {
                Button("Yes, I've saved it") {
                    completeAccountCreation()
                }
                Button("No, let me save it", role: .cancel) {}
            } message: {
                Text("Have you securely saved your recovery phrase? You won't be able to see it again.")
            }
        }
    }
    private func generateKeys() {
        // In a real app, generate mnemonic properly
        // This is just a placeholder
        mnemonic = ["example", "words", "would", "be", "generated", "here", 
                   "using", "proper", "bip39", "implementation", "for", "security"]
        privateKey = "generated_private_key_here"
    }
    private func completeAccountCreation() {
        Task {
            do {
                let signer = try NDKPrivateKeySigner(privateKey: privateKey)
                nostrManager.ndk?.signer = signer
                let user = try NDKUser(pubkey: signer.publicKey(format: .hex))
                appState.currentUser = user
                appState.isAuthenticated = true
                dismiss()
            } catch {
                print("Account creation failed: \(error)")
            }
        }
    }
}
</file>

<file path="Sources/Olas/Views/Components/OlasMultiImageView.swift">
import SwiftUI
// MARK: - Multi-Image Layout Component
struct OlasMultiImageView: View {
    let imageURLs: [String]
    @State private var loadedImages: [String: Image] = [:]
    @State private var failedImages: Set<String> = []
    var body: some View {
        GeometryReader { geometry in
            let width = geometry.size.width
            switch imageURLs.count {
            case 1:
                singleImageLayout(width: width)
            case 2:
                doubleImageLayout(width: width)
            case 3:
                tripleImageLayout(width: width)
            case 4...:
                quadImageLayout(width: width)
            default:
                EmptyView()
            }
        }
        .aspectRatio(4/5, contentMode: .fit)
        .background(OlasDesign.Colors.background)
    }
    // MARK: - Layout Components
    @ViewBuilder
    private func singleImageLayout(width: CGFloat) -> some View {
        imageView(for: imageURLs[0], aspectRatio: 4/5)
    }
    @ViewBuilder
    private func doubleImageLayout(width: CGFloat) -> some View {
        HStack(spacing: 1) {
            imageView(for: imageURLs[0], aspectRatio: 8/9)
            imageView(for: imageURLs[1], aspectRatio: 8/9)
        }
    }
    @ViewBuilder
    private func tripleImageLayout(width: CGFloat) -> some View {
        HStack(spacing: 1) {
            // Hero image on left (8:9)
            imageView(for: imageURLs[0], aspectRatio: 8/9)
                .frame(width: width * 0.6)
            // Two stacked images on right (1:1)
            VStack(spacing: 1) {
                imageView(for: imageURLs[1], aspectRatio: 1)
                imageView(for: imageURLs[2], aspectRatio: 1)
            }
            .frame(width: width * 0.4 - 1)
        }
    }
    @ViewBuilder
    private func quadImageLayout(width: CGFloat) -> some View {
        VStack(spacing: 1) {
            HStack(spacing: 1) {
                imageView(for: imageURLs[0], aspectRatio: 1)
                imageView(for: imageURLs[1], aspectRatio: 1)
            }
            HStack(spacing: 1) {
                imageView(for: imageURLs[2], aspectRatio: 1)
                if imageURLs.count > 3 {
                    ZStack {
                        imageView(for: imageURLs[3], aspectRatio: 1)
                        // Show +N overlay for additional images
                        if imageURLs.count > 4 {
                            Rectangle()
                                .fill(Color.black.opacity(0.6))
                                .overlay(
                                    Text("+\(imageURLs.count - 4)")
                                        .font(OlasDesign.Typography.title)
                                        .foregroundColor(.white)
                                        .olasTextShadow()
                                )
                        }
                    }
                } else {
                    imageView(for: imageURLs[2], aspectRatio: 1)
                }
            }
        }
    }
    // MARK: - Image View Builder
    @ViewBuilder
    private func imageView(for urlString: String, aspectRatio: CGFloat) -> some View {
        if let image = loadedImages[urlString] {
            // Already loaded
            image
                .resizable()
                .aspectRatio(aspectRatio, contentMode: .fill)
                .clipped()
        } else if failedImages.contains(urlString) {
            // Failed to load
            Rectangle()
                .fill(OlasDesign.Colors.surface)
                .aspectRatio(aspectRatio, contentMode: .fill)
                .overlay(
                    Image(systemName: "photo")
                        .font(.system(size: 30))
                        .foregroundColor(OlasDesign.Colors.textTertiary)
                )
        } else {
            // Loading
            AsyncImage(url: URL(string: urlString)) { phase in
                switch phase {
                case .success(let image):
                    image
                        .resizable()
                        .aspectRatio(aspectRatio, contentMode: .fill)
                        .clipped()
                        .onAppear {
                            loadedImages[urlString] = image
                        }
                case .failure(_):
                    Rectangle()
                        .fill(OlasDesign.Colors.surface)
                        .aspectRatio(aspectRatio, contentMode: .fill)
                        .overlay(
                            Image(systemName: "photo")
                                .font(.system(size: 30))
                                .foregroundColor(OlasDesign.Colors.textTertiary)
                        )
                        .onAppear {
                            failedImages.insert(urlString)
                        }
                case .empty:
                    Rectangle()
                        .fill(OlasDesign.Colors.surface)
                        .aspectRatio(aspectRatio, contentMode: .fill)
                        .overlay(
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                .scaleEffect(0.8)
                        )
                @unknown default:
                    EmptyView()
                }
            }
        }
    }
}
// MARK: - Image Interaction Overlay
struct OlasImageInteractionOverlay: View {
    let imageURLs: [String]
    @State private var currentIndex: Int = 0
    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @State private var lastOffset: CGSize = .zero
    @Binding var isPresented: Bool
    @State private var dragOffset: CGSize = .zero
    @State private var opacity: Double = 1.0
    var body: some View {
        ZStack {
            backgroundView
            imageViewer
            closeButton
        }
    }
    @ViewBuilder
    private var backgroundView: some View {
        Color.black
            .opacity(opacity)
            .ignoresSafeArea()
            .onTapGesture {
                withAnimation(OlasDesign.Animation.spring) {
                    isPresented = false
                }
            }
    }
    @ViewBuilder
    private var imageViewer: some View {
        TabView(selection: $currentIndex) {
            ForEach(imageURLs.indices, id: \.self) { index in
                imageView(at: index)
                    .tag(index)
            }
        }
        #if os(iOS)
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: imageURLs.count > 1 ? .always : .never))
        #endif
        .offset(dragOffset)
    }
    @ViewBuilder
    private func imageView(at index: Int) -> some View {
        AsyncImage(url: URL(string: imageURLs[index])) { phase in
            switch phase {
            case .success(let image):
                zoomableImage(image)
            case .failure(_):
                failureView
            case .empty:
                loadingView
            @unknown default:
                EmptyView()
            }
        }
    }
    @ViewBuilder
    private func zoomableImage(_ image: Image) -> some View {
        image
            .resizable()
            .aspectRatio(contentMode: .fit)
            .scaleEffect(scale)
            .offset(offset)
            .gesture(zoomGesture)
            .onTapGesture(count: 2) {
                toggleZoom()
            }
    }
    private var zoomGesture: some Gesture {
        MagnificationGesture()
            .onChanged { value in
                scale = lastScale * value
            }
            .onEnded { value in
                handleZoomEnd()
            }
            .simultaneously(with: dragGesture)
    }
    private var dragGesture: some Gesture {
        DragGesture()
            .onChanged { value in
                handleDrag(value: value)
            }
            .onEnded { value in
                handleDragEnd(value: value)
            }
    }
    private func handleZoomEnd() {
        lastScale = scale
        withAnimation(OlasDesign.Animation.spring) {
            if scale < 1 {
                scale = 1
                lastScale = 1
                offset = .zero
                lastOffset = .zero
            } else if scale > 4 {
                scale = 4
                lastScale = 4
            }
        }
    }
    private func handleDrag(value: DragGesture.Value) {
        if scale > 1 {
            offset = CGSize(
                width: lastOffset.width + value.translation.width,
                height: lastOffset.height + value.translation.height
            )
        } else {
            dragOffset = value.translation
            let progress = abs(value.translation.height) / 200
            opacity = 1 - min(progress, 0.5)
        }
    }
    private func handleDragEnd(value: DragGesture.Value) {
        if scale > 1 {
            lastOffset = offset
        } else {
            if abs(value.translation.height) > 100 {
                withAnimation(OlasDesign.Animation.spring) {
                    isPresented = false
                }
            } else {
                withAnimation(OlasDesign.Animation.spring) {
                    dragOffset = .zero
                    opacity = 1
                }
            }
        }
    }
    private func toggleZoom() {
        withAnimation(OlasDesign.Animation.spring) {
            if scale > 1 {
                scale = 1
                lastScale = 1
                offset = .zero
                lastOffset = .zero
            } else {
                scale = 2
                lastScale = 2
            }
        }
        #if os(iOS)
        OlasDesign.Haptic.impact(.light)
        #else
        OlasDesign.Haptic.impact(0)
        #endif
    }
    @ViewBuilder
    private var failureView: some View {
        VStack(spacing: OlasDesign.Spacing.md) {
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 50))
                .foregroundColor(OlasDesign.Colors.textTertiary)
            Text("Failed to load image")
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
    }
    @ViewBuilder
    private var loadingView: some View {
        ProgressView()
            .progressViewStyle(CircularProgressViewStyle(tint: .white))
            .scaleEffect(1.5)
    }
    @ViewBuilder
    private var closeButton: some View {
        VStack {
            HStack {
                Spacer()
                Button(action: {
                    withAnimation(OlasDesign.Animation.spring) {
                        isPresented = false
                    }
                    OlasDesign.Haptic.selection()
                }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title)
                        .foregroundStyle(.white, Color.white.opacity(0.2))
                        .background(Circle().fill(.ultraThinMaterial))
                }
                .padding(OlasDesign.Spacing.lg)
            }
            Spacer()
        }
    }
}
// MARK: - Preview
struct OlasMultiImageView_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            OlasMultiImageView(imageURLs: ["https://example.com/1.jpg"])
                .frame(height: 400)
            OlasMultiImageView(imageURLs: ["https://example.com/1.jpg", "https://example.com/2.jpg"])
                .frame(height: 400)
            OlasMultiImageView(imageURLs: ["https://example.com/1.jpg", "https://example.com/2.jpg", "https://example.com/3.jpg"])
                .frame(height: 400)
            OlasMultiImageView(imageURLs: ["https://example.com/1.jpg", "https://example.com/2.jpg", "https://example.com/3.jpg", "https://example.com/4.jpg", "https://example.com/5.jpg"])
                .frame(height: 400)
        }
        .padding()
        .background(OlasDesign.Colors.background)
    }
}
</file>

<file path="Sources/Olas/Views/Components/OlasRichText.swift">
import SwiftUI
import NDKSwift
// MARK: - Rich Text Component
struct OlasRichText: View {
    let content: String
    let tags: [[String]]
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var parsedComponents: [RichTextComponent] = []
    @State private var profileCache: [String: NDKUserProfile] = [:]
    @State private var loadingProfiles: Set<String> = []
    var body: some View {
        Text(attributedString)
            .font(OlasDesign.Typography.body)
            .foregroundColor(OlasDesign.Colors.text)
            .tint(Color.white)
            .task {
                parseContent()
                await loadProfiles()
            }
            .onChange(of: content) { _, _ in
                parseContent()
                Task {
                    await loadProfiles()
                }
            }
    }
    private var attributedString: AttributedString {
        var result = AttributedString()
        for component in parsedComponents {
            switch component {
            case .text(let text):
                result.append(AttributedString(text))
            case .mention(let pubkey):
                let displayName = profileCache[pubkey]?.displayName ?? profileCache[pubkey]?.name ?? shortPubkey(pubkey)
                var mention = AttributedString("@\(displayName)")
                mention.foregroundColor = .white
                mention.font = OlasDesign.Typography.bodyMedium
                mention.link = URL(string: "olas://profile/\(pubkey)")
                mention.underlineStyle = .single
                #if os(iOS)
                mention.underlineColor = UIColor.white.withAlphaComponent(0.3)
                #else
                mention.underlineColor = NSColor.white.withAlphaComponent(0.3)
                #endif
                result.append(mention)
            case .hashtag(let tag):
                var hashtag = AttributedString("#\(tag)")
                hashtag.foregroundColor = .white
                hashtag.font = OlasDesign.Typography.bodyMedium
                hashtag.link = URL(string: "olas://hashtag/\(tag)")
                hashtag.underlineStyle = .single
                #if os(iOS)
                hashtag.underlineColor = UIColor.white.withAlphaComponent(0.3)
                #else
                hashtag.underlineColor = NSColor.white.withAlphaComponent(0.3)
                #endif
                result.append(hashtag)
            case .link(let url):
                var link = AttributedString(url)
                link.foregroundColor = .white.opacity(0.8)
                link.font = OlasDesign.Typography.body
                link.link = URL(string: url)
                link.underlineStyle = .single
                #if os(iOS)
                link.underlineColor = UIColor.white.withAlphaComponent(0.3)
                #else
                link.underlineColor = NSColor.white.withAlphaComponent(0.3)
                #endif
                result.append(link)
            case .noteReference(let noteId):
                var reference = AttributedString(" Note")
                reference.foregroundColor = .white.opacity(0.8)
                reference.font = OlasDesign.Typography.body
                reference.link = URL(string: "olas://note/\(noteId)")
                reference.underlineStyle = .single
                #if os(iOS)
                reference.underlineColor = UIColor.white.withAlphaComponent(0.3)
                #else
                reference.underlineColor = NSColor.white.withAlphaComponent(0.3)
                #endif
                result.append(reference)
            }
        }
        return result
    }
    private func parseContent() {
        let currentText = content
        // Create a map of replacements with their positions
        var replacements: [(range: Range<String.Index>, component: RichTextComponent)] = []
        // Find all mentions from tags
        for tag in tags {
            if tag.count >= 2 && tag[0] == "p" {
                let pubkey = tag[1]
                let mentionIndex = tag.count > 2 ? Int(tag[2]) : nil
                // Find nostr: mentions
                let nostrPattern = "nostr:npub1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}"
                if let regex = try? NSRegularExpression(pattern: nostrPattern) {
                    let matches = regex.matches(in: currentText, range: NSRange(currentText.startIndex..., in: currentText))
                    for match in matches {
                        if let range = Range(match.range, in: currentText) {
                            let npubFull = String(currentText[range])
                            let npub = npubFull.replacingOccurrences(of: "nostr:", with: "")
                            if let decoded = try? Bech32.decode(npub) {
                                let decodedPubkey = Data(decoded.data).hexString
                                if decodedPubkey == pubkey {
                                    replacements.append((range, .mention(pubkey)))
                                }
                            }
                        }
                    }
                }
                // Find #[index] mentions
                if let index = mentionIndex {
                    let indexPattern = "#\\[\(index)\\]"
                    if let regex = try? NSRegularExpression(pattern: indexPattern) {
                        let matches = regex.matches(in: currentText, range: NSRange(currentText.startIndex..., in: currentText))
                        for match in matches {
                            if let range = Range(match.range, in: currentText) {
                                replacements.append((range, .mention(pubkey)))
                            }
                        }
                    }
                }
            }
        }
        // Find hashtags
        let hashtagPattern = "#[a-zA-Z0-9_]+"
        if let regex = try? NSRegularExpression(pattern: hashtagPattern) {
            let matches = regex.matches(in: currentText, range: NSRange(currentText.startIndex..., in: currentText))
            for match in matches {
                if let range = Range(match.range, in: currentText) {
                    let hashtag = String(currentText[range]).dropFirst() // Remove #
                    replacements.append((range, .hashtag(String(hashtag))))
                }
            }
        }
        // Find URLs
        let urlPattern = "https?://[^\\s]+"
        if let regex = try? NSRegularExpression(pattern: urlPattern) {
            let matches = regex.matches(in: currentText, range: NSRange(currentText.startIndex..., in: currentText))
            for match in matches {
                if let range = Range(match.range, in: currentText) {
                    let url = String(currentText[range])
                    replacements.append((range, .link(url)))
                }
            }
        }
        // Find note references
        let notePattern = "nostr:note1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}"
        if let regex = try? NSRegularExpression(pattern: notePattern) {
            let matches = regex.matches(in: currentText, range: NSRange(currentText.startIndex..., in: currentText))
            for match in matches {
                if let range = Range(match.range, in: currentText) {
                    let noteFull = String(currentText[range])
                    let note = noteFull.replacingOccurrences(of: "nostr:", with: "")
                    if let decoded = try? Bech32.decode(note) {
                        let noteId = Data(decoded.data).hexString
                        replacements.append((range, .noteReference(noteId)))
                    }
                }
            }
        }
        // Sort replacements by position (reverse order for replacement)
        replacements.sort { $0.range.lowerBound > $1.range.lowerBound }
        // Build components
        var workingText = currentText
        var finalComponents: [RichTextComponent] = []
        for replacement in replacements {
            // Add text after this replacement
            let afterText = String(workingText[replacement.range.upperBound...])
            if !afterText.isEmpty {
                finalComponents.insert(.text(afterText), at: 0)
            }
            // Add the replacement component
            finalComponents.insert(replacement.component, at: 0)
            // Update working text
            workingText = String(workingText[..<replacement.range.lowerBound])
        }
        // Add any remaining text
        if !workingText.isEmpty {
            finalComponents.insert(.text(workingText), at: 0)
        }
        parsedComponents = finalComponents
    }
    private func loadProfiles() async {
        guard let profileManager = nostrManager.ndk?.profileManager else { return }
        // Find all unique pubkeys that need loading
        let pubkeysToLoad = parsedComponents.compactMap { component -> String? in
            if case .mention(let pubkey) = component,
               profileCache[pubkey] == nil,
               !loadingProfiles.contains(pubkey) {
                return pubkey
            }
            return nil
        }
        // Mark as loading
        await MainActor.run {
            pubkeysToLoad.forEach { loadingProfiles.insert($0) }
        }
        // Load profiles
        await withTaskGroup(of: (String, NDKUserProfile?).self) { group in
            for pubkey in pubkeysToLoad {
                group.addTask {
                    // Use observe to get reactive updates
                    var profile: NDKUserProfile?
                    for await p in await profileManager.observe(for: pubkey, maxAge: 3600) {
                        profile = p
                        break // Just get the first one for now
                    }
                    return (pubkey, profile)
                }
            }
            // Collect results
            for await (pubkey, profile) in group {
                await MainActor.run {
                    if let profile = profile {
                        profileCache[pubkey] = profile
                    }
                    loadingProfiles.remove(pubkey)
                }
            }
        }
    }
    private func shortPubkey(_ pubkey: String) -> String {
        if pubkey.count > 8 {
            return "\(pubkey.prefix(4))...\(pubkey.suffix(4))"
        }
        return pubkey
    }
}
// MARK: - Rich Text Component Types
private enum RichTextComponent: Hashable {
    case text(String)
    case mention(String) // pubkey
    case hashtag(String)
    case link(String)
    case noteReference(String) // note id
}
// MARK: - Preview Helper
struct OlasRichText_Previews: PreviewProvider {
    static var previews: some View {
        VStack(alignment: .leading, spacing: 20) {
            OlasRichText(
                content: "Hello nostr:npub1234567890abcdef! Check out #nostr and visit https://nostr.com",
                tags: [["p", "1234567890abcdef"]]
            )
            OlasRichText(
                content: "Reply to #[0] about #photography with note reference nostr:note1234567890abcdef",
                tags: [["p", "abcdef1234567890", "0"]]
            )
        }
        .padding()
        .background(OlasDesign.Colors.background)
        .environmentObject(AppState())
    }
}
</file>

<file path="Sources/Olas/Views/Create/CreatePostView.swift">
import SwiftUI
import PhotosUI
struct CreatePostView: View {
    @State private var selectedItems: [PhotosPickerItem] = []
    @State private var selectedImages: [UIImage] = []
    @State private var caption = ""
    @State private var showCamera = false
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Photo picker
                if selectedImages.isEmpty {
                    VStack(spacing: 24) {
                        PhotosPicker(selection: $selectedItems,
                                   maxSelectionCount: 4,
                                   matching: .images) {
                            VStack(spacing: 16) {
                                Image(systemName: "photo.on.rectangle.angled")
                                    .font(.system(size: 60))
                                    .foregroundColor(.secondary)
                                Text("Select Photos")
                                    .font(.headline)
                            }
                            .frame(maxWidth: .infinity, minHeight: 300)
                            .background(Color.gray.opacity(0.1))
                            .cornerRadius(12)
                        }
                        Button(action: { showCamera = true }) {
                            Label("Take Photo", systemImage: "camera")
                                .font(.headline)
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(Color(hex: "667eea"))
                                .foregroundColor(.white)
                                .cornerRadius(12)
                        }
                    }
                    .padding()
                } else {
                    // Selected images preview
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 12) {
                            ForEach(selectedImages, id: \.self) { image in
                                Image(uiImage: image)
                                    .resizable()
                                    .scaledToFill()
                                    .frame(width: 200, height: 200)
                                    .clipped()
                                    .cornerRadius(12)
                            }
                        }
                        .padding()
                    }
                    .frame(height: 220)
                    // Caption input
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Caption")
                            .font(.headline)
                        TextEditor(text: $caption)
                            .frame(minHeight: 100)
                            .padding(8)
                            .background(Color.gray.opacity(0.1))
                            .cornerRadius(8)
                    }
                    .padding()
                    Spacer()
                    // Post button
                    Button(action: createPost) {
                        Text("Post")
                            .font(.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(
                                LinearGradient(
                                    colors: [Color(hex: "667eea"), Color(hex: "764ba2")],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .cornerRadius(12)
                    }
                    .padding()
                }
            }
            .navigationTitle("Create Post")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                if !selectedImages.isEmpty {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("Clear") {
                            selectedImages = []
                            selectedItems = []
                            caption = ""
                        }
                    }
                }
            }
            .onChange(of: selectedItems) { oldValue, newValue in
                Task {
                    selectedImages = []
                    for item in newValue {
                        if let data = try? await item.loadTransferable(type: Data.self),
                           let image = UIImage(data: data) {
                            selectedImages.append(image)
                        }
                    }
                }
            }
        }
    }
    private func createPost() {
        // Implement post creation logic
        print("Creating post with \(selectedImages.count) images")
    }
}
</file>

<file path="Sources/Olas/Views/Main/MainTabView.swift">
import SwiftUI
struct MainTabView: View {
    @State private var selectedTab = 0
    var body: some View {
        TabView(selection: $selectedTab) {
            FeedView()
                .tabItem {
                    Label("Feed", systemImage: "photo.stack")
                }
                .tag(0)
            ExploreView()
                .tabItem {
                    Label("Explore", systemImage: "magnifyingglass")
                }
                .tag(1)
            CreatePostView()
                .tabItem {
                    Label("Create", systemImage: "plus.square")
                }
                .tag(2)
            ProfileView()
                .tabItem {
                    Label("Profile", systemImage: "person.circle")
                }
                .tag(3)
            SettingsView()
                .tabItem {
                    Label("Settings", systemImage: "gear")
                }
                .tag(4)
        }
        .tint(Color(hex: "667eea"))
    }
}
</file>

<file path="Sources/Olas/Views/Profile/ProfileView.swift">
import SwiftUI
import NDKSwift
struct ProfileView: View {
    @EnvironmentObject var appState: AppState
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 0) {
                    // Profile header
                    VStack(spacing: 16) {
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: [Color(hex: "667eea"), Color(hex: "764ba2")],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 100, height: 100)
                            .overlay(
                                Text(appState.currentUser?.pubkey.prefix(2).uppercased() ?? "?")
                                    .font(.largeTitle)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            )
                        VStack(spacing: 4) {
                            Text("Anonymous User")
                                .font(.title2)
                                .fontWeight(.bold)
                            Text("@\(appState.currentUser?.pubkey.prefix(8) ?? "unknown")")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                        }
                        // Stats
                        HStack(spacing: 40) {
                            VStack {
                                Text("0")
                                    .font(.title2)
                                    .fontWeight(.semibold)
                                Text("Posts")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            VStack {
                                Text("0")
                                    .font(.title2)
                                    .fontWeight(.semibold)
                                Text("Followers")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            VStack {
                                Text("0")
                                    .font(.title2)
                                    .fontWeight(.semibold)
                                Text("Following")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                        .padding(.vertical)
                        Button(action: {}) {
                            Text("Edit Profile")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 8)
                                .background(Color.gray.opacity(0.2))
                                .cornerRadius(8)
                        }
                    }
                    .padding()
                    Divider()
                    // Posts grid placeholder
                    VStack {
                        Text("Your Posts")
                            .font(.title3)
                            .foregroundColor(.secondary)
                            .padding(.top, 40)
                        Text("Posts will appear here")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .frame(minHeight: 300)
                }
            }
            .navigationTitle("Profile")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
}
</file>

<file path="Sources/Olas/Views/Settings/AccountSettingsView.swift">
import SwiftUI
import NDKSwift
import CryptoKit
struct AccountSettingsView: View {
    @EnvironmentObject var appState: AppState
    @State private var showKeyBackup = false
    @State private var showCopyAlert = false
    @State private var copiedText = ""
    @State private var showBiometricToggle = false
    @State private var biometricEnabled = false
    @State private var showNsecWarning = false
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            ScrollView {
                VStack(spacing: OlasDesign.Spacing.xl) {
                    // Profile section
                    profileSection
                    // Key management section
                    keyManagementSection
                    // Security section
                    securitySection
                    // Data management section
                    dataManagementSection
                }
                .padding(OlasDesign.Spacing.lg)
            }
        }
        .navigationTitle("Account Settings")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.large)
        #endif
        .sheet(isPresented: $showKeyBackup) {
            keyBackupSheet
        }
        .alert("Copied!", isPresented: $showCopyAlert) {
            Button("OK") { }
        } message: {
            Text("\(copiedText) copied to clipboard")
        }
        .alert("Private Key Warning", isPresented: $showNsecWarning) {
            Button("I Understand", role: .destructive) {
                showKeyBackup = true
            }
            Button("Cancel", role: .cancel) { }
        } message: {
            Text("Your private key (nsec) controls your account. Anyone with this key has full access. Keep it secure and never share it.")
        }
    }
    // MARK: - Sections
    @ViewBuilder
    private var profileSection: some View {
        VStack(spacing: OlasDesign.Spacing.lg) {
            // Avatar
            if let currentUserProfile = appState.currentUserProfile {
                AsyncImage(url: URL(string: currentUserProfile.picture ?? "")) { image in
                    image
                        .resizable()
                        .scaledToFill()
                } placeholder: {
                    Image(systemName: "person.circle.fill")
                        .font(.system(size: 80))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [OlasDesign.Colors.primary, OlasDesign.Colors.secondary],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                }
                .frame(width: 100, height: 100)
                .clipShape(Circle())
                .overlay(
                    Circle()
                        .stroke(OlasDesign.Colors.border, lineWidth: 2)
                )
                VStack(spacing: OlasDesign.Spacing.sm) {
                    Text(currentUserProfile.displayName ?? currentUserProfile.name ?? "Unknown")
                        .font(OlasDesign.Typography.title2)
                        .foregroundColor(OlasDesign.Colors.text)
                    if let nip05 = currentUserProfile.nip05 {
                        Text(nip05)
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                }
            }
            OlasButton(
                title: "Edit Profile",
                action: {
                    // TODO: Navigate to profile edit
                    OlasDesign.Haptic.selection()
                },
                style: .secondary
            )
        }
        .frame(maxWidth: .infinity)
        .padding(OlasDesign.Spacing.lg)
        .background(OlasDesign.Colors.surface)
        .cornerRadius(16)
    }
    @ViewBuilder
    private var keyManagementSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Key Management")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            VStack(spacing: OlasDesign.Spacing.sm) {
                // Public key
                keyRow(
                    title: "Public Key",
                    subtitle: "Your public identity",
                    icon: "key",
                    action: copyPublicKey
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                // Private key backup
                keyRow(
                    title: "Backup Private Key",
                    subtitle: "Secure your account",
                    icon: "lock.shield",
                    action: {
                        showNsecWarning = true
                    },
                    isDestructive: true
                )
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
    }
    @ViewBuilder
    private var securitySection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Security")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            VStack(spacing: 0) {
                // Biometric lock
                HStack {
                    Image(systemName: "faceid")
                        .font(.body)
                        .foregroundColor(OlasDesign.Colors.primary)
                        .frame(width: 30)
                    VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                        Text("Biometric Lock")
                            .font(OlasDesign.Typography.body)
                            .foregroundColor(OlasDesign.Colors.text)
                        Text("Require Face ID to access")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    Spacer()
                    Toggle("", isOn: $biometricEnabled)
                        .tint(OlasDesign.Colors.primary)
                }
                .padding(OlasDesign.Spacing.md)
                Divider()
                    .background(OlasDesign.Colors.border)
                    .padding(.leading, 46)
                // Session management
                sessionRow(
                    title: "Active Sessions",
                    subtitle: "Manage logged in devices",
                    icon: "laptopcomputer.and.iphone",
                    badge: "3"
                )
            }
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
    }
    @ViewBuilder
    private var dataManagementSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Data Management")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            VStack(spacing: OlasDesign.Spacing.sm) {
                dataRow(
                    title: "Export Data",
                    subtitle: "Download all your content",
                    icon: "square.and.arrow.up"
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                dataRow(
                    title: "Clear Cache",
                    subtitle: "Free up storage space",
                    icon: "trash",
                    isDestructive: true
                )
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
    }
    // MARK: - Components
    @ViewBuilder
    private func keyRow(title: String, subtitle: String, icon: String, action: @escaping () -> Void, isDestructive: Bool = false) -> some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .font(.body)
                    .foregroundColor(isDestructive ? OlasDesign.Colors.warning : OlasDesign.Colors.primary)
                    .frame(width: 30)
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                    Text(title)
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                    Text(subtitle)
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Spacer()
                Image(systemName: "chevron.right")
                    .font(.caption)
                    .foregroundColor(OlasDesign.Colors.textTertiary)
            }
            .padding(.vertical, OlasDesign.Spacing.sm)
        }
    }
    @ViewBuilder
    private func sessionRow(title: String, subtitle: String, icon: String, badge: String? = nil) -> some View {
        HStack {
            Image(systemName: icon)
                .font(.body)
                .foregroundColor(OlasDesign.Colors.primary)
                .frame(width: 30)
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                Text(title)
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                Text(subtitle)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
            }
            Spacer()
            if let badge = badge {
                Text(badge)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(.white)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 2)
                    .background(OlasDesign.Colors.primary)
                    .cornerRadius(10)
            }
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
        .padding(OlasDesign.Spacing.md)
    }
    @ViewBuilder
    private func dataRow(title: String, subtitle: String, icon: String, isDestructive: Bool = false) -> some View {
        Button(action: {
            // TODO: Implement actions
            OlasDesign.Haptic.selection()
        }) {
            HStack {
                Image(systemName: icon)
                    .font(.body)
                    .foregroundColor(isDestructive ? OlasDesign.Colors.warning : OlasDesign.Colors.primary)
                    .frame(width: 30)
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                    Text(title)
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                    Text(subtitle)
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Spacer()
                Image(systemName: "chevron.right")
                    .font(.caption)
                    .foregroundColor(OlasDesign.Colors.textTertiary)
            }
            .padding(.vertical, OlasDesign.Spacing.sm)
        }
    }
    // MARK: - Key Backup Sheet
    @ViewBuilder
    private var keyBackupSheet: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: OlasDesign.Spacing.xl) {
                    // Warning
                    VStack(spacing: OlasDesign.Spacing.md) {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .font(.system(size: 50))
                            .foregroundColor(OlasDesign.Colors.warning)
                        Text("Private Key Backup")
                            .font(OlasDesign.Typography.title2)
                            .foregroundColor(OlasDesign.Colors.text)
                        Text("Keep this key secure. Anyone with access can control your account.")
                            .font(OlasDesign.Typography.body)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.top, OlasDesign.Spacing.xl)
                    // Key display
                    if let signer = NDKAuthManager.shared.activeSigner as? NDKPrivateKeySigner {
                        VStack(spacing: OlasDesign.Spacing.lg) {
                            // Hex format
                            keyDisplayBox(
                                title: "Hex Format",
                                value: signer.privateKey,
                                action: {
                                    copyToClipboard(signer.privateKey, label: "Private key (hex)")
                                }
                            )
                            // nsec format
                            if let nsec = try? signer.privateKey.nsec() {
                                keyDisplayBox(
                                    title: "nsec Format",
                                    value: nsec,
                                    action: {
                                        copyToClipboard(nsec, label: "Private key (nsec)")
                                    }
                                )
                            }
                        }
                    }
                    Spacer()
                    // Done button
                    OlasButton(
                        title: "Done",
                        action: {
                            showKeyBackup = false
                        },
                        style: .primary
                    )
                    .padding(.bottom, OlasDesign.Spacing.lg)
                }
                .padding(.horizontal, OlasDesign.Spacing.lg)
            }
        }
    }
    @ViewBuilder
    private func keyDisplayBox(title: String, value: String, action: @escaping () -> Void) -> some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
            Text(title)
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textSecondary)
            HStack {
                Text(value)
                    .font(.system(.caption, design: .monospaced))
                    .foregroundColor(OlasDesign.Colors.text)
                    .lineLimit(1)
                    .truncationMode(.middle)
                Spacer()
                Button(action: action) {
                    Image(systemName: "doc.on.doc")
                        .font(.body)
                        .foregroundColor(OlasDesign.Colors.primary)
                }
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(8)
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(OlasDesign.Colors.border, lineWidth: 1)
            )
        }
    }
    // MARK: - Methods
    private func copyPublicKey() {
        guard let signer = NDKAuthManager.shared.activeSigner as? NDKPrivateKeySigner else { return }
        let pubkey = signer.publicKey
        copyToClipboard(pubkey, label: "Public key")
    }
    private func copyToClipboard(_ text: String, label: String) {
        #if canImport(UIKit)
        UIPasteboard.general.string = text
        #elseif canImport(AppKit)
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(text, forType: .string)
        #endif
        copiedText = label
        showCopyAlert = true
        OlasDesign.Haptic.success()
    }
}
// MARK: - Preview
struct AccountSettingsView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            AccountSettingsView()
                .environmentObject(AppState())
        }
    }
}
</file>

<file path="Sources/Olas/Views/Settings/NotificationSettingsView.swift">
import SwiftUI
struct NotificationSettingsView: View {
    @State private var pushNotificationsEnabled = true
    @State private var newFollowers = true
    @State private var mentions = true
    @State private var replies = true
    @State private var zaps = true
    @State private var directMessages = true
    @State private var showSoundSettings = false
    @State private var selectedSound = "Default"
    private let notificationSounds = ["Default", "Chime", "Pop", "Ding", "None"]
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            ScrollView {
                VStack(spacing: OlasDesign.Spacing.xl) {
                    // Master toggle
                    masterToggleSection
                    if pushNotificationsEnabled {
                        // Notification types
                        notificationTypesSection
                        // Sound settings
                        soundSettingsSection
                        // Quiet hours
                        quietHoursSection
                    }
                }
                .padding(OlasDesign.Spacing.lg)
            }
        }
        .navigationTitle("Notifications")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.large)
        #endif
        .sheet(isPresented: $showSoundSettings) {
            soundSelectionSheet
        }
    }
    // MARK: - Sections
    @ViewBuilder
    private var masterToggleSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            HStack {
                VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                    Text("Push Notifications")
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                    Text("Get notified about activity")
                        .font(OlasDesign.Typography.caption)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                }
                Spacer()
                Toggle("", isOn: $pushNotificationsEnabled)
                    .tint(OlasDesign.Colors.primary)
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
        .onChange(of: pushNotificationsEnabled) { _, enabled in
            OlasDesign.Haptic.selection()
            if enabled {
                requestNotificationPermission()
            }
        }
    }
    @ViewBuilder
    private var notificationTypesSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Notification Types")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            VStack(spacing: 0) {
                notificationToggle(
                    title: "New Followers",
                    subtitle: "When someone follows you",
                    icon: "person.badge.plus",
                    isOn: $newFollowers
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                    .padding(.leading, 46)
                notificationToggle(
                    title: "Mentions",
                    subtitle: "When you're @mentioned",
                    icon: "at",
                    isOn: $mentions
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                    .padding(.leading, 46)
                notificationToggle(
                    title: "Replies",
                    subtitle: "Responses to your posts",
                    icon: "bubble.left",
                    isOn: $replies
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                    .padding(.leading, 46)
                notificationToggle(
                    title: "Zaps",
                    subtitle: "Lightning payments received",
                    icon: "bolt.fill",
                    isOn: $zaps
                )
                Divider()
                    .background(OlasDesign.Colors.border)
                    .padding(.leading, 46)
                notificationToggle(
                    title: "Direct Messages",
                    subtitle: "Private messages",
                    icon: "envelope",
                    isOn: $directMessages
                )
            }
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
    }
    @ViewBuilder
    private var soundSettingsSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Sound")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            Button(action: {
                showSoundSettings = true
                OlasDesign.Haptic.selection()
            }) {
                HStack {
                    Image(systemName: "speaker.wave.2")
                        .font(.body)
                        .foregroundColor(OlasDesign.Colors.primary)
                        .frame(width: 30)
                    Text("Notification Sound")
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.text)
                    Spacer()
                    Text(selectedSound)
                        .font(OlasDesign.Typography.body)
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                    Image(systemName: "chevron.right")
                        .font(.caption)
                        .foregroundColor(OlasDesign.Colors.textTertiary)
                }
                .padding(OlasDesign.Spacing.md)
                .background(OlasDesign.Colors.surface)
                .cornerRadius(12)
            }
        }
    }
    @ViewBuilder
    private var quietHoursSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Quiet Hours")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            VStack(spacing: OlasDesign.Spacing.md) {
                quietHourRow(
                    title: "Do Not Disturb",
                    subtitle: "Silence notifications",
                    icon: "moon.fill"
                )
                quietHourRow(
                    title: "Schedule",
                    subtitle: "10:00 PM - 7:00 AM",
                    icon: "clock"
                )
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(12)
        }
    }
    // MARK: - Components
    @ViewBuilder
    private func notificationToggle(title: String, subtitle: String, icon: String, isOn: Binding<Bool>) -> some View {
        HStack {
            Image(systemName: icon)
                .font(.body)
                .foregroundColor(OlasDesign.Colors.primary)
                .frame(width: 30)
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                Text(title)
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                Text(subtitle)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
            }
            Spacer()
            Toggle("", isOn: isOn)
                .tint(OlasDesign.Colors.primary)
        }
        .padding(OlasDesign.Spacing.md)
        .onChange(of: isOn.wrappedValue) { _, _ in
            OlasDesign.Haptic.selection()
        }
    }
    @ViewBuilder
    private func quietHourRow(title: String, subtitle: String, icon: String) -> some View {
        HStack {
            Image(systemName: icon)
                .font(.body)
                .foregroundColor(OlasDesign.Colors.primary)
                .frame(width: 30)
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                Text(title)
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                Text(subtitle)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
            }
            Spacer()
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(OlasDesign.Colors.textTertiary)
        }
    }
    // MARK: - Sound Selection Sheet
    @ViewBuilder
    private var soundSelectionSheet: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: 0) {
                    // Header
                    HStack {
                        Button("Cancel") {
                            showSoundSettings = false
                        }
                        .foregroundColor(OlasDesign.Colors.textSecondary)
                        Spacer()
                        Text("Notification Sound")
                            .font(OlasDesign.Typography.title3)
                            .foregroundColor(OlasDesign.Colors.text)
                        Spacer()
                        Button("Done") {
                            showSoundSettings = false
                        }
                        .foregroundColor(OlasDesign.Colors.primary)
                    }
                    .padding(OlasDesign.Spacing.lg)
                    // Sound options
                    VStack(spacing: OlasDesign.Spacing.sm) {
                        ForEach(notificationSounds, id: \.self) { sound in
                            Button(action: {
                                selectedSound = sound
                                playSound(sound)
                                OlasDesign.Haptic.selection()
                            }) {
                                HStack {
                                    Text(sound)
                                        .font(OlasDesign.Typography.body)
                                        .foregroundColor(OlasDesign.Colors.text)
                                    Spacer()
                                    if selectedSound == sound {
                                        Image(systemName: "checkmark")
                                            .font(.body)
                                            .foregroundColor(OlasDesign.Colors.primary)
                                    }
                                }
                                .padding(OlasDesign.Spacing.md)
                                .background(OlasDesign.Colors.surface)
                                .cornerRadius(8)
                            }
                        }
                    }
                    .padding(OlasDesign.Spacing.lg)
                    Spacer()
                }
            }
        }
    }
    // MARK: - Methods
    private func requestNotificationPermission() {
        #if os(iOS)
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) { granted, error in
            if granted {
                print("Notification permission granted")
            } else if let error = error {
                print("Notification permission error: \(error)")
            }
        }
        #endif
    }
    private func playSound(_ sound: String) {
        // In a real app, you'd play the actual sound here
        print("Playing sound: \(sound)")
    }
}
// MARK: - Preview
struct NotificationSettingsView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            NotificationSettingsView()
        }
    }
}
</file>

<file path="Sources/Olas/Views/Settings/RelayManagementView.swift">
import SwiftUI
import NDKSwift
struct RelayManagementView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var relays: [RelayInfo] = []
    @State private var newRelayURL = ""
    @State private var showAddRelay = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var isConnecting = false
    @State private var relayToRemove: RelayInfo?
    @State private var showRemoveConfirmation = false
    struct RelayInfo: Identifiable {
        let id = UUID()
        let url: String
        var status: RelayStatus
        var isRead: Bool
        var isWrite: Bool
        var latency: Int? // in milliseconds
    }
    enum RelayStatus {
        case connected
        case connecting
        case disconnected
        case error
        var color: Color {
            switch self {
            case .connected: return .green
            case .connecting: return .orange
            case .disconnected: return .gray
            case .error: return .red
            }
        }
        var icon: String {
            switch self {
            case .connected: return "circle.fill"
            case .connecting: return "circle.dotted"
            case .disconnected: return "circle"
            case .error: return "exclamationmark.circle"
            }
        }
    }
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            VStack(spacing: 0) {
                // Header with add button
                HStack {
                    Text("Relay Management")
                        .font(OlasDesign.Typography.title)
                        .foregroundColor(OlasDesign.Colors.text)
                    Spacer()
                    Button(action: {
                        showAddRelay = true
                        OlasDesign.Haptic.selection()
                    }) {
                        Image(systemName: "plus.circle.fill")
                            .font(.title2)
                            .foregroundStyle(
                                LinearGradient(
                                    colors: [OlasDesign.Colors.primary, OlasDesign.Colors.secondary],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                    }
                }
                .padding(OlasDesign.Spacing.lg)
                // Relay statistics
                relayStatsView
                    .padding(.horizontal, OlasDesign.Spacing.lg)
                    .padding(.bottom, OlasDesign.Spacing.lg)
                // Relay list
                ScrollView {
                    VStack(spacing: OlasDesign.Spacing.md) {
                        ForEach(relays) { relay in
                            relayRow(relay)
                        }
                    }
                    .padding(OlasDesign.Spacing.lg)
                }
            }
        }
        .onAppear {
            loadRelays()
        }
        .sheet(isPresented: $showAddRelay) {
            addRelaySheet
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .alert("Remove Relay", isPresented: $showRemoveConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("Remove", role: .destructive) {
                if let relay = relayToRemove {
                    removeRelay(relay)
                }
            }
        } message: {
            Text("Are you sure you want to remove \(relayToRemove?.url ?? "")?")
        }
    }
    // MARK: - Views
    @ViewBuilder
    private var relayStatsView: some View {
        HStack(spacing: OlasDesign.Spacing.lg) {
            statsCard(
                title: "Connected",
                value: "\(relays.filter { $0.status == .connected }.count)",
                color: .green
            )
            statsCard(
                title: "Total",
                value: "\(relays.count)",
                color: OlasDesign.Colors.primary
            )
            statsCard(
                title: "Avg Latency",
                value: formatLatency(averageLatency()),
                color: .blue
            )
        }
    }
    @ViewBuilder
    private func statsCard(title: String, value: String, color: Color) -> some View {
        VStack(spacing: OlasDesign.Spacing.xs) {
            Text(value)
                .font(OlasDesign.Typography.title)
                .foregroundColor(color)
            Text(title)
                .font(OlasDesign.Typography.caption)
                .foregroundColor(OlasDesign.Colors.textSecondary)
        }
        .frame(maxWidth: .infinity)
        .padding(OlasDesign.Spacing.md)
        .background(OlasDesign.Colors.surface)
        .cornerRadius(12)
    }
    @ViewBuilder
    private func relayRow(_ relay: RelayInfo) -> some View {
        HStack(spacing: OlasDesign.Spacing.md) {
            // Status indicator
            Image(systemName: relay.status.icon)
                .foregroundColor(relay.status.color)
                .font(.body)
            // Relay info
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.xs) {
                Text(relay.url)
                    .font(OlasDesign.Typography.body)
                    .foregroundColor(OlasDesign.Colors.text)
                    .lineLimit(1)
                HStack(spacing: OlasDesign.Spacing.sm) {
                    if relay.isRead {
                        Label("Read", systemImage: "arrow.down.circle")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    if relay.isWrite {
                        Label("Write", systemImage: "arrow.up.circle")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    if let latency = relay.latency {
                        Label("\(latency)ms", systemImage: "speedometer")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                }
            }
            Spacer()
            // Actions
            Menu {
                Button(action: {
                    toggleRead(relay)
                }) {
                    Label(relay.isRead ? "Disable Read" : "Enable Read", systemImage: "arrow.down.circle")
                }
                Button(action: {
                    toggleWrite(relay)
                }) {
                    Label(relay.isWrite ? "Disable Write" : "Enable Write", systemImage: "arrow.up.circle")
                }
                if relay.status == .disconnected {
                    Button(action: {
                        reconnectRelay(relay)
                    }) {
                        Label("Reconnect", systemImage: "arrow.counterclockwise")
                    }
                }
                Button(role: .destructive, action: {
                    relayToRemove = relay
                    showRemoveConfirmation = true
                }) {
                    Label("Remove", systemImage: "trash")
                }
            } label: {
                Image(systemName: "ellipsis")
                    .font(.body)
                    .foregroundColor(OlasDesign.Colors.textSecondary)
                    .frame(width: 44, height: 44)
            }
        }
        .padding(OlasDesign.Spacing.md)
        .background(OlasDesign.Colors.surface)
        .cornerRadius(12)
    }
    @ViewBuilder
    private var addRelaySheet: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: OlasDesign.Spacing.lg) {
                    Text("Add New Relay")
                        .font(OlasDesign.Typography.title2)
                        .foregroundColor(OlasDesign.Colors.text)
                        .padding(.top, OlasDesign.Spacing.lg)
                    VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                        Text("Relay URL")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                        TextField("wss://relay.example.com", text: $newRelayURL)
                            .textFieldStyle(.plain)
                            .padding(OlasDesign.Spacing.md)
                            .background(OlasDesign.Colors.surface)
                            .cornerRadius(8)
                            .overlay(
                                RoundedRectangle(cornerRadius: 8)
                                    .stroke(OlasDesign.Colors.border, lineWidth: 1)
                            )
                            #if os(iOS)
                            .autocapitalization(.none)
                            #endif
                            .disableAutocorrection(true)
                    }
                    // Popular relays
                    VStack(alignment: .leading, spacing: OlasDesign.Spacing.sm) {
                        Text("Popular Relays")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: OlasDesign.Spacing.sm) {
                                ForEach(popularRelays, id: \.self) { relay in
                                    Button(action: {
                                        newRelayURL = relay
                                        OlasDesign.Haptic.selection()
                                    }) {
                                        Text(relay)
                                            .font(OlasDesign.Typography.caption)
                                            .padding(.horizontal, OlasDesign.Spacing.md)
                                            .padding(.vertical, OlasDesign.Spacing.sm)
                                            .background(OlasDesign.Colors.surface)
                                            .cornerRadius(20)
                                            .overlay(
                                                RoundedRectangle(cornerRadius: 20)
                                                    .stroke(OlasDesign.Colors.border, lineWidth: 1)
                                            )
                                    }
                                    .foregroundColor(OlasDesign.Colors.text)
                                }
                            }
                        }
                    }
                    Spacer()
                    // Action buttons
                    HStack(spacing: OlasDesign.Spacing.md) {
                        OlasButton(
                            title: "Cancel",
                            action: {
                                showAddRelay = false
                                newRelayURL = ""
                            },
                            style: .secondary
                        )
                        OlasButton(
                            title: isConnecting ? "Connecting..." : "Add Relay",
                            action: addNewRelay,
                            style: .primary,
                            isLoading: isConnecting
                        )
                        .disabled(newRelayURL.isEmpty || isConnecting)
                    }
                    .padding(.bottom, OlasDesign.Spacing.lg)
                }
                .padding(.horizontal, OlasDesign.Spacing.lg)
            }
        }
    }
    // MARK: - Data
    private let popularRelays = [
        "wss://relay.damus.io",
        "wss://relay.nostr.band",
        "wss://nos.lol",
        "wss://nostr.wine",
        "wss://relay.snort.social"
    ]
    // MARK: - Methods
    private func loadRelays() {
        guard let ndk = nostrManager.ndk else { return }
        relays = ndk.relayPool.relays.map { relay in
            RelayInfo(
                url: relay.url,
                status: relay.status == .connected ? .connected : .disconnected,
                isRead: true,
                isWrite: true,
                latency: nil
            )
        }
        // Measure latency for connected relays
        for (index, relay) in relays.enumerated() where relay.status == .connected {
            measureLatency(for: relay) { latency in
                if let latency = latency {
                    relays[index].latency = latency
                }
            }
        }
    }
    private func addNewRelay() {
        guard !newRelayURL.isEmpty, let ndk = nostrManager.ndk else { return }
        isConnecting = true
        Task {
            do {
                // Normalize the URL
                var normalizedURL = newRelayURL
                if !normalizedURL.hasPrefix("wss://") && !normalizedURL.hasPrefix("ws://") {
                    normalizedURL = "wss://\(normalizedURL)"
                }
                // Add relay to pool
                try await ndk.relayPool.addRelay(normalizedURL)
                await MainActor.run {
                    OlasDesign.Haptic.success()
                    showAddRelay = false
                    newRelayURL = ""
                    loadRelays()
                }
            } catch {
                await MainActor.run {
                    errorMessage = "Failed to add relay: \(error.localizedDescription)"
                    showError = true
                    OlasDesign.Haptic.error()
                }
            }
            await MainActor.run {
                isConnecting = false
            }
        }
    }
    private func removeRelay(_ relay: RelayInfo) {
        guard let ndk = nostrManager.ndk else { return }
        Task {
            // Remove from pool
            ndk.relayPool.removeRelay(relay.url)
            await MainActor.run {
                relays.removeAll { $0.id == relay.id }
                OlasDesign.Haptic.success()
            }
        }
    }
    private func toggleRead(_ relay: RelayInfo) {
        if let index = relays.firstIndex(where: { $0.id == relay.id }) {
            relays[index].isRead.toggle()
            // TODO: Update relay configuration in NDK
        }
    }
    private func toggleWrite(_ relay: RelayInfo) {
        if let index = relays.firstIndex(where: { $0.id == relay.id }) {
            relays[index].isWrite.toggle()
            // TODO: Update relay configuration in NDK
        }
    }
    private func reconnectRelay(_ relay: RelayInfo) {
        guard let ndk = nostrManager.ndk else { return }
        if let index = relays.firstIndex(where: { $0.id == relay.id }) {
            relays[index].status = .connecting
            Task {
                // Reconnect
                if let ndkRelay = ndk.relayPool.relays.first(where: { $0.url == relay.url }) {
                    try? await ndkRelay.connect()
                }
                await MainActor.run {
                    loadRelays()
                }
            }
        }
    }
    private func measureLatency(for relay: RelayInfo, completion: @escaping (Int?) -> Void) {
        // Simple latency measurement - in production, you'd send a ping event
        let start = Date()
        Task {
            // Simulate latency measurement
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s
            let latency = Int(Date().timeIntervalSince(start) * 1000)
            await MainActor.run {
                completion(latency)
            }
        }
    }
    private func averageLatency() -> Int? {
        let latencies = relays.compactMap { $0.latency }
        guard !latencies.isEmpty else { return nil }
        return latencies.reduce(0, +) / latencies.count
    }
    private func formatLatency(_ latency: Int?) -> String {
        guard let latency = latency else { return "N/A" }
        return "\(latency)ms"
    }
}
// MARK: - Preview
struct RelayManagementView_Previews: PreviewProvider {
    static var previews: some View {
        RelayManagementView()
            .environmentObject(AppState())
    }
}
</file>

<file path="Sources/Olas/Views/Settings/SettingsView.swift">
import SwiftUI
import NDKSwift
struct SettingsView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    @State private var showingLogoutAlert = false
    var body: some View {
        NavigationStack {
            ZStack {
                OlasDesign.Colors.background
                    .ignoresSafeArea()
                List {
                    // Account Section
                    Section {
                        NavigationLink(destination: AccountSettingsView()) {
                            settingRow(
                                icon: "person.circle",
                                title: "Account Settings",
                                color: OlasDesign.Colors.primary
                            )
                        }
                    }
                    // Relay Section
                    Section {
                        NavigationLink(destination: RelayManagementView()) {
                            HStack {
                                Image(systemName: "server.rack")
                                    .font(.body)
                                    .foregroundColor(.blue)
                                    .frame(width: 30)
                                Text("Relay Configuration")
                                    .font(OlasDesign.Typography.body)
                                Spacer()
                                Text("\(nostrManager.ndk?.relayPool.relays.count ?? 0)")
                                    .font(OlasDesign.Typography.caption)
                                    .foregroundColor(OlasDesign.Colors.textSecondary)
                            }
                        }
                    }
                    // Appearance & Notifications
                    Section {
                        NavigationLink(destination: ThemeSettingsView()) {
                            settingRow(
                                icon: "paintbrush",
                                title: "Theme",
                                color: .purple
                            )
                        }
                        NavigationLink(destination: NotificationSettingsView()) {
                            settingRow(
                                icon: "bell",
                                title: "Notifications",
                                color: .orange
                            )
                        }
                    }
                    // Blossom Section
                    Section {
                        NavigationLink(destination: Text("Blossom Server Management")) {
                            settingRow(
                                icon: "cloud",
                                title: "Blossom Servers",
                                color: .green
                            )
                        }
                    }
                    // Privacy Section
                    Section {
                        NavigationLink(destination: Text("Blocked Users")) {
                            settingRow(
                                icon: "eye.slash",
                                title: "Blocked Users",
                                color: .red
                            )
                        }
                        NavigationLink(destination: Text("Content Filtering")) {
                            settingRow(
                                icon: "hand.raised",
                                title: "Content Filtering",
                                color: .orange
                            )
                        }
                    }
                    // About Section
                    Section {
                        NavigationLink(destination: Text("About Olas")) {
                            settingRow(
                                icon: "info.circle",
                                title: "About Olas",
                                color: .blue
                            )
                        }
                        NavigationLink(destination: Text("Help & Support")) {
                            settingRow(
                                icon: "questionmark.circle",
                                title: "Help & Support",
                                color: .green
                            )
                        }
                    }
                    // Logout
                    Section {
                        Button(action: { showingLogoutAlert = true }) {
                            HStack {
                                Image(systemName: "rectangle.portrait.and.arrow.right")
                                    .font(.body)
                                    .foregroundColor(.red)
                                    .frame(width: 30)
                                Text("Logout")
                                    .font(OlasDesign.Typography.body)
                                    .foregroundColor(.red)
                            }
                        }
                    }
                }
                .listStyle(.insetGrouped)
                .scrollContentBackground(.hidden)
            }
            .navigationTitle("Settings")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.large)
            #endif
            .alert("Logout", isPresented: $showingLogoutAlert) {
                Button("Cancel", role: .cancel) {}
                Button("Logout", role: .destructive) {
                    logout()
                }
            } message: {
                Text("Are you sure you want to logout?")
            }
        }
    }
    @ViewBuilder
    private func settingRow(icon: String, title: String, color: Color) -> some View {
        HStack {
            Image(systemName: icon)
                .font(.body)
                .foregroundColor(color)
                .frame(width: 30)
            Text(title)
                .font(OlasDesign.Typography.body)
                .foregroundColor(OlasDesign.Colors.text)
        }
    }
    private func logout() {
        appState.isAuthenticated = false
        appState.currentUser = nil
        Task {
            await nostrManager.disconnect()
        }
        NDKAuthManager.shared.signOut()
    }
}
</file>

<file path="Sources/Olas/Views/Settings/ThemeSettingsView.swift">
import SwiftUI
struct ThemeSettingsView: View {
    @State private var selectedTheme = "Auto"
    @State private var accentColor = "Purple"
    @State private var appIcon = "Default"
    private let themes = ["Auto", "Light", "Dark"]
    private let accentColors = [
        ("Purple", Color.purple),
        ("Blue", Color.blue),
        ("Pink", Color.pink),
        ("Orange", Color.orange),
        ("Green", Color.green),
        ("Red", Color.red)
    ]
    private let appIcons = ["Default", "Dark", "Gradient", "Minimal"]
    var body: some View {
        ZStack {
            OlasDesign.Colors.background
                .ignoresSafeArea()
            ScrollView {
                VStack(spacing: OlasDesign.Spacing.xl) {
                    // Theme selection
                    themeSection
                    // Accent color
                    accentColorSection
                    // App icon
                    appIconSection
                    // Preview
                    previewSection
                }
                .padding(OlasDesign.Spacing.lg)
            }
        }
        .navigationTitle("Theme")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.large)
        #endif
    }
    // MARK: - Sections
    @ViewBuilder
    private var themeSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Appearance")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            HStack(spacing: OlasDesign.Spacing.md) {
                ForEach(themes, id: \.self) { theme in
                    themeOption(theme)
                }
            }
        }
    }
    @ViewBuilder
    private func themeOption(_ theme: String) -> some View {
        Button(action: {
            selectedTheme = theme
            OlasDesign.Haptic.selection()
        }) {
            VStack(spacing: OlasDesign.Spacing.sm) {
                // Preview
                ZStack {
                    RoundedRectangle(cornerRadius: 12)
                        .fill(theme == "Dark" ? Color.black : theme == "Light" ? Color.white : Color.gray)
                        .frame(height: 100)
                    VStack(spacing: 4) {
                        RoundedRectangle(cornerRadius: 4)
                            .fill(theme == "Dark" ? Color.gray : Color.black.opacity(0.8))
                            .frame(width: 40, height: 4)
                        HStack(spacing: 4) {
                            ForEach(0..<3) { _ in
                                RoundedRectangle(cornerRadius: 2)
                                    .fill(theme == "Dark" ? Color.gray.opacity(0.5) : Color.gray.opacity(0.3))
                                    .frame(width: 20, height: 20)
                            }
                        }
                        .padding(.top, 8)
                    }
                }
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(selectedTheme == theme ? OlasDesign.Colors.primary : OlasDesign.Colors.border, lineWidth: 2)
                )
                Text(theme)
                    .font(OlasDesign.Typography.caption)
                    .foregroundColor(selectedTheme == theme ? OlasDesign.Colors.primary : OlasDesign.Colors.textSecondary)
            }
        }
        .frame(maxWidth: .infinity)
    }
    @ViewBuilder
    private var accentColorSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Accent Color")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: OlasDesign.Spacing.md), count: 3), spacing: OlasDesign.Spacing.md) {
                ForEach(accentColors, id: \.0) { name, color in
                    Button(action: {
                        accentColor = name
                        OlasDesign.Haptic.selection()
                    }) {
                        VStack(spacing: OlasDesign.Spacing.sm) {
                            Circle()
                                .fill(color)
                                .frame(width: 60, height: 60)
                                .overlay(
                                    Circle()
                                        .stroke(accentColor == name ? Color.white : Color.clear, lineWidth: 3)
                                        .padding(3)
                                )
                                .overlay(
                                    Circle()
                                        .stroke(accentColor == name ? color : OlasDesign.Colors.border, lineWidth: 2)
                                )
                            Text(name)
                                .font(OlasDesign.Typography.caption)
                                .foregroundColor(accentColor == name ? color : OlasDesign.Colors.textSecondary)
                        }
                    }
                }
            }
        }
    }
    @ViewBuilder
    private var appIconSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("App Icon")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: OlasDesign.Spacing.md), count: 4), spacing: OlasDesign.Spacing.md) {
                ForEach(appIcons, id: \.self) { icon in
                    Button(action: {
                        appIcon = icon
                        changeAppIcon(to: icon)
                        OlasDesign.Haptic.selection()
                    }) {
                        VStack(spacing: OlasDesign.Spacing.sm) {
                            // Icon preview
                            RoundedRectangle(cornerRadius: 16)
                                .fill(
                                    icon == "Default" ? LinearGradient(
                                        colors: [.purple, .pink],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ) : icon == "Dark" ? LinearGradient(
                                        colors: [.black, .gray],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ) : icon == "Gradient" ? LinearGradient(
                                        colors: [.blue, .green],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ) : LinearGradient(
                                        colors: [.white, .gray],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 60, height: 60)
                                .overlay(
                                    Text("O")
                                        .font(.system(size: 30, weight: .bold, design: .rounded))
                                        .foregroundColor(icon == "Minimal" ? .black : .white)
                                )
                                .overlay(
                                    RoundedRectangle(cornerRadius: 16)
                                        .stroke(appIcon == icon ? OlasDesign.Colors.primary : OlasDesign.Colors.border, lineWidth: 2)
                                )
                            Text(icon)
                                .font(.system(size: 10))
                                .foregroundColor(appIcon == icon ? OlasDesign.Colors.primary : OlasDesign.Colors.textSecondary)
                        }
                    }
                }
            }
        }
    }
    @ViewBuilder
    private var previewSection: some View {
        VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
            Text("Preview")
                .font(OlasDesign.Typography.title3)
                .foregroundColor(OlasDesign.Colors.text)
            // Mock feed item
            VStack(alignment: .leading, spacing: OlasDesign.Spacing.md) {
                // Header
                HStack(spacing: OlasDesign.Spacing.sm) {
                    Circle()
                        .fill(LinearGradient(
                            colors: [.purple, .pink],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ))
                        .frame(width: 40, height: 40)
                    VStack(alignment: .leading, spacing: 2) {
                        Text("Preview User")
                            .font(OlasDesign.Typography.bodyBold)
                            .foregroundColor(OlasDesign.Colors.text)
                        Text("2 minutes ago")
                            .font(OlasDesign.Typography.caption)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    Spacer()
                }
                // Image
                RoundedRectangle(cornerRadius: 12)
                    .fill(LinearGradient(
                        colors: getAccentGradient(),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ))
                    .aspectRatio(1, contentMode: .fit)
                    .overlay(
                        Image(systemName: "photo")
                            .font(.largeTitle)
                            .foregroundColor(.white.opacity(0.5))
                    )
                // Actions
                HStack(spacing: OlasDesign.Spacing.lg) {
                    Button(action: {}) {
                        Image(systemName: "heart")
                            .font(.title3)
                            .foregroundColor(getAccentColor())
                    }
                    Button(action: {}) {
                        Image(systemName: "bubble.left")
                            .font(.title3)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    Button(action: {}) {
                        Image(systemName: "bolt")
                            .font(.title3)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                    Spacer()
                    Button(action: {}) {
                        Image(systemName: "square.and.arrow.up")
                            .font(.title3)
                            .foregroundColor(OlasDesign.Colors.textSecondary)
                    }
                }
            }
            .padding(OlasDesign.Spacing.md)
            .background(OlasDesign.Colors.surface)
            .cornerRadius(16)
        }
    }
    // MARK: - Methods
    private func getAccentColor() -> Color {
        switch accentColor {
        case "Purple": return .purple
        case "Blue": return .blue
        case "Pink": return .pink
        case "Orange": return .orange
        case "Green": return .green
        case "Red": return .red
        default: return .purple
        }
    }
    private func getAccentGradient() -> [Color] {
        let base = getAccentColor()
        switch accentColor {
        case "Purple": return [.purple, .pink]
        case "Blue": return [.blue, .cyan]
        case "Pink": return [.pink, .red]
        case "Orange": return [.orange, .yellow]
        case "Green": return [.green, .mint]
        case "Red": return [.red, .orange]
        default: return [.purple, .pink]
        }
    }
    private func changeAppIcon(to iconName: String) {
        #if os(iOS)
        guard UIApplication.shared.supportsAlternateIcons else { return }
        let alternateIconName: String? = iconName == "Default" ? nil : iconName
        UIApplication.shared.setAlternateIconName(alternateIconName) { error in
            if let error = error {
                print("Error changing app icon: \(error.localizedDescription)")
            }
        }
        #endif
    }
}
// MARK: - Preview
struct ThemeSettingsView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            ThemeSettingsView()
        }
    }
}
</file>

<file path="Sources/Olas/Views/ContentView.swift">
import SwiftUI
import NDKSwift
struct ContentView: View {
    @Environment(NostrManager.self) private var nostrManager
    @EnvironmentObject var appState: AppState
    var body: some View {
        if let ndk = nostrManager.ndk {
            Group {
                if appState.authManager.isAuthenticated {
                    // Authenticated content
                    MainTabView()
                } else {
                    // Authentication screen
                    AuthenticationView()
                }
            }
            .environment(\.ndk, ndk)
        } else {
            // Show loading or splash screen while NDK initializes
            ProgressView()
                .scaleEffect(1.5)
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.black)
        }
    }
}
</file>

<file path="Tests/OlasTests/OlasTests.swift">
import XCTest
@testable import Olas
final class OlasTests: XCTestCase {
    func testImageMetadataInitialization() throws {
        let url = URL(string: "https://example.com/image.jpg")!
        let metadata = ImageMetadata(
            url: url,
            width: 1024,
            height: 768,
            blurhash: "L6PZfSi_.AyE_3t7t7R**0o#DgR4",
            alt: "Test image"
        )
        XCTAssertEqual(metadata.url, url)
        XCTAssertEqual(metadata.width, 1024)
        XCTAssertEqual(metadata.height, 768)
        XCTAssertNotNil(metadata.blurhash)
        XCTAssertEqual(metadata.alt, "Test image")
    }
}
</file>

<file path=".gitignore">
# Xcode
#
# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore

## User settings
xcuserdata/

## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)
*.xcscmblueprint
*.xccheckout

## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)
build/
DerivedData/
*.moved-aside
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3

## Obj-C/Swift specific
*.hmap

## App packaging
*.ipa
*.dSYM.zip
*.dSYM

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
#
# Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
# Packages/
# Package.pins
# Package.resolved
# *.xcodeproj
#
# Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
# hence it is not needed unless you have added a package configuration file to your project
# .swiftpm

.build/

# CocoaPods
#
# We recommend against adding the Pods directory to your .gitignore. However
# you should judge for yourself, the pros and cons are mentioned at:
# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
#
# Pods/
#
# Add this line if you want to avoid checking in source code from the Xcode workspace
# *.xcworkspace

# Carthage
#
# Add this line if you want to avoid checking in source code from Carthage dependencies.
# Carthage/Checkouts

Carthage/Build/

# Accio dependency management
Dependencies/
.accio/

# fastlane
#
# It is recommended to not store the screenshots in the git repo.
# Instead, use fastlane to re-generate the screenshots whenever they are needed.
# For more information about the recommended setup visit:
# https://docs.fastlane.tools/best-practices/source-control/#source-control

fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output

# Code Injection
#
# After new code Injection tools there's a generated folder /iOSInjectionProject
# https://github.com/johnno1962/injectionforxcode

iOSInjectionProject/

# macOS
.DS_Store

# Test Results
test-results/
</file>

<file path="build.sh">
#!/bin/bash
set -euo pipefail
# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"
# Get app name from directory
APP_NAME=$(basename "$SCRIPT_DIR")
echo -e "${YELLOW} Regenerating Xcode project...${NC}"
# Check if xcodegen is installed
if ! command -v xcodegen &> /dev/null; then
    echo -e "${RED} xcodegen is not installed. Installing via Homebrew...${NC}"
    brew install xcodegen
fi
# Generate Xcode project
xcodegen generate
echo -e "${GREEN} Xcode project regenerated${NC}"
# Build the project
echo -e "${YELLOW}  Building ${APP_NAME}...${NC}"
# Set default values
DESTINATION="${DESTINATION:-platform=iOS Simulator,name=iPhone 15 Pro}"
CONFIGURATION="${CONFIGURATION:-Debug}"
SCHEME="${SCHEME:-$APP_NAME}"
# Build with xcbeautify for cleaner output
set -o pipefail && xcodebuild \
    -project "${APP_NAME}.xcodeproj" \
    -scheme "$SCHEME" \
    -destination "$DESTINATION" \
    -configuration "$CONFIGURATION" \
    build \
    | xcbeautify
echo -e "${GREEN} Build completed successfully${NC}"
</file>

<file path="deploy.sh">
#!/bin/bash
cd "$(dirname "$0")/.."
./deploy-testflight.sh Olas
</file>

<file path="ExportOptions-TestFlight.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>destination</key>
    <string>export</string>
    <key>method</key>
    <string>app-store</string>
    <key>signingStyle</key>
    <string>automatic</string>
    <key>stripSwiftSymbols</key>
    <true/>
    <key>teamID</key>
    <string>456SHKPP26</string>
    <key>uploadBitcode</key>
    <false/>
    <key>uploadSymbols</key>
    <true/>
    <key>compileBitcode</key>
    <false/>
    <key>provisioningProfiles</key>
    <dict/>
</dict>
</plist>
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Pablo Fernandez

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="MODERNIZATION_SUMMARY.md">
# Olas App Modernization Summary

## Overview
The Olas app has been modernized to match the architectural patterns used in NutsackiOS and Ambulando, following current NDKSwift best practices.

## Key Changes

### 1. Architecture Updates
- **NostrManager**: New centralized manager using `@Observable` instead of `ObservableObject`
- **Environment Injection**: Using `@Environment(NostrManager.self)` instead of passing NDK through AppState
- **Simplified AppState**: Now only handles UI state, not NDK management

### 2. Authentication Flow
- Integrated with `NDKAuthManager` for session persistence
- Support for biometric authentication
- Proper session management with keychain storage

### 3. Data Sources
- Created declarative data sources following NDKSwift patterns:
  - `UserProfileDataSource`: For user profile metadata
  - `ImageFeedDataSource`: For image posts
  - `HashtagFeedDataSource`: For hashtag-based feeds
  - `UserPostsDataSource`: For user-specific posts

### 4. Relay Management
- Modern relay management with UserDefaults persistence
- Support for default and user-added relays
- Real-time relay status monitoring

### 5. Blossom Integration
- `BlossomServerManager` for handling file uploads
- Multi-server support with fallback
- Server selection persistence

## Files Modified

### Core Files
- `OlasApp.swift`: Updated to initialize managers
- `AppState.swift`: Simplified to UI state only
- `NostrManager.swift`: New modern manager (created)
- `BlossomServerManager.swift`: Blossom integration (created)
- `NostrDataSources.swift`: Declarative data sources (created)

### View Updates
- `ContentView.swift`: Uses new architecture
- `AuthenticationView.swift`: Uses NostrManager
- `MainTabView.swift`: Updated navigation
- `RelayManagementView.swift`: Modern relay management
- `OnboardingView.swift`: Updated authentication

## Remaining Work

While the core architecture has been modernized, some views still need updates to use the new NostrManager instead of accessing NDK through AppState. The compilation errors indicate these areas need attention:

1. Update all views that reference `appState.ndk` to use `nostrManager.ndk`
2. Fix platform-specific code (UIKit references)
3. Update relay constants

## Benefits

1. **Better State Management**: Clear separation between UI state and Nostr state
2. **Session Persistence**: Automatic session restoration on app launch
3. **Modern Patterns**: Uses latest Swift concurrency and observation patterns
4. **Consistent Architecture**: Matches other example apps in the repository
</file>

<file path="Olas-progress.md">
# Olas Development Progress

This document tracks the development progress of Olas - A picture-first Nostr experience.

## Session 11 - Discovery Tab Implementation

Successfully implemented the complete Discovery (Explore) tab for Olas with masonry grid layout, category filtering, and trending hashtags.

### Accomplishments:

1. **ExploreView with Masonry Grid**:
   - Implemented 2-column masonry layout with variable heights
   - Smooth scrolling performance with LazyVGrid
   - Dynamic height assignment for visual variety
   - Proper image aspect ratio preservation
   - Only shows posts with images

2. **Category Pills System**:
   - 9 categories: Trending, Art, Photography, Nature, Portrait, Street, Landscape, Food, Architecture
   - Each category has unique icon and hashtag association
   - Smooth animated selection transitions
   - Horizontal scrolling with no indicators
   - Haptic feedback on selection

3. **Trending Hashtags**:
   - Horizontal scrolling pills below categories
   - Shows hashtag name, post count, and velocity (posts/hour)
   - Tap to open detailed hashtag view
   - Only visible in Trending category
   - Mock data for now (to be replaced with real analytics)

4. **HashtagView - Detailed Hashtag Page**:
   - Large gradient hashtag display
   - Follow/Following toggle button
   - Statistics: Total posts, Today's posts, Unique authors
   - 3-column grid layout for hashtag posts
   - Empty state with encouraging message
   - Modal presentation with Done button

5. **PostDetailView**:
   - Full post view with multi-image support
   - Author info with avatar and timestamp
   - Rich text content rendering
   - Engagement buttons: Like, Reply, Zap, Share
   - Reactive loading of likes and replies counts
   - Navigation to author profile

6. **Search Functionality**:
   - Search bar with magnifying glass icon
   - Real-time filtering of posts by content
   - Placeholder text guides users
   - Submit action with haptic feedback

7. **Supporting Components**:
   - CategoryPill: Styled selection pills with icons
   - TrendingHashtagPill: Trending data display
   - ExploreGridItem: Individual grid items with loading states
   - HashtagGridItem: Optimized for hashtag view
   - ShimmerView: Loading placeholder animation

### Technical Implementation:

1. **Fixed NDK API Usage**:
   - Changed from `ndk.subscribe()` to `ndk.observe().collect()` pattern
   - Fixed EventKind.text to EventKind.textNote
   - Corrected NDKFilter initialization with proper parameters
   - Fixed tags parameter to use `[String: Set<String>]` format

2. **Reactive Data Flow**:
   - Posts load immediately and render as they arrive
   - Profile information loads asynchronously per item
   - No blocking waits for data
   - Proper error handling throughout

3. **Platform Compatibility**:
   - Fixed haptic feedback with platform-specific code
   - Proper navigation bar handling for iOS/macOS
   - Conditional compilation where needed

### Build Status:
 Project builds successfully with swift build
 All Discovery features implemented
 NDK API usage corrected and working
 Reactive architecture maintained

### Files Created/Modified:
- `ExploreView.swift` - Main explore tab
- `HashtagView.swift` - Hashtag detail view
- `PostDetailView.swift` - Individual post view
- `CategoryPill.swift` - Category selection component
- `TrendingHashtagPill.swift` - Trending hashtag display
- `ExploreGridItem.swift` - Grid item component
- `MainTabView.swift` - Updated to use ExploreView
- `DesignSystem.swift` - Added missing like color

## Session 10 - Content Creation Implementation

Successfully implemented the complete content creation flow for Olas:

### Accomplishments:

1. **CreatePostView with Full Feature Set**:
   - Enhanced photo picker with multi-select support (up to 4 images)
   - Integrated camera capture button
   - Image carousel with remove functionality
   - Filter indicators on edited images
   - Upload progress tracking with visual feedback

2. **OlasCameraView - Custom Camera UI**:
   - Built custom camera interface with AVFoundation
   - Timer functionality (3s, 10s countdown)
   - Flash modes (off/on/auto) with toggle
   - Front/back camera switching
   - Grid overlay for composition
   - Gesture controls and animations
   - Capture feedback with haptics

3. **OlasImageEditor - Professional Image Editing**:
   - Implemented all 12 filters from specifications:
     - Olas Classic (subtle warmth and contrast)
     - Neon Tokyo (cyberpunk with blue tones)
     - Golden Hour (warm highlights)
     - Nordic Frost (desaturated blues)
     - Vintage Film (sepia with vignette)
     - Black Pearl (rich black and white)
     - Coral Dream (peachy soft tones)
     - Electric Blue (high contrast blues)
     - Autumn Maple (warm oranges and reds)
     - Mint Fresh (cool greens)
     - Purple Haze (moody purples)
   - Adjustment controls:
     - Brightness (-100 to +100)
     - Contrast (50% to 200%)
     - Saturation (0% to 200%)
     - Rotation with quick -90/+90 buttons
   - Filter preview thumbnails
   - Reset all adjustments button

4. **OlasCaptionComposer - Rich Text Input**:
   - Custom UITextView integration for precise cursor tracking
   - Real-time @mention suggestions with user search
   - #hashtag autocomplete
   - Reactive profile loading with NDK observe()
   - Smooth animations and transitions

5. **Blossom Integration**:
   - Multi-server upload with fallback (Primal, Nostr.wine, Damus)
   - Proper NIP-92 imeta tag creation
   - SHA256 hash calculation
   - File metadata including dimensions
   - Auth event creation with expiration
   - Progress tracking during upload

6. **Cross-Platform Support**:
   - Added conditional compilation for iOS/macOS
   - Platform-specific implementations where needed
   - Maintains functionality on both platforms
   - Graceful degradation for macOS

### Technical Details:

- Used NDKSwift's reactive patterns throughout
- Proper error handling and user feedback
- Haptic feedback for all interactions
- Memory-efficient image processing
- Follows Olas design system perfectly
- All components render immediately without waiting

### Build Status:
 Project builds successfully with swift build
 All content creation features implemented
 Reactive architecture maintained throughout
 Cross-platform compatibility achieved

## Session 12 - Reactive Architecture Implementation

Successfully implemented proper reactive data loading patterns throughout Olas, following best practices from NutsackiOS:

### Accomplishments:

1. **FeedView Reactive Patterns**:
   - Migrated from simple event filtering to NDKDataSource observe pattern
   - Implemented proper kind 20 (picture posts) support alongside kind 1
   - Added reactive engagement counting with real-time updates
   - Engagement counts (likes, replies) now update as events arrive
   - Proper task management and cancellation
   - Limited feed size to 200 items for performance

2. **FeedViewModel Architecture**:
   - Reactive profile loading using profileManager.observe()
   - Reactive engagement tracking for likes and replies
   - Proper sorting by timestamp with efficient insertion
   - Clean separation of concerns between view and data

3. **ExploreView Reactive Refactor**:
   - Created ExploreViewModel with reactive patterns
   - Replaced collect(timeout:) with continuous observe streams
   - Added proper category filtering with hashtag support
   - Reactive profile loading for grid items
   - Efficient task management and cancellation
   - Support for both kind 20 and kind 1 events

4. **Data Models Enhancement**:
   - FeedItem now includes engagement counts
   - ExploreItem with proper image URL extraction
   - Support for NIP-92 imeta tags for kind 20 events
   - Fallback to content parsing for kind 1 events

### Technical Implementation:

- **Reactive Subscriptions**: All data now flows through NDK observe() with real-time updates
- **Efficient Memory Usage**: Limited collections and proper task cancellation
- **Performance**: Insert sorted maintains chronological order without full array sorts
- **Error Handling**: Graceful degradation when data isn't available
- **Cache Policy**: Smart use of cacheWithNetwork and cacheOnly where appropriate

### Build Status:
 Project builds successfully with swift build
 iOS app builds successfully with xcodebuild for iPhone 15 Pro
 All reactive patterns implemented correctly
 NDK API usage follows best practices
 Performance optimizations in place

## Session 13 - Settings Implementation

Successfully implemented comprehensive Settings functionality for Olas with proper reactive patterns and professional UI design.

### Accomplishments:

1. **Settings Main View**:
   - Redesigned with modern iOS styling
   - Organized sections with visual icons
   - Proper navigation to sub-sections
   - Integrated with Olas design system
   - Background color consistency

2. **Relay Management**:
   - Full relay configuration interface
   - Real-time connection status indicators
   - Add/remove relay functionality
   - Popular relay suggestions
   - Connection statistics (connected count, latency)
   - Read/write permissions per relay
   - Reconnect functionality for disconnected relays

3. **Account Settings**:
   - Profile display with avatar
   - Public/private key management
   - Key backup with security warnings
   - Copy to clipboard functionality
   - Biometric lock toggle
   - Session management UI
   - Data export/clear cache options

4. **Notification Settings**:
   - Master toggle for push notifications
   - Granular control by notification type:
     - New followers
     - Mentions
     - Replies
     - Zaps
     - Direct messages
   - Sound selection with preview
   - Quiet hours configuration

5. **Theme Settings**:
   - Appearance selection (Auto/Light/Dark)
   - Accent color picker with 6 options
   - App icon selector with 4 variants
   - Live preview of theme changes
   - Proper gradient implementations

### Technical Implementation:

- **Reactive Patterns**: Used throughout for real-time updates
- **Platform Compatibility**: iOS/macOS conditional compilation
- **Error Handling**: Proper alerts and user feedback
- **Security**: Warning dialogs for sensitive operations
- **Design Consistency**: All views follow Olas design system

### Build Status:
 Project builds successfully with xcodebuild
 iOS app target builds for iPhone 15 Pro simulator
 All Settings features implemented
 Navigation and UI working correctly

### Files Created:
- `RelayManagementView.swift` - Complete relay configuration
- `AccountSettingsView.swift` - Account and security settings
- `NotificationSettingsView.swift` - Push notification preferences
- `ThemeSettingsView.swift` - Appearance customization
- Updated `SettingsView.swift` - Main settings navigation

### Next Steps:

1. **Polish & Performance**:
   - Fix navigation deprecation warnings
   - Animations and transitions
   - Image caching optimization
   - Error recovery flows

2. **Feature Completion**:
   - Blossom server management
   - Blocked users interface
   - Content filtering settings
   - About & Help sections

3. **Testing & Deployment**:
   - Unit tests for reactive features
   - UI tests for critical flows
   - Performance profiling
   - App Store preparation

## Session 14 - ProfileView and Build Fixes

Successfully implemented ProfileView with reactive data loading and fixed all build errors.

### Accomplishments:

1. **ProfileView Implementation**:
   - Complete profile header with parallax scrolling banner
   - Animated profile statistics with count-up animation
   - 3D rotation effect on avatar during scroll
   - Follow/unfollow functionality with reactive updates
   - Three-tab layout: Posts, Replies, Zaps
   - 3-column image grid for picture posts
   - Reactive data loading throughout

2. **Profile Data Loading**:
   - Reactive profile observation using profileManager
   - Picture posts loading for kind 20 (NIP-68) events
   - Replies loading for kind 1111 (NIP-22) events
   - Following count from contact list (kind 3)
   - Follower count set to N/A (complex to calculate)
   - Real-time updates as events arrive

3. **Build Error Fixes**:
   - Fixed NDKFilter tags syntax to use `[String: Set<String>]`
   - Fixed `fetchEvent` to use `observe().collect()` pattern
   - Fixed async/await issues in ZapView and FeedView
   - Fixed camera deprecation warning with iOS 16+ API
   - Added ImetaUtils for image metadata extraction
   - All components now compile successfully

4. **Component Integration**:
   - ProfileView properly integrated with navigation
   - Full-screen image viewer for posts
   - Reply cells with rich text support
   - Zap cells with amount and message display
   - Proper navigation from feed to profiles

### Technical Details:

- **Reactive Architecture**: All data flows through NDK observe patterns
- **Performance**: Efficient insertion and limited data sets
- **Error Handling**: Graceful fallbacks for missing data
- **Platform Support**: iOS/macOS conditional compilation
- **Design System**: Follows Olas specifications perfectly

### Build Status:
 Project builds successfully with xcodebuild
 All compilation errors resolved
 iOS app builds for iPhone 15 Pro simulator
 All reactive patterns working correctly

### Files Created/Modified:
- `ProfileView.swift` - Complete profile implementation
- `ImetaUtils.swift` - Image metadata extraction utilities
- `ReplyView.swift` - Fixed NDKFilter tags syntax
- `FeedView.swift` - Fixed async/await issues
- `OlasCameraView.swift` - Fixed iOS 16 deprecation
- `ZapView.swift` - Fixed async/await warning

### Next Steps:

1. **Polish & Performance**:
   - Fix remaining navigation deprecation warnings
   - Add more animations and transitions
   - Optimize image loading and caching
   - Profile performance and memory usage

2. **Missing Features**:
   - Stories (24-hour ephemeral content)
   - Direct Messages (NIP-04 encrypted)
   - Creator tools and analytics
   - Advanced search functionality

3. **Testing & Deployment**:
   - Unit tests for reactive patterns
   - UI tests for critical flows
   - Beta testing with TestFlight
   - App Store preparation
</file>

<file path="Package.swift">
// swift-tools-version: 5.10
import PackageDescription
let package = Package(
    name: "Olas",
    platforms: [
        .iOS(.v17),
        .macOS(.v14)
    ],
    dependencies: [
        .package(path: "../.."),
        .package(url: "https://github.com/zeugmaster/CashuSwift.git", from: "0.1.0")
    ],
    targets: [
        .executableTarget(
            name: "Olas",
            dependencies: [
                .product(name: "NDKSwift", package: "NDKSwift-z94ws0"),
                .product(name: "CashuSwift", package: "CashuSwift")
            ],
            path: "Olas"
        )
    ]
)
</file>

<file path="project.yml">
name: Olas
options:
  bundleIdPrefix: com.olas
  deploymentTarget:
    iOS: "17.0"
settings:
  base:
    # Code Signing Settings - Update these with your values
    DEVELOPMENT_TEAM: "456SHKPP26"
    CODE_SIGN_STYLE: Automatic
    CODE_SIGN_IDENTITY: "Apple Development"
    PROVISIONING_PROFILE_SPECIFIER: ""
    # App Settings
    PRODUCT_BUNDLE_IDENTIFIER: com.olas.app
    MARKETING_VERSION: "1.0.0"
    CURRENT_PROJECT_VERSION: "2"
packages:
  NDKSwift:
    url: https://github.com/pablof7z/NDKSwift
    branch: master
targets:
  Olas:
    type: application
    platform: iOS
    sources: 
      - Olas
    dependencies:
      - package: NDKSwift
        product: NDKSwift
    info:
      path: Olas/Info.plist
      properties:
        UILaunchStoryboardName: LaunchScreen
        LSRequiresIPhoneOS: true
        NSCameraUsageDescription: "Olas needs access to your camera to capture photos"
        NSPhotoLibraryUsageDescription: "Olas needs access to your photo library to select images"
        NSPhotoLibraryAddUsageDescription: "Olas needs permission to save photos to your library"
        UIApplicationSceneManifest:
          UIApplicationSupportsMultipleScenes: false
        UIRequiredDeviceCapabilities:
          - arm64
    settings:
      base:
        INFOPLIST_FILE: Olas/Info.plist
        PRODUCT_NAME: Olas
        ASSETCATALOG_COMPILER_APPICON_NAME: AppIcon
        TARGETED_DEVICE_FAMILY: "1"
        SUPPORTS_MACCATALYST: false
        SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD: false
        SWIFT_VERSION: 5.9
</file>

<file path="refresh-project.sh">
#!/bin/bash
set -euo pipefail
# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"
echo -e "${YELLOW} Refreshing Xcode project after file changes...${NC}"
# Clean derived data if requested
if [[ "${CLEAN:-false}" == "true" ]]; then
    echo -e "${YELLOW} Cleaning derived data...${NC}"
    rm -rf .build/DerivedData
fi
# Regenerate project
xcodegen generate --spec project.yml
echo -e "${GREEN} Project refreshed! The .xcodeproj now includes all current files.${NC}"
echo -e "${GREEN}   Code signing is configured from project.yml${NC}"
</file>

<file path="README.md">
# Olas - Picture-First Decentralized Social Media

<div align="center">
  <img src="Resources/olas-icon.png" alt="Olas Logo" width="200"/>
  
  [![Platform](https://img.shields.io/badge/platform-iOS%2017%2B-lightgrey)](https://developer.apple.com/ios/)
  [![Swift](https://img.shields.io/badge/Swift-5.9-orange)](https://swift.org)
  [![NDKSwift](https://img.shields.io/badge/NDKSwift-0.2.0-blue)](https://github.com/pablof7z/NDKSwift)
  [![License](https://img.shields.io/badge/license-MIT-green)](LICENSE)
</div>

## Overview

Olas is a cutting-edge decentralized social media application built on the [Nostr protocol](https://nostr.com), designed with a strong emphasis on visual content sharing. It combines the power of decentralized social networking with professional-grade photo creation and editing tools, creating a unique platform for visual storytelling that is censorship-resistant and user-controlled.

## Features

###  Picture-First Content Experience
- **Visual Feed**: Dynamic image and video feed with progressive loading using Blurhash
- **Multi-Image Posts**: Share multiple images in a single post
- **Professional Camera**: In-app camera with timer, flash control, and composition grid
- **Advanced Image Editor**: 12 custom filters and granular adjustments for brightness, contrast, saturation, and rotation
- **Decentralized Storage**: Images uploaded to multiple Blossom servers using [NIP-92](https://github.com/nostr-protocol/nips/blob/master/92.md)

###  Nostr-Native Social Features
- **Self-Sovereign Identity**: Control your cryptographic keys (nsec/pubkey)
- **Rich Interactions**: Likes, threaded replies ([NIP-22](https://github.com/nostr-protocol/nips/blob/master/22.md)), and Bitcoin Lightning zaps ([NIP-57](https://github.com/nostr-protocol/nips/blob/master/57.md))
- **Rich Text Editor**: Real-time @mention suggestions and #hashtag autocomplete
- **Encrypted DMs**: Private messaging with support for [NIP-44](https://github.com/nostr-protocol/nips/blob/master/44.md) encryption
- **Ephemeral Stories**: 24-hour disappearing visual content

###  Discovery & Exploration
- **Explore Tab**: Masonry grid layout for content discovery
- **Category Filtering**: Art, Photography, Nature, and other categories
- **Trending Hashtags**: Real-time popularity indicators with velocity metrics
- **Universal Search**: Find posts, hashtags, and users

###  Integrated Bitcoin Lightning & Cashu Wallet
- **NIP-60 Wallet**: Built-in support for Bitcoin Lightning and Cashu ecash
- **Balance Management**: Visual breakdown of funds across multiple Cashu mints
- **Seamless Transactions**: Send/receive sats via Lightning, ecash tokens, and Nostr zaps
- **QR Code Scanner**: Easy payment processing
- **Mint Management**: Add, remove, and monitor multiple Cashu mints

###  Comprehensive Settings & Customization
- **Account Management**: Profile settings, key backup, biometric lock
- **Relay Control**: Granular management of Nostr relay connections
- **Notification Settings**: Customizable alerts with quiet hours
- **Theme Customization**: Light/dark modes, accent colors, alternate app icons

## Requirements

- iOS 17.0+
- Xcode 15.0+
- Swift 5.9+

## Installation

### Building from Source

1. Clone the repository:
```bash
git clone https://github.com/pablof7z/Olas-iOS.git
cd Olas-iOS
```

2. Install XcodeGen if you haven't already:
```bash
brew install xcodegen
```

3. Generate the Xcode project:
```bash
./refresh-project.sh
```

4. Open the project in Xcode:
```bash
open Olas.xcodeproj
```

5. Build and run the project on your device or simulator

### TestFlight

Coming soon! We'll be releasing Olas on TestFlight for beta testing.

## Development

### Building

```bash
# Refresh project after file changes
./refresh-project.sh

# Build with clean output
./build.sh

# Build for specific device
DESTINATION="platform=iOS Simulator,name=iPhone 16 Pro" ./build.sh
```

### Deploying to TestFlight

```bash
./deploy.sh
```

## Architecture

Olas is built using modern iOS development technologies:

- **SwiftUI** for the user interface
- **NDKSwift** for Nostr protocol interactions
- **Core Image** for advanced photo editing
- **AVFoundation** for camera functionality
- **SwiftData** for local storage
- **Combine** for reactive programming

## Contributing

We welcome contributions! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with [NDKSwift](https://github.com/pablof7z/NDKSwift)
- Uses the [Nostr Protocol](https://nostr.com)
- Integrates [Cashu](https://cashu.space) for ecash functionality

## Contact

- Nostr: `npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft`
- GitHub: [@pablof7z](https://github.com/pablof7z)

---

<div align="center">
  Made with  for the decentralized future
</div>
</file>

</files>
